{"/":{"title":"A Curious Quest for Code and Clarity","content":"Hello There ,\n\nWelcome to my little end of these digital woods. I frequently come across  [[thoughts/general-specific problems]] , that there seems to be no easy answer for and I end up having to learn it the hard way myself. I often tend to note down the more tricky parts as I go in Obsidian up till now.  Since it's all markdown anyway I decided to publish them here. These days  they are generally concerning  [Android](/tags/android),  [Software](/tags/software) in general or  [Backend](/tags/backend). \n\nSome days I will find myself solving [leetcode questions](/dsa). I have been noting down all the solutions since I started grinding in 2021. And since I have been using markdown I published those as well.\n\nOn other days when I am doom scrolling twitter and every arm-chair [philosopher](/tags/philosophy) is trying to convince the world that  [[posts/AGI Will Never Be Hostile But Humans Will|AI cannot think]] or that  [[thoughts/Meaning is Objective|all meaning is subjective]], I resist the urge to part-take in a thread war and instead write out my thoughts over here.\n\nAs for this blog, you see I was not going to sit around and let all the 'Join my newsletter to 10x ChatGPT' schmucks get ahead of me. So I ended to doing a little digging and searching and made myself this neat little blog using [Hugo](https://github.com/gohugoio/hugo), [Quartz](https://github.com/jackyzha0/quartz) and [Obsidian](https://obsidian.md/) .  \n\nYou can find my socials along with my resume in the footer. Don't hesitate to reach out. Enjoy!\n","lastmodified":"2024-07-04T20:24:17.033181857Z","tags":[]},"/dsa/1.-Two-Sum":{"title":"1. Two Sum","content":"","lastmodified":"2024-07-04T20:24:17.033181857Z","tags":[]},"/dsa/1008.-Construct-Binary-Search-Tree-from-Preorder-Traversal":{"title":"1008. Construct Binary Search Tree from Preorder Traversal","content":"\n## Problem Statement\n\n\nPattern: \nRelated: [[98. Validate BST]]\n\n---\n\n## Ranged Solution\nFrom [[98. Validate BST]]\n``` java\nint i = 0;\n\nprivate TreeNode validate(int[] pre, int min, int max) {\n\tif(i \u003e= pre.length || pre[i] \u003c min || pre[i] \u003e max) return null;\n\t\n\tTreeNode root = new TreeNode(pre[i++]);\n\troot.left = validate(pre, min, root.val);\n\troot.right = validate(pre, root.val, max);\n\t\n\treturn root;\n}\n\npublic TreeNode bstFromPreorder(int[] preorder) {\n\treturn validate(preorder, Integer.MIN_VALUE, Integer.MAX_VALUE);\n}\n```\n\n``` java\nint i = 0;\npublic TreeNode bstFromPreorder(int[] A) {\n\treturn bstFromPreorder(A, Integer.MAX_VALUE);\n}\n\npublic TreeNode bstFromPreorder(int[] A, int max) {\n\tif (i == A.length || A[i] \u003e bound) return null;\n\tTreeNode root = new TreeNode(A[i++]);\n\troot.left = bstFromPreorder(A, root.val);\n\troot.right = bstFromPreorder(A, max);\n\treturn root;\n}\n```\nyou dont need lower bound since it is preorder so lower bound will alwys be true\n\n## Iterative Solution\n``` java\npublic TreeNode bstFromPreorder(int[] pre) {\n\tDeque\u003cTreeNode\u003e stack = new LinkedList\u003c\u003e();\n\tTreeNode root = new TreeNode(pre[0]), node;\n\tstack.push(root);\n\tfor(int i = 1; i \u003c pre.length; i++) {\n\t\tnode = new TreeNode(pre[i]);\n\t\tif(pre[i] \u003c stack.peek().val) {\n\t\t\tstack.peek().left = node; \n\t\t} else {\n\t\t\tTreeNode parent = stack.peek();\n\t\t\twhile (!stack.isEmpty() \u0026\u0026 pre[i] \u003e stack.peek().val) \n\t\t\t\tparent = stack.pop();\n\t\t\tparent.right = node;\n\t\t}\n\t\tstack.push(node);\n\t}\n\treturn root;\n}\n```\n","lastmodified":"2024-07-04T20:24:17.033181857Z","tags":["dsadeck","bst"]},"/dsa/101.-Symmetric-Tree":{"title":"101. Symmetric Tree","content":"\n## Problem Statement\n\n\nPattern: \n\n---\n\n## Solution\n``` java\npublic boolean compare (TreeNode A, TreeNode B){\n\tif(A == null \u0026\u0026 B == null) return true;     // both null\n\tif(A == null || B == null) return false;    // one of them null\n\t\t\n\tif(A.val != B.val) return false;\n\t\n\treturn compare(A.left, B.right) \u0026\u0026 compare(A.right, B.left);\n}\n\npublic boolean isSymmetric(TreeNode root) {\n\tif(root == null) return false;\n\treturn compare(root.left, root.right);\n}\n```\n\n### Notes\n- since symetric `compare(A.left, B.right) \u0026\u0026 compare(A.right, B.left)` - mirror images\n\n","lastmodified":"2024-07-04T20:24:17.033181857Z","tags":["dsadeck","binarytrees"]},"/dsa/1049.-Last-Stone-Weight-II":{"title":"1049. Last Stone Weight II","content":"\n## Problem Statement\n[Last Stone Weight II - LeetCode](https://leetcode.com/problems/last-stone-weight-ii/\n[Aditya Verma : Minimum Subset Difference](https://youtu.be/-GtpxG6l_Mc?list=PL_z_8CaSLPWekqhdCPmFohncHwz8TY2Go)\n\nPattern: [[Pattern DP Subset Sum]] \nRelated: [[416. Partition Equal Subset Sum]]\n\n---\n\n## Solution\nThis is a minimise subset/partition sum\n\n``` java\nInteger[][] dp;  \n  \nint f(int[] nums, int n, int k) {  \n   if (n \u003c 0) return 0;  \n   if (dp[n][k] != null) return dp[n][k];  \n   if (nums[n] \u003c= k) return dp[n][k] = Math.max(  \n         nums[n] + f(nums, n - 1, k - nums[n]),  \n         f(nums, n - 1, k)  \n      );  \n   return dp[n][k] = f(nums, n - 1, k);  \n}  \n  \npublic int lastStoneWeightII(int[] stones) {  \n   int sum = 0 ;  \n   for (int num : stones) sum += num;  \n   dp = new Integer[stones.length + 1][sum / 2 + 1];  \n   int maxPartitionSum = f(stones, stones.length - 1, sum / 2); // find partition w sum \u003c= sum/2  \n   return (sum - maxPartitionSum) - maxPartitionSum;   // sum of (second partition - first partition)  \n}\n```\nTC : $n * sum/2$ - 4ms 85% solution\nSC : \n\n### Notes\n[Logic](https://leetcode.com/problems/last-stone-weight-ii/discuss/294888/JavaC++Python-Easy-Knapsacks-DP/918974)\n\u003e For any sequence of operations, the algebra boils down to difference of two sums\n\nFor example\n```\n(((a - b) - c) - d) = a - b - c - d = (a) - (b + c + d)  \n((d - (a - b) )- c) = d - a + b - c = (d + b) - (a + c)\n```\n\nSo all we have to do is find the one of the groups, such that its sum is as close as possible to the other, so if total sum is 24, we have to find the group with sum closest to 12.\n\nEssentially it boils down to an [[Pattern DP Subset Sum]] problem.\n\n## Iterative\n#todoleetcode \n","lastmodified":"2024-07-04T20:24:17.033181857Z","tags":["dsadeck","dp"]},"/dsa/105.-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal":{"title":"105. Construct Binary Tree from Preorder and Inorder Traversal","content":"\n## Problem Statement\n\n\nPattern: \nRelated: [[106.Â Construct Binary Tree from Inorder and Postorder Traversal]]\n\n---\n\n## Solution\n``` java\nint[] preOrder;\nint[] inOrder;\n\nprivate TreeNode build(int pre, int inStart, int inEnd) {\n\tif (pre \u003e preOrder.length - 1 || inStart \u003e inEnd) return null;\n\n\tTreeNode root = new TreeNode(preOrder[pre]);\n\tint rootIn = inStart;\n\twhile (inOrder[rootIn] != root.val) rootIn++;\n\t\n\t// preRight = pre + no. of els in preLeft\n\tint preLeft = pre + 1, preRight = pre + (rootIn - inStart + 1);\n\n\troot.left = build(preLeft, inStart, rootIn - 1);\n\troot.right = build(preRight, rootIn + 1, inEnd);\n\n\treturn root;\n}\n\npublic TreeNode buildTree(int[] preOrderArr, int[] inOrderArr) {\n\tpreOrder = preOrderArr;\n\tinOrder = inOrderArr;\n\n\treturn build(0, 0, inOrderArr.length - 1);\n}\n```\n\n### Notes\n- `preOrder` gives you roots in sequence of preOrder traversal `N L R`\n- so for each elment in `preOrder` -\u003e  `pre`, all the elements before it in `inOrder` belong to its left subtree, and all the elements after it belong to its right subtree\n- for each `root = new TreeNode(preOrder[pre])`\n\t- find `rootIn` (root index)  in `inOrder`\n\t- calculate `preLeft`, and `preRight` (roots of the left and right subtree of `root`)\n\t- and inorder start and end `inStart` and `inEnd`\n\t\t- for left subtree : `inStart -\u003e rootIn-1` (current inorderStart to rootindex)\n\t\t- for right subtree : `rootIn + 1  -\u003e inEnd` (rootIndex to current inorderEnd) \n\t- set the `root.left` and `root.right` to `build()` value of left and right ranges of `inOrder` and `pre` \n \n\n\n\n## Simplified Code\nsince `build` is traversing preorder, `index` for the `preOrder` array will increase desirably, eliminating the need for `pre, preLeft, preRight`\n``` java\nint[] preOrder;\nint[] inOrder;\nint index;\n\nprivate TreeNode build(int inStart, int inEnd) {\n\tif (index \u003e preOrder.length - 1 || inStart \u003e inEnd) return null;\n\t\n\tTreeNode root = new TreeNode(preOrder[index++]);\n\tint pos = inStart;\n\twhile (inOrder[pos] != root.val) pos++;\n\n\troot.left = build(inStart, pos - 1);\n\troot.right = build(pos + 1, inEnd);\n\n\treturn root;\n}\n\npublic TreeNode buildTree(int[] preOrderArr, int[] inOrderArr) {\n\tpreOrder = preOrderArr;\n\tinOrder = inOrderArr;\n\tindex = 0;\n\treturn build(0, inOrderArr.length - 1);\n}\n```\n","lastmodified":"2024-07-04T20:24:17.033181857Z","tags":["dsadeck","binarytrees"]},"/dsa/106.-Construct-Binary-Tree-from-Inorder-and-Postorder-Traversal":{"title":"106. Construct Binary Tree from Inorder and Postorder Traversal","content":"\n## Problem Statement\n\n\nPattern: \nRelated: [[105. Construct Binary Tree from Preorder and Inorder Traversal]]\n\n---\n\n## Solution\n``` java\nint[] preOrder;\nint[] postOrder;\nint[] inOrder;\nint index;\n\n// find position of rootVal in inorder arr\nint posInorder(int start, int rootVal) {\n\twhile (inOrder[start] != rootVal)start++;\n\treturn start;\n}\n\nTreeNode buildPost(int inStart, int inEnd) {\n\tif(index \u003c 0 || inStart \u003e inEnd) return null;\n\n\tTreeNode root = new TreeNode(postOrder[index--]);\n\tint pos = posInorder(inStart, root.val);\n\n\troot.right = buildPost(pos + 1, inEnd);\n\troot.left = buildPost(inStart, pos-1);\n\n\treturn root;\n}\n\nTreeNode buildTree(int[] inOrderArr, int[] postOrderArr) {\n\tpostOrder = postOrderArr;\n\tinOrder = inOrderArr;\n\tindex = postOrder.length-1;\n\treturn buildPost(0, inOrder.length-1);\n}\n```\n\n### Notes\n- to understand this, understand [[105. Construct Binary Tree from Preorder and Inorder Traversal]]\n\n\n","lastmodified":"2024-07-04T20:24:17.033181857Z","tags":["dsadeck","binarytrees"]},"/dsa/114.-Flatten-Binary-Tree":{"title":"114. Flatten Binary Tree","content":"\n# Problem Statement\n[114. Flatten Binary Tree to Linked List - LeetCode](https://leetcode.com/problems/flatten-binary-tree-to-linked-list/)\n\n## Morris Travel Solution\n[[Morris Traversals of Binary Tree]]\n``` java\npublic void flatten (TreeNode root){\n\tTreeNode node = root;\n\twhile(node != null) {\n\t\tif(node.left != null) { // nodes remaining in left\n\t\t\t// get predecessor\n\t\t\tTreeNode pred = node.left;\n\t\t\twhile(pred.right!=null) pred = pred.right;\n\t\t\t// thread and flatten\n\t\t\tpred.right = node.right;\n\t\t\tnode.right = node.left;\n\t\t\tnode.left = null;\n\t\t}\n\t\tnode = node.right;      // traverse right\n\t}\n}\n```\n\n## Reverse Postorder Solution\n``` java\nprivate TreeNode prev = null;\n\npublic void flatten(TreeNode root) {\n    if (root == null) return;\n    \n    flatten(root.right);\n    flatten(root.left);\n    \n    // chain prev to the right\n    root.right = prev;\n    root.left = null;\n    \n    // update prev\n    prev = root;\n}\n```\n - This solution essentially starts chaining the 'linked list' from the end\n\n\n### Without Global Variable\n``` java\nprivate TreeNode flatten(TreeNode root, TreeNode prev) {\n\tif (root == null) return prev;\n\n\tprev = flatten(root.right, prev);\n\tprev = flatten(root.left, prev);\n\n\t// chain prev to the right\n\troot.right = prev;\n\troot.left = null;\n\n\treturn root;\n}\n\n\npublic TreeNode flatten(TreeNode root) {\n\treturn flatten(root, null);\n}\n```\n\n \n\n","lastmodified":"2024-07-04T20:24:17.033181857Z","tags":[]},"/dsa/1143.-Longest-Common-Subsequence":{"title":"1143. Longest Common Subsequence","content":"\n## Problem Statement\n\n\nPattern: \n\n---\n\n## Solution\n``` java\nInteger[][] cache;\npublic int longestCommonSubsequence(String text1, String text2) {\n\t\tcache = new Integer[text1.length()+1][text2.length()+1];\n\t\treturn dp(text1.toCharArray(), text2.toCharArray(), text1.length()-1, text2.length()-1);\n}\n\npublic int dp(char[] t1, char[] t2, int n1, int n2) {\n\tif(n1 \u003c 0 || n2 \u003c 0) return 0;\n\tif(cache[n1][n2]!=null) return cache[n1][n2];\n\t\n\tif(t1[n1] == t2 [n2])  return cache[n1][n2] = dp(t1, t2, n1-1, n2-1) + 1;\n\t\n\treturn cache[n1][n2] = Math.max(\n\t\tdp(t1, t2, n1-1, n2), dp(t1, t2, n1, n2-1)\n\t);\n\t\n}~\n```\nTC : $n*m$\nSC : $n*m$\n\n\n\n","lastmodified":"2024-07-04T20:24:17.033181857Z","tags":["dsadeck","strings","dp"]},"/dsa/1161.-Maximum-Level-Sum-of-a-Binary-Tree":{"title":"1161. Maximum Level Sum of a Binary Tree","content":"\n## Problem Statement\n\n\nPattern: \nRelated: [[BT Sum at Kth Level]]\n\n---\n\n## Solution\n``` java\npublic int maxLevelSum (Node root){\n\tint level = 0, sum = 0, maxSum = Integer.MIN_VALUE, maxLevel = level;\n\tQueue\u003cNode\u003e q = new LinkedList\u003c\u003e();\n\tq.add(root);\n\t\n\twhile(!q.isEmpty()) {\n\t\tint size = q.size(); sum = 0; level++;\n\t\t\n\t\twhile (size-- \u003e 0) {\n\t\t\tNode node = q.poll();\n\t\t\tsum += node.val;\n\t\t\tif(node.left != null)q.add(node.left);\n\t\t\tif(node.right != null)q.add(node.right);\n\t\t}\n\t\t\n\t\t// update maxSum maxLevel\n\t\tif(sum \u003e maxSum) {\n\t\t\tmaxSum = sum;\n\t\t\tmaxLevel = level;\n\t\t}\n\t}\n\treturn maxLevel;\n}\n```\n\n### Notes\n- same as [[BT Sum at Kth Level]], except you keep track of maxSum, and return its level\n\n\n","lastmodified":"2024-07-04T20:24:17.033181857Z","tags":["dsadeck","binarytrees"]},"/dsa/121.-Best-Time-to-Buy-and-Sell-Stock":{"title":"121. Best Time to Buy and Sell Stock","content":"\n## Problem Statement\n\n\nPattern: \n\n---\n\n## Solution\n``` java\npublic int maxProfit (int[] prices){\n\tint max_price = Integer.MIN_VALUE, maxProfit = 0;\n\tfor (int i = prices.length-1; i \u003e= 0 ; i--) {\n\t\tmax_price = Math.max(max_price, prices[i]);\n\t\tmaxProfit = Math.max(maxProfit , max_price - prices[i]);\n\t}\n\treturn maxProfit;\n}\n```\n\n\n``` java\n\t    public int maxProfit (int[] prices){\n\t\t\tint min = Integer.MAX_VALUE, maxProfit = Integer.MIN_VALUE;\n\t\t\tfor (int num : prices) {\n\t\t\t\t// update min stock price so far\n\t\t\t\tmin = Math.min(num, min);\n\t\t\t\t// max (max so far, profit if sold today)\n\t\t\t\tmaxProfit = Math.max(maxProfit, num - min);\n\t\t\t}\n\t\t\treturn maxProfit;\n\t    }\n```\n\nBoth are same, do it forwards or backwards\n\n","lastmodified":"2024-07-04T20:24:17.033181857Z","tags":["dsadeck","arrays"]},"/dsa/1217.-Minimum-Cost-to-Move-Chips-to-The-Same-Position":{"title":"1217. Minimum Cost to Move Chips to The Same Position","content":"\n## Problem Statement\n\n\nPattern: \n\n---\n\n## Solution\n``` java\npublic int minCostToMoveChips(int[] position) {\n\tint evenCount = 0, oddCount = 0;\n\tfor(int pos : position)\n\t\tif((pos \u0026 1) == 0) evenCount++;\n\t\telse oddCount++;\n\treturn Math.min(evenCount, oddCount);\n}\n```\n\n### Notes\n- cost of moving coins back over in 2s increments is 0.\n\t- Odd positions move all the way back to pos 1 for free\n\t- Even position move all the way back to 0 for free\n\t- Now depending on if no. of coins on 1 or 0 is less, you can shift the minimum no. of coins onto the other stack.\n\t- Simply find the no. of odd and even postions. and return the min of those ð¤·ââï¸\n\n\n","lastmodified":"2024-07-04T20:24:17.033181857Z","tags":["dsadeck","arrays"]},"/dsa/128.-Longest-Consecutive-Sequence":{"title":"128. Longest Consecutive Sequence","content":"\n## Problem Statement\n\n\nPattern: \n\n---\n\n## Naive Solution\n\nFreq Array /  HashSet Approach\n``` java\npublic int longestConsecutive1 (int[] nums){\n\tif(nums.length == 0) return 0;\n\tHashSet\u003cInteger\u003e set = new HashSet\u003c\u003e();\n\tint min = Integer.MAX_VALUE, max = Integer.MIN_VALUE;\n\tfor(int num: nums) {\n\t\tmin = Math.min(min, num);\n\t\tmax = Math.max(max, num);\n\t\tset.add(num);\n\t}\n\tint count = 0, maxCount = 1;\n\tfor (int i = min; i \u003c= max; i++) {\n\t\tif(set.contains(i)) count++;\n\t\telse count = 0;\n\t\tmaxCount = Math.max(maxCount, count);\n\t}\n\treturn maxCount;\n}\n```\nsolution will fail if the range of `nums[i] \u003e 10^8`, \n\n### Notes\n- Here we store an array into a set, and find the min and max of the array\n- we start from min, and iterate to max, update count whenever set.contains is true for a consecutive set of integers.\n- This is a very bad solution. **better to sort** array and find longest subsequnce \n as long as `nums.length \u003c 10^7`\n \n\n\n## Optimised Solution\nSet, but we keep all searching operations within the set. \n``` java\npublic int longestConsecutive (int[] nums) {  \n   Set\u003cInteger\u003e set = new HashSet\u003c\u003e();  \n   for (int num : nums) set.add(num);  \n   int maxLen = 0;  \n   for(int num : set) {  \n      if(!set.contains(num-1)) {  // start at the smallest no. of the subsequence  \n         int next = num+1;  \n         while(set.contains(next)) next++;   // find the end of the subsequence  \n         maxLen = Math.max(maxLen, next-num);    // update max  \n      }  \n   }   return maxLen;  \n}\n```\n\n### Notes\n- store all the elements into a set.\n- iterate over set elements\n\t- find the start of a consecutive sequence `!set.contains(num-1)`\n\t\t- find the length of the sequence, and update `max`.\n\n","lastmodified":"2024-07-04T20:24:17.033181857Z","tags":["dsadeck","arrays","subarrays","set"]},"/dsa/1295.-Find-Numbers-with-Even-Number-of-Digits":{"title":"1295. Find Numbers with Even Number of Digits","content":"\n## Problem Statement\n[Find Numbers with Even Number of Digits - LeetCode](https://leetcode.com/problems/find-numbers-with-even-number-of-digits/)\n\nPattern: \n\n---\n\n## Solution\n``` java\npublic int findNumbers(int[] nums) {\n\tint even = 0;\n\tfor(int i = 0; i \u003c nums.length; i++) {\n\t\tif(((int)Math.log10((double)nums[i])+1)%2 == 0 )\n\t\t\teven++;\n\t}\n\treturn even;\n}\n```\n\n### Notes\n- \n\n","lastmodified":"2024-07-04T20:24:17.033181857Z","tags":["dsadeck","arrays"]},"/dsa/13.-Roman-to-Integer":{"title":"13. Roman to Integer","content":"\n## Problem Statement\n\n\nPattern: \n\n---\n\n## Solution\n``` java\npublic int value (char ch) {\n\tswitch (ch) {\n\t\tcase 'I' : return 1;\n\t\tcase 'V' : return 5;\n\t\tcase 'X' : return 10;\n\t\tcase 'L' : return 50;\n\t\tcase 'C' : return 100;\n\t\tcase 'D' : return 500;\n\t\tdefault : return 1000;\n\t}\n}\n\npublic int romanToInt(String s) {\n\tint prev = -1, sum = 0;\n\tfor (char ch : s.toCharArray()) {\n\t\tint curr = value(ch);\n\t\tsum+= curr;\n\t\t\n\t\tif(prev != -1 \u0026\u0026 prev \u003c curr ) sum -= 2*prev;\n\t\tprev = curr;\n\t}\n\treturn sum;\n}\n```\n\nTC : $O(n)$\nSC : $O(1)$\n\n### Notes\n- if a smaller number comes before a larger number, instead of adding it to the sum, we subtract it from the sum.\n\n\n","lastmodified":"2024-07-04T20:24:17.033181857Z","tags":["dsadeck","strings"]},"/dsa/1304.-Find-N-Unique-Integers-Sum-up-to-Zero":{"title":"1304. Find N Unique Integers Sum up to Zero","content":"\n## Problem Statement\n\n\nPattern: \n\n---\n\n## Solution\n``` java\n// simple approach\npublic int[] sumZero1(int n) {\n\tint[] res = new int[n];\n\tfor (int i = 0 ; i \u003c n-1 ; i++)\n\t\tres[i++] = i+1;\n\n\t// add last element -\u003e -ve sum of elements b4 n\n\tres[--n] = -n * (n+1) / 2;\n\treturn res;\n}\n\n// robust approach (n \u003e= 10^5)\npublic int[] sumZero(int n) {\n\tint[] res = new int[n];\n\tfor (int i = 0; i \u003c n; i++)\n\t\tres[i] = 2*i - n +1;\n\treturn res;\n}\n```\n\n### Notes\n- First Appraoch is simple and straight fwd\n\t- Fill array with numbers upto n-1\n\t- last element is the negative sum of all the numbers\n- Second approach is robust with large range of n\n\t- [[Java/C++/Python] Find the Rule - LeetCode Discuss](https://leetcode.com/problems/find-n-unique-integers-sum-up-to-zero/discuss/465585/JavaC%2B%2BPython-Find-the-Rule)\n\t- Basically it will give you  a patttern like this.\n\t- `n = 3, [-2, 0, 2]`  \n\t- `n = 4, [-3, -1, 1, 3]`  \n\t- `n = 5, [-4, -2, 0, 2, 4]`\n\n","lastmodified":"2024-07-04T20:24:17.033181857Z","tags":["dsadeck","arrays"]},"/dsa/1312.-Minimum-Insertion-Steps-to-Make-a-String-Palindrome":{"title":"1312. Minimum Insertion Steps to Make a String Palindrome","content":"\n## Problem Statement\n[Minimum Insertion Steps to Make a String Palindrome - LeetCode](https://leetcode.com/problems/minimum-insertion-steps-to-make-a-string-palindrome/)\n\nPattern: \n\n---\n\n## Solution\n``` java\nInteger[][] cache;\n\n/// return smallest uncommon subsequence\npublic int dp (char[] s, int start, int end) {\n\tif(start \u003c= end) return 0;\n\tif(cache[start][end] != null) return cache[start][end];\n\t\n\tif(s[start] == s[end])\n\t\treturn cache[start][end] = dp(s, start+1, end-1);\n\t\n\treturn cache[start][end] = \n\t\t1 + Math.min(dp(s, start+1, end), dp(s, start, end-1));\n}\n\npublic int minInsertions(String s) {\n\tint n = s.length();\n\tcache = new Integer[n+1][n+1];\n\treturn dp(s.toCharArray(), 0, n-1);\n}\n```\nTC : $O(n^2)$\nSC : $O(n^2)$\n\n### Notes\n- Much like [[1143. Longest Common Subsequence]] you simply have to return Smallest Uncommon Subsequence\n- The logic is, for every uncommnon letter, you can insert another, to equalise it.\n\n\n\n\n","lastmodified":"2024-07-04T20:24:17.033181857Z","tags":["dsadeck","strings"]},"/dsa/1365.-How-Many-Numbers-Are-Smaller-Than-the-Current-Number":{"title":"1365. How Many Numbers Are Smaller Than the Current Number","content":"\n## Problem Statement\n\n\nPattern: \n\n---\n\n## Solution\n``` java\n// freq array prefix sum O(n)\npublic int[] smallerNumbersThanCurrent(int[] nums) {\n\t// this method is viable since nums[i] \u003c 100\n\tfinal int MAX = 101;\n\t//create freq arr\n\tint[] freq = new int[MAX];\n\tfor (int i = 0; i \u003c nums.length; i++) {\n\t\tfreq[nums[i]]++;\n\t}\n\t\n\t// convert into prefix sum arr\n\tfor (int i = 1; i \u003c MAX; i++) {\n\t\t// each index stores the no of elements smaller than it\n\t\tfreq[i] += freq[i - 1];\n\t}\n\t\n\t// write to nums array\n\tfor (int i = 0; i \u003c nums.length; i++) {\n\t\t// already correct/ avoid out of bounds\n\t\tif(nums[i] == 0) break; \n\t\tnums[i] = freq[nums[i] - 1];  // freq of nums 'up to' nums[i]\n\t}\n\treturn nums;\n}\n\n// sort array O(nlogn)\npublic int[] smallerNumberThanCurrentSort(int[] nums) {\n\t// create sorted array\n\tint [] sortedNums = nums.clone();\n\tArrays.sort(sortedNums);\n\t\n\t// insert first location\n\tHashMap\u003cInteger, Integer\u003e map = new HashMap\u003c\u003e();\n\tfor (int i = 0; i \u003c sortedNums.length; i++)\n\t\t// insert the first pos of el in sorted array\n\t\tmap.putIfAbsent(sortedNums[i], i);\n\t\n\t// rewrite array\n\tfor (int i = 0; i \u003c nums.length; i++)\n\t\tnums[i] = map.get(nums[i]);\n\t\n\treturn nums;\n}\n```\n\n### Notes\n- 2 ways to do it\n- Both find the number of elements before the current element\n\t- Enter freqs into a freq array\n\t- Convert into prefix sum\n\t\t- `freq[i]` gives you the number of elements that exist in array till value `i` in `nums` (including i). \n\t\t- So to find no. of elements till value `i` not including `i` , get `freq[i-1]`\n- Hashmap implmentation stores the first 0-based index of every element's first occurrence if the array was sorted\n\t- That gives you the no. of elements smaller `nums[i]`, \n\t- dry run with first element `1`\n","lastmodified":"2024-07-04T20:24:17.033181857Z","tags":["dsadeck","arrays"]},"/dsa/1380.-Lucky-Numbers-in-a-Matrix":{"title":"1380. Lucky Numbers in a Matrix","content":"\n## Problem Statement\n\n\nPattern: \n\n---\n\n## Solution\n``` java\npublic List\u003cInteger\u003e luckyNumbers(int[][] matrix) {\n\t// min max arrays\n\tint[] minRow = new int[matrix.length];\n\tint[] maxColumn = new int[matrix[0].length];\n\t// fill with appropriate values for comparison\n\tArrays.fill(minRow, Integer.MAX_VALUE);\n\tArrays.fill(maxColumn, Integer.MIN_VALUE);\n\t\n\tArrayList\u003cInteger\u003e result = new ArrayList\u003c\u003e();\n\t\n\t// update min for each row and each column\n\tfor (int i = 0; i \u003c matrix.length; i++) {\n\t\tfor (int j = 0; j \u003c matrix[i].length; j++) {\n\t\t\tminRow[i] = Math.min(minRow[i], matrix[i][j]);\n\t\t\tmaxColumn[j] = Math.max(maxColumn[j], matrix[i][j]);\n\t\t}\n\t}\n\t\n\t// see for any given element, is there a match in min and max arrays\n\tfor (int i = 0; i \u003c matrix.length; i++)\n\t\tfor (int j = 0; j \u003c matrix[i].length; j++)\n\t\t\tif(maxColumn[j]== minRow[i]) result.add(maxColumn[j]);\n\t\n\treturn result;\n}\n```\n\n### Notes\n- \n\n","lastmodified":"2024-07-04T20:24:17.033181857Z","tags":["dsadeck","arrays","matrix"]},"/dsa/1382.-Balance-a-Binary-Search-Tree":{"title":"1382. Balance a Binary Search Tree","content":"\n## Problem Statement\n\n\nPattern: \n\n---\n\n## Trivial Solutions\n``` java\nArrayList\u003cTreeNode\u003e list = new ArrayList\u003c\u003e();\n\nvoid inorder(TreeNode root) {\n\tif(root == null) return; \n\tinorder(root.left);\n\tlist.add(root);\n\tinorder(root.right);\n}\n\nTreeNode balance(int start, int end) {\n\tif(start \u003e end) return null;\n\t\n\tint mid = (end-start)/2 + start;\n\tTreeNode node = list.get(mid);\n\t\n\tnode.left = balance(start, mid-1);\n\tnode.right = balance(mid+1, end);\n\t\n\treturn node;\n}\n\npublic TreeNode balanceBST(TreeNode root) {\n\tinorder(root);\n\treturn balance(0, list.size()-1);\n}\n```\n\n## DWS Solution\n#todoleetcode \n[C++/Java with picture, DSW O(n)|O(1) - LeetCode Discuss](https://leetcode.com/problems/balance-a-binary-search-tree/discuss/541785/C%2B%2BJava-with-picture-DSW-O(n)orO(1))\n\n\n","lastmodified":"2024-07-04T20:24:17.033181857Z","tags":["dsadeck","bst"]},"/dsa/1389.-Create-Target-Array-in-the-Given-Order":{"title":"1389. Create Target Array in the Given Order","content":"\n## Problem Statement\n\n\nPattern: \n\n---\n\n## Solution\n\nO(n^2) solution\n``` java\npublic int[] createTargetArray (int[] nums, int[] index){\n\t// create target arr\n\tint[] target = new int[nums.length];\n\t// insert from the end\n\tint i = 0, j = 0;\n\t// while index has not ended\n\tfor (i = 0; i \u003c index.length; i++) {\n\t\t// end -\u003e start till j has not reached index[i]\n\t\tfor (j = target.length-1; j \u003e index[i]; j--) {\n\t\t\t// shift el fwd\n\t\t\ttarget[j] = target[j-1];\n\t\t}\n\t\t// insert num at j index\n\t\ttarget[j] = nums[i];\n\t}\n\treturn target;\n}\n```\n\n### Notes\n- Start from the back and shift all elements fwd till target index has been reached.\n- Insert num at target index.\n- Works for all cases, whether its a new indes, or a prewritten index, end of the array, start of the array.\n\n\n``` java\npublic int[] createTargetArrayShort (int[] nums, int[] index){\n\tArrayList\u003cInteger\u003e target = new ArrayList\u003c\u003e(nums.length);\n\tfor (int i = 0; i \u003c index.length; i++) {\n\t\ttarget.add(index[i], nums[i]);\n\t}\n\t// returns an int[] array instead of ArrayList\u003cInteger\u003e\n\treturn target.stream().mapToInt(Integer::intValue).toArray();\n\t// target.stream() returns a stream with collection 'target' as source\n\t// mapToInt returns an IntStream after appying necessary modifications (unboxing int from Integer in this case)\n\t// toArray() converts stream to array\n}\n```\n\n### Notes\n- Shorter does the same thing\n- returning arraylist as int array is haard\n\t- [java - How to convert an ArrayList containing Integers to primitive int array? - Stack Overflow](https://stackoverflow.com/questions/718554/how-to-convert-an-arraylist-containing-integers-to-primitive-int-array)\n\t- herees a link to help you out\n\n\n","lastmodified":"2024-07-04T20:24:17.033181857Z","tags":["dsadeck","arrays"]},"/dsa/139.-Word-Break":{"title":"139. Word Break","content":"\n## Problem Statement\n\n\nPattern: \n\n---\n\n## Solution\n``` java\nBoolean[] cache;\nHashSet\u003cString\u003e dict;\n\npublic boolean dp(String S, int start) {\n\tif(start \u003e= S.length()) return true;\n\tif(cache[start] != null) return cache[start];\n\t\n\tint end = start;\n\twhile(end \u003c S.length()){\n\t\tif(dict.contains(S.substring(start, end+1)) \u0026\u0026 dp(S, end + 1)) \n\t\t\treturn cache[start] = true;\n\t\tend++;\n\t}\n\t\n\treturn cache[start] = false;\n}\n\npublic boolean wordBreak(String s, List\u003cString\u003e wordDict) {\n\tcache = new Boolean[s.length()+1];\n\tdict = new HashSet\u003c\u003e();\n\tfor(String str : wordDict) dict.add(str);\n\t\n\treturn dp(s, 0);\n}\n```\nTC : $n^2$\nSC : $n^2$\n\n### Notes\n- This can be further optimised by iterating over the dictionary, since the dictionary size is lower, the Time complexity $n^2$ would be lower.\n\n\n\n\n","lastmodified":"2024-07-04T20:24:17.033181857Z","tags":["dsadeck","strings"]},"/dsa/14.-Longest-Common-Prefix":{"title":"14. Longest Common Prefix","content":"\n## Problem Statement\n\n\nPattern: \n\n---\n\n## Solution\n``` java\npublic String longestCommonPrefix(String[] strs) {\n\tint limit = strs[0].length()-1; String prev = strs[0];\n\tfor (int i = 1 ; i \u003c strs.length ; i++) {\n\t\tint j = 0; String curr = strs[i];\n\t\twhile(j \u003c prev.length() \u0026\u0026 j \u003c curr.length() \u0026\u0026 j \u003c= limit \u0026\u0026 prev.charAt(j) == curr.charAt(j)) j++;\n\t\t\t\t\t   \n\t\tlimit = j-1;\n\t\tprev = curr;\n\t}\n\treturn strs[0].substring(0, limit+1);\n}\n```\nTC : $O(n)$\nSC : $O(1)$\n\n### Notes\n- elementary my dear shit head\n\n\n\n\n","lastmodified":"2024-07-04T20:24:17.033181857Z","tags":["dsadeck","strings"]},"/dsa/140.-Word-Break-II":{"title":"140. Word Break II","content":"\n## Problem Statement\n[Word Break II - LeetCode](https://leetcode.com/problems/word-break-ii/)\n\nPattern: \nRelated: [[139. Word Break]]\n\n---\n\n## Solution\n``` java\nHashSet\u003cString\u003e dict;\nArrayList\u003cString\u003e res;\n\npublic void dp (String S, int start, StringBuilder sb) {\n\tif(start \u003e= S.length()) {\n\t\tsb.setLength(Math.max(sb.length() - 1, 0));\n\t\tres.add(sb.toString());\n\t\treturn;\n\t}\n\n\tfor (int end = start ; end \u003c S.length() ; end++) {\n\t\tString str = S.substring(start, end+1);\n\t\tif(dict.contains(str)) {\n\t\t\tdp(S, end + 1, new StringBuilder(sb).append(str).append(\" \"));\n\t\t}\n\t}\n}\n\npublic List\u003cString\u003e wordBreak(String s, List\u003cString\u003e list) {\n\tdict = new HashSet\u003c\u003e();\n\tdict.addAll(list);\n\tres = new ArrayList\u003c\u003e();\n\n\tdp(s, 0, new StringBuilder());\n\treturn res;\n}\n```\nTC : $n^2$\nSC : \n\n### Notes\n- \n\n\n\n","lastmodified":"2024-07-04T20:24:17.033181857Z","tags":["dsadeck","strings"]},"/dsa/142.-Linked-List-Cycle-II":{"title":"142. Linked List Cycle II","content":"\n## Problem Statement\n[Linked List Cycle II - LeetCode](https://leetcode.com/problems/linked-list-cycle-ii/)\n![](https://i.imgur.com/UoYyY9w.png)\n\n\nPattern: [[Pattern Fast and Slow Pointer}]]\n\n---\n\n## Solution\n``` java\npublic ListNode detectCycle(ListNode head) {\n\tListNode slow = head, fast = head;\n\twhile (fast != null \u0026\u0026 fast.next != null) {\n\t\tslow = slow.next;\n\t\tfast = fast.next.next;\n\t\tif (slow == fast) break;\n\t}\n\tif (fast == null || fast.next == null) return null;\n\twhile (head != slow) {\n\t\thead = head.next;\n\t\tslow = slow.next;\n\t}\n\treturn head;\n}\n```\n\n## Explanation: \ncontinued from ![[GFG Detect Loop#Why fast pointer skips '1' specifically]]\n### How do they meet, and then meet again?\n\n![](https://i.imgur.com/ixDFbzJ.png)\nSimply said, when F and S meet at `x + y`\n- Length travelled by `S` : `x+y`\n- Length travelled by `F`  = `2 (x+y)` (cuz it was moving *2x as fast* as `S`)\n\nThe difference of Len(F) - Len(S) = x + y = ? (what). lemme rephrase this, **How much farther did `F` travel than `S` ?** rephrased again...\n\n\u003e  Once `F` had travelled `(x+y)` what was it doing waiting for `S` to catch up? That's right, going around in circles... of size `C`. How many times? Who knows ð¤·ââï¸, some constant K or N\n\nwe got two pointers, and we know the `head` position of the LL, and the meeting `x+y` position so now how do we find `x` ?\n\nLet's see. `S` enters the circle and meets with `F` at `y` inside the circle. This time, with `S` at an offset of `y` let it go around in circles, till head pointer meets up with it, except since we offset it by `y`, they meet up at `x+y - y -\u003e x` ð¤¯\n\n","lastmodified":"2024-07-04T20:24:17.033181857Z","tags":["dsadeck","arrays"]},"/dsa/1448.-Count-Good-Nodes-in-Binary-Tree":{"title":"1448. Count Good Nodes in Binary Tree","content":"\n## Problem Statement\n\n\nPattern: \n\n---\n\n## Solution\n``` java\npublic int helper(TreeNode root, int max) {\n\tint count = 0;\n\t\n\tif(root == null) return count;\n\tif(root.val \u003e= max) count++;\n\t\n\tcount += helper(root.left, Math.max(max, root.val));\n\tcount += helper(root.right, Math.max(max, root.val));\n\treturn count;\n}\n\npublic int goodNodes(TreeNode root) {\n\treturn helper(root, root.val);\n}\n```\n\n### Notes\n- \n\n","lastmodified":"2024-07-04T20:24:17.033181857Z","tags":["dsadeck","binarytrees"]},"/dsa/1470.-Shuffle-the-Array":{"title":"1470. Shuffle the Array","content":"\n## Problem Statement\n[Shuffle the Array - LeetCode](https://leetcode.com/problems/shuffle-the-array/)\nGiven the arrayÂ `nums`Â consisting ofÂ `2n`Â elements in the formÂ `[x1,x2,...,xn,y1,y2,...,yn]`.\n\n_Return the array in the form_Â `[x1,y1,x2,y2,...,xn,yn]`.\n\nPattern: [[Pattern 2 values in 1 variable]]\n\n---\n\n## Solution\n``` java\npublic int[] shuffle (int[] nums, int n){\n\t// 1024 is upper constraint of nums[i], so can be taken as constVal\n\tfinal int constVal = 1024;\n\t// store array in second half\n\tfor (int i = n; i \u003c 2*n; i++) {\n\t\tnums[i] = nums[i-n] + (constVal * nums[i]);\n\t}\n\t\n\t// retrieve pairs from second half, write to adjacent pairs\n\tint index = 0;\n\tfor (int i = n; i \u003c 2 * n; i++, index+=2) {\n\t\tnums[index] = nums[i] % constVal;\n\t\tnums[index+1] = nums[i] / constVal;\n\t}\n\t\n\treturn nums;\n}\n```\n\n### Notes\n- Store both i and i+n values in the right half of the array\n- Rewrite adjacent pairs from the begnining of the array, using the second half of the array.\n","lastmodified":"2024-07-04T20:24:17.033181857Z","tags":["dsadeck","arrays"]},"/dsa/148.-Sort-List":{"title":"148. Sort List","content":"\n## Problem Statement\n\n\nPattern: \n\n---\n\n## Solution\n``` java\nprivate ListNode getMid (ListNode head) {\n\tListNode slow = head, fast = head;\n\tfast = fast.next;\n\t\n\twhile (fast!= null \u0026\u0026 fast.next!=null) {\n\t\tslow = slow.next;\n\t\tfast = fast.next.next;\n\t}\n\t// when fast / fast.next becomes null, slow would have reached floor of mid\n\treturn slow;\n}\n\nprivate ListNode merge(ListNode left, ListNode right) {\n\tListNode dummy = new ListNode(-1), tail = dummy;\n\t\n\t// merge left and right\n\twhile(left != null \u0026\u0026 right != null) {\n\t\tif(left.val \u003c= right.val) {\n\t\t\ttail.next = left;\n\t\t\tleft = left.next;\n\t\t} else {  // right.val \u003c left.val\n\t\t\ttail.next = right;\n\t\t\tright = right.next;\n\t\t}\n\t\ttail = tail.next;\n\t}\n\t\n\t// merge left\n\twhile (left != null) {\n\t\ttail.next = left;\n\t\tleft = left.next;\n\t\ttail = tail.next;\n\t}\n\t\n\t// merge right\n\twhile (right != null ) {\n\t\ttail.next = right;\n\t\tright = right.next;\n\t\ttail = tail.next;\n\t}\n\t\n\treturn dummy.next;\n}\n\npublic ListNode sortList (ListNode head){\n\t// return if single el\n\tif (head == null || head.next == null) return head;\n\t\n\t// set left, mid right\n\tListNode left = head;\n\tListNode mid = getMid(head);\n\tListNode right = mid.next;\n\t\n\t// disconnect mid\n\tmid.next = null;\n \n\t// RECURSE for left and right sublist\n\tleft = sortList(left);\n\tright = sortList(right);\n\t\n\t// WAY UP\n\treturn merge(left, right);\n}\n```\n\n### Notes\n[Sort List - Merge Sort - Leetcode 148 - YouTube](https://www.youtube.com/watch?v=TGveA1oFhrc)\n- `getMid` from   [[876. Middle of the Linked List]]\n- `sortList` as expected partitions the array, ,into left and right, and sets the mid partition to null\n\t- recruse for left and right on the way down\n\t- return merged list on the way up\n- Interestingly for linkedlists you dont need to init a seperate linked list, to store the merged array, since you can point a your `tail` to the next `left` or `right` \n\n","lastmodified":"2024-07-04T20:24:17.033181857Z","tags":["dsadeck","arrays","linkedlist","tododryrun"]},"/dsa/15.-3Sum":{"title":"15. 3Sum","content":"\n## Problem Statement\n\n\nPattern: [[Pattern Two Pointer]]\n\n---\n\n## 2 Pointer Solution\n``` java\npublic List\u003cList\u003cInteger\u003e\u003e threeSum (int[] num){\n\tArrays.sort(num);\n\tList\u003cList\u003cInteger\u003e\u003e res = new LinkedList\u003c\u003e(); \n\tfor (int i = 0; i \u003c num.length-2; i++) {\n\t\tif (i == 0 || (i \u003e 0 \u0026\u0026 num[i] != num[i-1])) {\n\t\t\tint lo = i+1, hi = num.length-1, sum = 0 - num[i];\n\t\t\twhile (lo \u003c hi) {\n\t\t\t\tif (num[lo] + num[hi] == sum) {\n\t\t\t\t\tres.add(Arrays.asList(num[i], num[lo], num[hi]));\n\t\t\t\t\twhile (lo \u003c hi \u0026\u0026 num[lo] == num[lo+1]) lo++;\n\t\t\t\t\twhile (lo \u003c hi \u0026\u0026 num[hi] == num[hi-1]) hi--;\n\t\t\t\t\tlo++; hi--;\n\t\t\t\t} else if (num[lo] + num[hi] \u003c sum) lo++;\n\t\t\t\telse hi--;\n\t\t   }\n\t\t}\n\t}\n\treturn res;    \n}\n```\n\n### Notes\n- simple solution like [[GFG Triplet Sum in Array]]\n\n ## Set 2 Pointer Solution\n Higher runtime\n ``` java\npublic List\u003cList\u003cInteger\u003e\u003e threeSum (int[] nums){\n\tSet\u003cList\u003cInteger\u003e\u003e lists = new HashSet\u003c\u003e();\n\tArrays.sort(nums);\n\tfor (int start = 0; start \u003c nums.length-2; start++) {\n\t\tint mid = start+1, end = nums.length-1;\n\t\twhile(mid \u003c end) {\n\t\t\tint sum = nums[start] + nums[mid] + nums[end];\n\t\t\tif(sum \u003c 0) mid++;\n\t\t\telse if(sum \u003e 0) end--;\n\t\t\telse lists.add(Arrays.asList(nums[start], nums[mid++], nums[end--]));\n\t\t}\n\t}\n\treturn new ArrayList\u003c\u003e(lists);\n}\n```\nhere we can forego the duplicate logic. but the runtimme is much higher.\n\n","lastmodified":"2024-07-04T20:24:17.033181857Z","tags":["dsadeck","arrays"]},"/dsa/1512.-Number-of-Good-Pairs":{"title":"1512. Number of Good Pairs","content":"\n## Problem Statement\n\n\nPattern: \n\n---\n\n## Solution\n``` java\npublic int numIdenticalPairs (int[] nums){\n\tHashMap\u003cInteger, Integer\u003e map = new HashMap\u003c\u003e();\n\t// count how many times has this element been repeated in the past for each repetition.\n\tint totalPrevDuplicates=0;\n\tfor (int num : nums) {\n\t\tint freq = map.getOrDefault(num, 0);\n\t\t// no. of times num[i] has appeared before added to total\n\t\ttotalPrevDuplicates += freq;\n\t\tmap.put(num, ++freq);\n\t}\n\treturn totalPrevDuplicates;\n}\n```\n\n### Notes\n- Its just like the No. of Handshakes Question \n\t- [JAVA | STORY BASED | 0ms | SINGLE PASS | EASY TO UNDERSTAND | SIMPLE | HASHMAP - LeetCode Discuss](https://leetcode.com/problems/number-of-good-pairs/discuss/1457646/JAVA-or-STORY-BASED-or-0ms-or-SINGLE-PASS-or-EASY-TO-UNDERSTAND-or-SIMPLE-or-HASHMAP)\n- Here instead of no. of handshakes you have to count, how many pairs does each element form with thos in front of it / how many times is an element repeated in front of it\n- Or look at it in reverse\n\u003e [!Concept]\n\u003e How many elements before this can pair with this element / How many elements before this are duplicates of this element\n\n\n\n","lastmodified":"2024-07-04T20:24:17.033181857Z","tags":["dsadeck","arrays"]},"/dsa/1574.-Shortest-Subarray-Removed-to-Make-Array-Sorted":{"title":"1574. Shortest Subarray  Removed to Make Array Sorted","content":"\n## Problem Statement\n[Shortest Subarray to be Removed to Make Array Sorted - LeetCode](https://leetcode.com/problems/shortest-subarray-to-be-removed-to-make-array-sorted/)\n\n\nPattern: [[Pattern Two Pointer]]\n\n---\n\n## Solution\n``` java\npublic int findLengthOfShortestSubarray(int[] arr) {\n\t// find lengths prefix and suffix subarray\n\tint left = 0, right = arr.length-1;\n\t\n\twhile(left \u003c right \u0026\u0026 arr[left+1] \u003e= arr[left]) \n\t\tleft++;\n\t\n\tif (left == right) return 0;\n\t\t\t\n\twhile(right \u003e 0 \u0026\u0026 arr[right-1] \u003c= arr[right])\n\t\tright--;\n\t\n\t// find smaller 'len'subarray \n\tint minLength = Math.min(arr.length - left - 1, right);\n\t\n\t\n\t// find smallest 'len' sub, by merging prefix and suffix\n\tfor (int i = 0, j = right ; i \u003c= left ; i++) {\n\t\t\n\t\t// shift j fwds while arr[i] is larger\n\t\twhile(j \u003c arr.length \u0026\u0026 arr[i] \u003e arr[j]) j++;\n\t\n\t\tif (j == arr.length) break;\n\t\t\n\t\t// update len\n\t\tminLength = Math.min(j - i - 1, minLength);\n\t}\n\t\n\treturn minLength;\n}\n```\n\n### Notes\n- Since we can only remove a subarray, the final remaining elements must be either: (1) solely a prefix, (2) solely a suffix or (3) a merge of the prefix and suffix.\n1.  Find the monotone non-decreasing prefix [a_0 \u003c= ... a_i | ...]\n    -   `l`Â is the index such thatÂ `arr[l+1] \u003c arr[l]`\n2.  Find the monotone non-decreasing suffix [... | a_j \u003c= ... a_n]\n    -   `r`Â is the index such thatÂ `arr[r-1] \u003e arr[r]`\n3.  Try to \"merge 2 sorted arrays\", if we can merge, update our minimum to remove.\n\n- if the whole array is sorted, the 'merging' process might make the `minLenth = -1` since `j == i`. So in that case we return if `l == r`\n\n\n","lastmodified":"2024-07-04T20:24:17.033181857Z","tags":["easy","arrays","incomplete","subarrays","twopointer","dsadeck"]},"/dsa/160.-Intersection-of-Two-Linked-Lists":{"title":"160. Intersection of Two Linked Lists","content":"\n## Problem Statement\n![](https://i.imgur.com/CrRfJJD.png)\n\n\nPattern: \n\n---\n\n## Solution\nWorks even if no intersection\n``` java\npublic ListNode getIntersectionNode (ListNode headA, ListNode headB){\n\tint lenA = getLen(headA), lenB = getLen(headB);\n\twhile(lenA \u003e lenB){\n\t\theadA = headA.next;\n\t\tlenA--;\n\t}\n\twhile(lenB \u003e lenA) {\n\t\theadB = headB.next;\n\t\tlenB--;\n\t}\n\t\n\twhile(headA != headB) {\n\t\theadA = headA.next;\n\t\theadB = headB.next;\n\t}\n\treturn headA;   // returns null if no intersection found\n}\n\nprivate int getLen (ListNode head) {\n\tif(head == null) return 0;\n\tint count = 1;\n\twhile(head.next != null) {\n\t\thead = head.next;\n\t\tcount++;\n\t}\n\treturn count;\n}\n```\n\n### Notes\n- find difference in lengths in linked lists\n- shift the longer lls pointer fwd by the diff\n- now when you increment both pointers they will intersect at the intersection. \n- return a pointer\n- if intersection not found, null will be returned\n\n \n## Clever Solution\n\n``` java\npublic ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n    //boundary check\n    if(headA == null || headB == null) return null;\n    \n    ListNode a = headA;\n    ListNode b = headB;\n    \n    //if a \u0026 b have different len, then we will stop the loop after second iteration\n    while( a != b){\n    \t//for the end of first iteration, we just reset the pointer to the head of another linkedlist\n        a = a == null? headB : a.next;\n        b = b == null? headA : b.next;    \n    }\n    \n    return a;\n}\n```\n\n[Java solution without knowing the difference in len! - LeetCode Discuss](https://leetcode.com/problems/intersection-of-two-linked-lists/discuss/49785/Java-solution-without-knowing-the-difference-in-len!)\n\n- here instead of checking lenths, as as soon as one LL's pointer reaches the end, set it to the head of the other LL.\n\n- once both LL's , have reached the end, and swapped to the other's start's the longer one would have offset by the difference in lengths!\n\n- once they intersect, return any pointer\n\n- if intersection is not found, both will reach end together(since we fixed the offset) and null will be returned!\n\nit's a perfect solution\n\n\n","lastmodified":"2024-07-04T20:24:17.033181857Z","tags":["dsadeck","linkedlist"]},"/dsa/169.-Majority-Element":{"title":"169. Majority Element","content":"\n## Problem Statement\n![](https://i.imgur.com/pqyRvcn.png)\n\nPattern: [[Pattern Boyer Moore's Voting Algorithm]]\nRelated: [[229.Â Majority Element II]]\n\n---\n\n\n## Solution\n``` java\npublic int majorityElement (int[] nums){\n\tint major = nums[0], count = 1;\n\tfor (int num : nums) {\n\t\t// update count\n\t\tif(num == major) count++;\n\t\telse count--;\n\t\t// count = 0 -\u003e reset major\n\t\tif (count == 0) {\n\t\t\tmajor = num;\n\t\t\tcount = 1;\n\t\t}\n\t}\n\treturn major;\n}\n```\n\n### Notes\n#### Concept\nFor an element to be a majority element, it needs to appear more than n/2 times in an array. if more than half an array is made up of a single element, then there is no other element that could appear more times than the majority element. i.e. there can only be one majority element.\n\nOne interesting solution would be to sort the array, and pick the middle element, it will always be the majority element. lol. \n\n\u003e [!CONEPT]\n\u003e If there is a 'majority' element in the array that appears more times than all the other elements in the array combined, you could keep cancelling out a majority and minority pair, at the end, only the majority element will remain. simply because it appears more times than all the other elements in the array combined \n\n#### Execution\n - pick the first element to be majority element, and track its count. decrement only if a 'minority element' appears (any element that is not the same as our supposed majority element)\n - if count reaches 0, set the next element as the majority element,and forget about the old one\n","lastmodified":"2024-07-04T20:24:17.033181857Z","tags":["dsadeck","arrays","arithmetic"]},"/dsa/1721.-Swapping-Nodes-in-a-Linked-List":{"title":"1721. Swapping Nodes in a Linked List","content":"\n## Problem Statement\n\n\nPattern: \n\n---\n\n## Solution\n``` java\nvoid swap(ListNode pa, ListNode pb){\n\t// swap parents\n\tListNode a = pa.next, b = pb.next;\n\tpa.next = b;\n\tpb.next = a;\n\t// swap children\n\tListNode temp = a.next;\n\ta.next = b.next;\n\tb.next = temp;\n}\n\npublic ListNode swapNodes (ListNode head, int k){\n\tListNode dummy = new ListNode(-1), pa = dummy, pb = dummy, a = head, b = head;\n\tdummy.next = head;\n\n\t// find parent-a\n\tint count = 0;\n\twhile(++count \u003c k) {\n\t\tpa = pa.next;\n\t\ta = a.next;\n\t}\n\t// find parent-b\n\twhile(a.next!= null) {\n\t\ta = a.next;\n\t\tpb = pb.next;\n\t\tb = b.next;\n\t}\n\t// swap nodes by their parents\n\tswap(pa, pb);\n\treturn dummy.next;\n}\n```\n\n### Notes\n- \n\n","lastmodified":"2024-07-04T20:24:17.033181857Z","tags":["dsadeck","linkedlist"]},"/dsa/1749.-Maximum-Absolute-Sum-of-Any-Subarray":{"title":"1749. Maximum Absolute Sum of Any Subarray","content":"#dsadeck \n## Problem Statement\n[Maximum Absolute Sum of Any Subarray - LeetCode](https://leetcode.com/problems/maximum-absolute-sum-of-any-subarray/)\n\nYou are given an integer arrayÂ `nums`. TheÂ **absolute sum**Â of a subarrayÂ `[numsl, numsl+1, ..., numsr-1, numsr]`Â isÂ `abs(numslÂ + numsl+1Â + ... + numsr-1Â + numsr)`.\n\nReturnÂ _theÂ **maximum**Â absolute sum of anyÂ **(possibly empty)**Â subarray of_Â `nums`.\n\nNote thatÂ `abs(x)`Â is defined as follows:\n\n-   IfÂ `x`Â is a negative integer, thenÂ `abs(x) = -x`.\n-   IfÂ `x`Â is a non-negative integer, thenÂ `abs(x) = x`.\n\nExample 1:\n\n``` txt\nInput: nums = [1,-3,2,3,-4]\nOutput: 5\nExplanation: The subarray [2,3] has absolute sum = abs(2+3) = abs(5) = 5.\n```\nExample 2:\n``` txt\nInput: nums = [2,-5,1,-4,3,-2]\nOutput: 8\nExplanation: The subarray [-5,1,-4] has absolute sum = abs(-5+1-4) = abs(-8) = 8.\n \n```\n\nConstraints:\n\n``` txt\n1 \u003c= nums.length \u003c= 105\n-104 \u003c= nums[i] \u003c= 104\n```\nPattern: [[Pattern Kadane's Algorithm]]\n\n---\n\n## Solution\n``` java\n\n// find both minSum and maxSum \u003e return max(abs(min, max))\npublic static int maxAbsoluteSum (int[] nums){\n\tint minSum = Integer.MAX_VALUE, currMin = Integer.MAX_VALUE,\n\t\tmaxSum = Integer.MIN_VALUE, currMax = Integer.MIN_VALUE;\n\tfor (int num : nums) {\n\t\tif(currMin \u003e 0) currMin = num;\n\t\telse currMin += num;\n\t\t\n\t\tif(currMax \u003c 0) currMax = num;\n\t\telse currMax += num;\n\t\t\n\t\t// update max and min\n\t\tminSum = Math.min(currMin, minSum);\n\t\tmaxSum = Math.max(currMax, maxSum);\n\t}\n\treturn Math.max(Math.abs(minSum), maxSum);\n}\n```\n\n### Notes\n- The questions will take the subarray that you give it and return the subarray with the greatest absolute sum i.e. `Math.abs(sum)`\n\t- This means that sum could be negative or positive.\n\t- So find the max positive sum subarray, and smallest negative subarray\n\t- See which has greater absolute value\n\t- Return absolute value\n- `Return the maximum absolute sum of any (possibly empty) subarray of nums.`\n\t- This is an attempt at bait, since a non-empty subarray will be the largest always, under no circumstances will an empty subarray return the greatest absolute value.  So don't bother incorporating empty subarray logic into your code\n\t\t- If you are looking for minSum in a positive arrzay, it makes no sense to reset currMinsum to 0 if currMinsum \u003e 0, since a positive currMinsum, will give a greater value, compared to 0 at the end, when supplied into the function\n\t\t- `return Math.max(Math.abs(minSum), maxSum);`\n\n\n\n","lastmodified":"2024-07-04T20:24:17.033181857Z","tags":["easy","arrays","completed","dp","subarrays"]},"/dsa/1773.-Count-Items-Matching-a-Rule":{"title":"1773. Count Items Matching a Rule","content":"\n## Problem Statement\n\n\nPattern: \n\n---\n\n## Solution\n``` java\npublic int countMatches (List\u003cList\u003cString\u003e\u003e items, String ruleKey, String ruleValue){\n\t// available properties\n\tString[] ruleKeys = {\"type\", \"color\", \"name\"};\n\t// find RuleKeyNo.\n\tint keyNo = 0;\n\tfor (int i = 0; i \u003c ruleKeys.length; i++)\n\t\tif(ruleKeys[i].equals(ruleKey)) {\n\t\t\tkeyNo = i;\n\t\t\tbreak;\n\t\t}\n\n\t// Check which item satisfies the rulevalue\n\tfor (int itemNo = 0; itemNo \u003c items.size(); itemNo++) {\n\t\tList\u003cString\u003e item = items.get(itemNo);\n\t\tif(item.get(keyNo).equals(ruleValue))\n\t\t\treturn itemNo;\n\t}\n\t\n\t// element not found\n\treturn -1;\n}\n```\n\n### Notes\n- Make sure to use `.equals()` and not `==`\n\n\n","lastmodified":"2024-07-04T20:24:17.033181857Z","tags":["dsadeck","arrays"]},"/dsa/1832.-Check-if-the-Sentence-Is-Pangram":{"title":"1832. Check if the Sentence Is Pangram","content":"\n## Problem Statement\n\n\nPattern: \n\n---\n\n## Solution\n``` java\npublic boolean checkIfPangram (String sentence){\n\tboolean[] charPresent = new boolean[26];\n\n\t// mark all chars present as true\n\tfor (char c : sentence.toCharArray()) {\n\t\tcharPresent[c-'a'] = true;\n\t}\n\t\t\n\t// check if  charPresent is false\n\tfor(boolean bool : charPresent)\n\t\tif (!bool) return false;\n\t\n\treturn true;\n}\n```\n\n### Notes\n- \n\n","lastmodified":"2024-07-04T20:24:17.033181857Z","tags":["dsadeck","arrays","strings"]},"/dsa/1854.-Maximum-Population-Year":{"title":"1854. Maximum Population Year","content":"\n## Problem Statement\n\n\nPattern: \n\n---\n\n## Solution\n``` java\npublic int maximumPopulation (int[][] logs){\n\tfinal int MIN_YEAR = 1950, MAX_YEAR = 2050;\n\tint[] population = new int[MAX_YEAR-MIN_YEAR+1];\n\n\t// for each log\n\tfor(int[] log : logs){\n\t\t// increment birth year population\n\t\tpopulation[log[0]-1950]++;\n\t\t// decrement death year population\n\t\tpopulation[log[1]-1950]--;\n\t}\n\t\n\t// convert to prefix sum to get true population\n\tfor (int i = 1; i \u003c population.length; i++)\n\t\tpopulation[i] += population[i-1];\n\t\n\t// find maxYear\n\tint maxYear = 0;\n\tfor (int i = 0; i \u003c population.length; i++)\n\t\tif(population[i] \u003e population[maxYear]) maxYear = i;\n\t\n\t// offset to get answer\n\treturn maxYear+1950;\n}\n```\n\n### Notes\n- \n\n","lastmodified":"2024-07-04T20:24:17.033181857Z","tags":["dsadeck","arrays"]},"/dsa/1920.-Build-Array-from-Permutation":{"title":"1920. Build Array from Permutation","content":"\n## Problem Statement\n[Build Array from Permutation - LeetCode](https://leetcode.com/problems/build-array-from-permutation)\n\nPattern: [[Pattern 2 values in 1 variable]]\n\n---\n\n## Solution\n``` java\npublic int[] buildArray(int[] nums) {\n\tint n = nums.length;\n\tfor (int i = 0; i \u003c n; i++) {\n\t\t// nums[nums[i]] is the supposed correct location of nums[i]\n\t\t// nums[nums[i]] % n reverses this ð black magic we did to it, in case we did, otherwise same value.\n\t\tnums[i] = nums[i] + n * (nums[nums[i]] % n);\n\t\t\n\t\t// to store a and b in a\n\t\t// a' = a + (b * k)   - where k is some constant larger than both a and b, in this case we use nums.length\n\t\t// how are both a and b stored in a?\n\t\t// well a' % k  will give you a\n\t\t// a' / k will give you b !!\n\t\t\n\t}\n\t\n\tfor (int i = 0; i \u003c n; i++) {\n\t\tnums[i] = nums[i] / n;\n\t}\n\treturn nums;\n}\n```\n\n### Notes\n- The whole idea is to store 2 number inside of a single number\n- reversing black magic : restores the earlier number if it has already been altered\n\n","lastmodified":"2024-07-04T20:24:17.033181857Z","tags":["dsadeck","arrays"]},"/dsa/1963.-Minimum-Number-of-Swaps-to-Make-the-String-Balanced":{"title":"1963. Minimum Number of Swaps to Make the String Balanced","content":"\n## Problem Statement\n[Minimum Number of Swaps to Make the String Balanced - LeetCode](https://leetcode.com/problems/minimum-number-of-swaps-to-make-the-string-balanced/)\n\nPattern: \n\n---\n\n## Solution\n``` java\npublic int minSwaps(String s) {\n\tint stackSize = 0, rev = 0;        // reversal count\n\n\tfor (char ch : s.toCharArray())\n\t\tif(ch == '[') stackSize++;\n\t\telse {\n\t\t\tif(stackSize == 0) {\n\t\t\t\tstackSize++;\n\t\t\t\trev++;\n\t\t\t}\n\t\t\telse stackSize--;\n\t\t}\n\n\t// if unbalanced brackets left\n\tif(stackSize != 0) \n\t\tif(stackSize % 2 == 0) rev = rev + stackSize / 2;\n\t\telse return -1;\n\n\treturn (rev+2-1)/2;\n}\n```\nTC : $O(n)$\nSC : $O(1)$\n\n### Notes\n- \n\n\n\n","lastmodified":"2024-07-04T20:24:17.033181857Z","tags":["dsadeck","strings"]},"/dsa/198.-House-Robber":{"title":"198. House Robber","content":"\n## Problem Statement\n\n\nPattern: \n\n---\n\n## Recursive Solution\n``` java\nprivate class Pair {\n\tint inSum;\n\tint exSum;\n\tPair (int inSum, int exSum) {\n\t\tthis.inSum = inSum;\n\t\tthis.exSum = exSum;\n\t}\n}\n\nPair maxSum (LinkedList\u003cInteger\u003e list) {\n\tif(list.isEmpty()) return new Pair(0, 0);\n\n\tint num = list.remove();    // remove first\n\n\tPair next = maxSum(list);\n\tint inSum = num + next.exSum;\n\tint exSum = Math.max(next.exSum, next.inSum);\n\n\treturn new Pair(inSum, exSum);\n}\n\npublic int rob (int[] nums){\n\tLinkedList\u003cInteger\u003e list = new LinkedList\u003c\u003e();\n\tfor (int num : nums) list.add(num);\n\n\tPair max = maxSum(list);\n\n\treturn(Math.max(max.inSum, max.exSum));\n}\n```\n\nMuch like : [[Maxiumum Sum of Non-Adjacent Nodes]]\n\n\n## Iterative Solution\n\nNo callstack! and No unnecessary object creation! much faster !!!\n``` java\nprivate class Pair {\n\tint inSum;\n\tint exSum;\n\n\tPair(int inSum, int exSum) {\n\t\tthis.inSum = inSum;\n\t\tthis.exSum = exSum;\n\t}\n}\n\nint rob(int[] nums) {\n\tPair prev = new Pair(0, 0);\n\tfor (int num : nums) {\n\t\tint inSum = prev.inSum;\n\t\tprev.inSum = prev.exSum + num;\n\t\tprev.exSum = Math.max(prev.exSum, inSum);\n\t}\n\treturn Math.max(prev.exSum, prev.inSum);\n}\n```\nSame solution except we can move iterativel\n\n## Simplified Iterative\n``` java\npublic int rob(int[] num) {\n    int prevNo = 0;\n    int prevYes = 0;\n    for (int n : num) {\n        int temp = prevNo;\n        prevNo = Math.max(prevNo, prevYes);\n        prevYes = n + temp;\n    }\n    return Math.max(prevNo, prevYes);\n}\n```\n\n","lastmodified":"2024-07-04T20:24:17.033181857Z","tags":["dsadeck","arrays"]},"/dsa/1980.-Find-Unique-Binary-String":{"title":"1980. Find Unique Binary String","content":"\n## Problem Statement\n\n\nPattern: \n\n---\n\n## Solution\n- https://leetcode.com/problems/find-unique-binary-string/discuss/1418687/Detailed-Explanation-O(N)-Java-C++-Python-short-concise-code-Cantor's-Diagonalization\n\n- https://leetcode.com/problems/find-unique-binary-string/discuss/1418713/No-Recursion-or-Think-in-other-way-or-Python\n\n\n``` java\n\n```\n\n### Notes\n- \n\n","lastmodified":"2024-07-04T20:24:17.033181857Z","tags":["easy","arrays","tbdone"]},"/dsa/2.-Add-Two-Numbers":{"title":"2. Add Two Numbers","content":"\n## Problem Statement\n\n\nPattern: \n\n---\n\n## Solution 1\nExtra Linked List solution\n``` java\npublic ListNode addTwoNumbers (ListNode l1, ListNode l2) {\n\tListNode ans = new ListNode(-1), ansHead = ans;\n\tint carry = 0;\n\twhile (l1 != null || l2 != null || carry !=0) {\n\t\t\n\t\tint first  =  (l1 != null) ? l1.val : 0;\n\t\tint second = (l2 != null) ? l2.val : 0;\n\t\t\n\t\tcarry = carry + first + second;\n\t\tans.next = new ListNode(carry%10);\n\t\tcarry/=10;\n\t\t\n\t\t// increment LLs\n\t\tans = ans.next;\n\t\tl1 = (l1!=null) ? l1.next : null;\n\t\tl2 = (l2!=null) ? l2.next : null;\n\t\n\t}\n\treturn ansHead.next;\n}\n```\nð this ones far better honestly. i spend so much time on ðthat, that i didnt have the heart to not note it down\n\n\n## Solution 2\nAdd sum into the second linked \n``` java\npublic ListNode addTwoNumbers (ListNode l1, ListNode l2){\n\t// p1 and p2 are dummy head l1 and l2s\n\tListNode p1 = new ListNode(-1, l1), p2 = new ListNode(-1, l2);\n\tint carry = 0;\n\t\n\t// while p1 and l2 left\n\twhile(p1.next != null \u0026\u0026 p2.next != null) {\n\t\tcarry = carry + p2.next.val + p1.next.val;\n\t\tp2.next.val = carry % 10;\n\t\tcarry /=10;\n\t\t\n\t\tp1 = p1.next;\n\t\tp2 = p2.next;\n\t}\n\t\n\t// while p1 left\n\twhile(p1.next != null) {\n\t\tcarry = carry + p1.next.val;\n\t\tp2.next = new ListNode(carry%10);\n\t\tcarry /=10;\n\t\t\n\t\tp1 = p1.next;\n\t\tp2 = p2.next;\n\t}\n\t\n\t// while l2 left\n\twhile (p2.next != null) {\n\t\tcarry = carry + p2.next.val;\n\t\tp2.next.val = carry % 10;\n\t\tcarry /=10;\n\t\tp2 = p2.next;\n\t}\n\t\n\t// while carry left\n\twhile(carry != 0) {\n\t\tp2.next = new ListNode(carry%10);\n\t\tcarry /= 10;\n\t\tp2 = p2.next;\n\t}\n\t\n\treturn l2;\n}\n```\n\n\n","lastmodified":"2024-07-04T20:24:17.033181857Z","tags":["dsadeck","arrays"]},"/dsa/2027.-Minimum-Moves-to-Convert-String":{"title":"2027. Minimum Moves to Convert String","content":"\n## Problem Statement\n\n\nPattern: \n\n---\n\n## Solution\n``` java\npublic int minimumMoves(String s) {\n\tint steps = 0, i = 0, len = s.length();\n\twhile (i \u003c len) {\n\t\tif (s.charAt(i) == 'X') { steps++; i+=2; }\n\t\ti++;\n\t}\n\treturn steps;\n}\n```\nTC : $O(n)$\nSC : $O(1)$\n\n### Notes\n- This is a very simple slightly unintuitive greedy approach problem just like [[Police and Thieves]] \n- You can visualise this as iterating forwards, by the left end of a 3 element long underline/bar. and with every single `step` we take, we try to take out the maximum number of `X's` we can without leaving out a single one!\n\n\n","lastmodified":"2024-07-04T20:24:17.033181857Z","tags":["dsadeck","strings"]},"/dsa/2053.-Kth-Distinct-String-in-an-Array":{"title":"2053. Kth Distinct String in an Array","content":"\n\n## Problem Statement\n\n\nPattern: \n\n---\n\n## Solution\n``` java\npublic static String kthDistinct (String[] arr, int k){\n\tHashMap hm = new HashMap\u003cString, Integer\u003e();\n\t// insert into hashmap\n\tfor (String str : arr) {\n\t\tint count = 0;\n\t\tif(hm.containsKey(str))\n\t\t\tcount = (int) hm.get(str);\n\t\thm.put(str, ++count);\n\t}\n\t// find kth distinct element\n\tint count = 0;\n\tfor(String str : arr){\n\t\tif((int) hm.get(str) == 1) count++;\n\t\tif(count == k) return str;\n\t}\n\t// string not found\n\treturn \"\";\n}\n```\n\n### Notes\n- \n","lastmodified":"2024-07-04T20:24:17.033181857Z","tags":["easy","arrays","completed","dsadeck"]},"/dsa/206.-Reverse-Linked-List":{"title":"206. Reverse Linked List","content":"\n## Problem Statement\n[Reverse Linked List - LeetCode](https://leetcode.com/problems/reverse-linked-list/)\n\nPattern: \nRelated:[[Reverse LinkedList in Groups of K]]\n\n---\n\n## Iterative Solution\n``` java\npublic ListNode reverseList (ListNode head){\n\tListNode prev = null, current = head; // next not init cuz head could be null\n\twhile(current != null) {\n\t\tListNode next = current.next;   // store the next ptr\n\t\tcurrent.next = prev;            // flip curr nodes next to prev\n\t\t\n\t\tprev = current;                 // new prev is curr\n\t\tcurrent = next;                 // new curr is next\n\t}\n\treturn prev;\n}\n```\n\n## Recursive Solution\n``` java\npublic ListNode reverse(ListNode head) {\n\tif(head == null || head.next == null) return head;  // return last node\n\t\n\t// GO DOWN\n\tListNode last = reverse(head.next);  // goes to the last node\n\t\n\t// ON THE WAY UP\n\thead.next.next = head;                  // point the next node to myself\n\t\n\thead.next = null;                       // point myself to null\n\t\n\treturn last;                         // return last NODE\n}\n```\n\n\n### Notes\n- the 'point myself to null' line has any meaningful effect, only on the 'first' / 'new last' node.\n- Basically\n\t- go down to the last node and keep returning it on the way back as the new head, no need to touch it.\n\t- on the way back point every node's next to itself\n- ð thats it. .thats the genius explanation\n\n","lastmodified":"2024-07-04T20:24:17.033181857Z","tags":["dsadeck","linkedlist"]},"/dsa/209.-Minimum-Size-Subarray-Sum":{"title":"209. Minimum Size Subarray Sum","content":"\n## Problem Statement\n\n\nPattern: [[Pattern Sliding Window]]\n\n---\n\n## Solution\n``` java\npublic static int minSubArrayLen(int target, int[] nums) {\n\tint start = 0, end = 0, min = Integer.MAX_VALUE, currSum = 0;\n\t\n\t// sliding window\n\twhile (end \u003c nums.length) {\n\t\t// update currSum\n\t\tcurrSum += nums[end];\n\t\t\n\t\t// if currSum \u003e= target\n\t\twhile(start\u003c= end \u0026\u0026 currSum \u003e= target){\n\t\t\t// update min\n\t\t\tmin = Math.min(min, end-start+1);\n\t\t\t// update sum, slide start forward\n\t\t\tcurrSum -= nums[start++];\n\t\t}\n\t\tend++;\n\t}\n\t// if el not found\n\tif (min == Integer.MAX_VALUE) min = 0;\n\treturn min;\n}\n```\n\n### Notes\n- Sliding window : move end forward and update sum\n\t- while (sum \u003e= target) update min, slide window forward, update sum\n\n\n","lastmodified":"2024-07-04T20:24:17.033181857Z","tags":["dsadeck","arrays","completed"]},"/dsa/215.-Kth-Largest-Element-in-an-Array":{"title":"215. Kth Largest Element in an Array","content":"\n## Problem Statement\n\n\nPattern: [[Pattern Order Of Statistics]]\n\n---\n\n## Code\n``` java\npublic static int findKthLargestLib (int[] nums, int k) {\n\tPriorityQueue\u003cInteger\u003e pq = new PriorityQueue\u003c\u003e();\n\tint index = 0;\n\twhile(k-- \u003e 0) {\n\t\tpq.add(nums[index++]);\n\t}\n\tfor(;index \u003c nums.length;index++) {\n\t\tif(nums[index] \u003e= pq.peek()) {\n\t\t\tpq.remove();\n\t\t\tpq.add(nums[index]);\n\t\t}\n\t}\n\treturn pq.peek();\n}\n\n```\n\n### Notes\n- Make a minHeap of size k of the largest elements of an array. \n- The root will be the answer!\n\n\n## Quick Select Solution\n[[Quick Sort]]\n``` java\npublic static int findKthLargestLib (int[] nums, int k) {\n\tPriorityQueue\u003cInteger\u003e pq = new PriorityQueue\u003c\u003e();\n\tint index = 0;\n\twhile(k-- \u003e 0) {\n\t\tpq.add(nums[index++]);\n\t}\n\tfor(;index \u003c nums.length;index++) {\n\t\tif(nums[index] \u003e= pq.peek()) {\n\t\t\tpq.remove();\n\t\t\tpq.add(nums[index]);\n\t\t}\n\t}\n\treturn pq.peek();\n}\n\n```\n\n### Notes\n- Make a minHeap of size k of the largest elements of an array. \n- The root will be the answer!\n\n## Kth largest element in an infinite Array / Stream\nhttps://www.google.com/amp/s/www.geeksforgeeks.org/kth-largest-element-in-a-stream/amp/\n\n\n#heap\n\n","lastmodified":"2024-07-04T20:24:17.033181857Z","tags":["easy","arrays","tbdone"]},"/dsa/226.-Invert-Binary-Tree":{"title":"226. Invert Binary Tree","content":"\n## Problem Statement\n\n\nPattern: \n\n---\n\n## Solution\n``` java\npublic Node invertTree (Node root){\n\tif(root == null) return null;\n\t\n\t// swap\n\tNode temp = root.left;\n\troot.left = root.right;\n\troot.right = temp;\n\n\tinvertTree(root.left);\n\tinvertTree(root.right);\n\t\n\treturn root;\n}\n```\n\n### Notes\n- self explanatory\n\n\n","lastmodified":"2024-07-04T20:24:17.033181857Z","tags":["dsadeck","binarytrees"]},"/dsa/229.-Majority-Element-II":{"title":"229. Majority Element II","content":"## Problem Statement\n![](https://i.imgur.com/Vd9AFcF.png)\n\n\nPattern: \n\n---\n\n## Solution\n``` java\npublic List\u003cInteger\u003e majorityElement(int[] nums) {\n\tint count1 = 0, count2 = 0, major1 = -1, major2 = -1;\n\t\n\t// get major1 and major2\n\tfor (int num : nums) {\n\t\tif (num == major1) count1++;\n\t\telse if (num == major2) count2++;\n\t\telse if (count1 == 0) {\n\t\t\tmajor1 = num;\n\t\t\tcount1 = 1;\n\t\t} else if (count2 == 0) {\n\t\t\tmajor2 = num;\n\t\t\tcount2 = 1;\n\t\t} else {\n\t\t\tcount1--;\n\t\t\tcount2--;\n\t\t}\n\t}\n\t\n\t// check count of major1 and major2\n\tcount1 = count2 = 0;\n\tfor (int num : nums)\n\t\tif (num == major1) count1++;\n\t\telse if (num == major2) count2++;\n\t\n\t// add majors to result\n\tList\u003cInteger\u003e res = new ArrayList\u003c\u003e();\n\tif (count1 \u003e nums.length / 3) res.add(major1);\n\tif (count2 \u003e nums.length / 3) res.add(major2);\n\t\n\t// return result\n\treturn res;\n}\n```\n\n### Concept\nCheckout the concept in [[169. Majority Element]] first. Here the only difference is, there can only be 2 majority elements max. Why?\n\n`n=9`, for an element to be a majority element it has to occupy, atleast `n/3 +1` spaces *(more than n/3 times* so `4 spaces`\n\nlets say `m1 = 13` is the first majority element that appears the minimum of 4 times. `m2 = 25` is the second majority element that appears the minimum of 4 times. \n\nSo far 8 out of 9 spaces have been occupied. so as you can see... it is physically impossible to have a 3rd majority element.\n\nnow we just need to track 2 majority elements instead of one, track their counts, and reset them with a new one when their counts reach zero\n\n\n\n\n","lastmodified":"2024-07-04T20:24:17.033181857Z","tags":["dsadeck","arrays"]},"/dsa/2293.-Min-Max-Game":{"title":"2293. Min Max Game","content":"\n## Problem Statement\n[Min Max Game - LeetCode Contest](https://leetcode.com/contest/weekly-contest-296/problems/min-max-game/)\n\nPattern: \n\n---\n\n## Solution\n``` java\n    public int minMaxGame(int[] nums) {\n        // exit condition\n        if(nums.length == 1) return nums[0];\n        // create temp array\n        int[] newNums = new int[nums.length/2];\n        // replace nums arr\n        for (int i = 0; i \u003c nums.length / 2; i++) {\n            // even vs odd\n            if((i\u00261) == 0) {\n                newNums[i] = Math.min(nums[2*i], nums[2*i+1]);\n            } else {\n                newNums[i] = Math.max(nums[2*i], nums[2*i+1]);\n            }\n        }\n        return minMaxGame(newNums);\n    }\n```\n\n### Notes\n- Do what the problem says\n- Recursion was a little tricky as a beginner\n\n","lastmodified":"2024-07-04T20:24:17.033181857Z","tags":["dsadeck","arrays","contest","binarytrees"]},"/dsa/2294.-Partition-Array-Such-That-Maximum-Difference-Is-K":{"title":"2294. Partition Array Such That Maximum Difference Is K","content":"## Problem Statement\n[Partition Array Such That Maximum Difference Is K - LeetCode Contest](https://leetcode.com/contest/weekly-contest-296/problems/partition-array-such-that-maximum-difference-is-k/)\n\nPattern: [[Pattern Sliding Window]]\n\n---\n\n## Solution\n``` java\npublic int partitionArray(int[] nums, int k) {\n\tif (nums.length == 1) return 1;\n\n\t// sort array\n\tArrays.sort(nums);\n\tint start = 0, end = 1, subArrayCount = 1;\n\t// sliding window\n\twhile(end \u003c nums.length){\n\t\t// if max-min \u003e k\n\t\tif(nums[end]-nums[start] \u003e k) {\n\t\t\t// reset start\n\t\t\tstart = end;\n\t\t\t// increment count\n\t\t\tsubArrayCount++;\n\t\t}\n\t\tend++;\n\t}\n\treturn subArrayCount;\n}\n```\n\n### Notes\n- Sort array\n- increase window size till `nums[end]-num[start] \u003e k`\n\t- reset window and increment `subarrayCount`\n\n\n\n","lastmodified":"2024-07-04T20:24:17.033181857Z","tags":["dsadeck","arrays","subarrays"]},"/dsa/23.-Merge-k-Sorted-Lists":{"title":"23. Merge k Sorted Lists","content":"\n## Problem Statement\n\n\nPattern: \n\n---\n## Merge Solution\n250ms  O(n^2) and recursion -\u003e function calling time\nO(1) space complexity\n[[Flatten a Linked List#Merge Sort Solution]]\n``` java\nListNode merge(ListNode a, ListNode b) {\n\tif(a == null) return b;\n\tif(b == null) return a;\n\n\tListNode smaller, larger;\n\n\tsmaller = (a.val \u003c= b.val) ? a : b;\n\tlarger = (b.val \u003e= a.val) ? b : a;\n\n\tsmaller.next = merge(smaller.next, larger);\n\treturn smaller;\n}\n\npublic ListNode mergeKLists(ListNode[] lists) {\n\tint n = lists.length;\n\tif(n == 0) return null;\n\tif(n == 1) return lists[0];\n\t\n\tListNode curr = new ListNode(Integer.MIN_VALUE);\n\t\n\tfor(ListNode list : lists) \n\t\tcurr =  merge(curr, list);\n\t\n\treturn curr.next;\n}\n```\n\n\n\n\n## PQ Solution\n16 ms, O(n) space\n``` java\npublic static ListNode mergeKLists(ListNode[] lists) {\n\tPriorityQueue\u003cListNode\u003e pq =\n\t\tnew PriorityQueue\u003cListNode\u003e(Comparator.comparingInt((ListNode a) -\u003e a.val));\n\t\n\tfor(ListNode nodeHead : lists)\n\t\tif(nodeHead != null) pq.add(nodeHead); // avoid NPE\n\t\n\tListNode sortedLL = new ListNode(-1), sortedLLHead = sortedLL;\n\t\n\twhile (!pq.isEmpty()) {\n\t\tListNode minNode = pq.poll();\n\t\tsortedLL.next = new ListNode(minNode.val);\n\t\tsortedLL = sortedLL.next;\n\t\tif(minNode.next != null) pq.add(minNode.next);\n\t} \n\treturn sortedLLHead.next;\n}\n\n```\n\n### Notes\n- Add the heads of LLs to a priority queue that can compare the value at the current node\n- pop each node off the min heap, and add to sorted linked list\n\t- add node back to heap if there `node.next != null`\n\t- repeat till pq is empty\n\n","lastmodified":"2024-07-04T20:24:17.033181857Z","tags":["dsadeck","arrays","heap","linkedlist"]},"/dsa/230.-Kth-Smallest-Element-in-a-BST":{"title":"230. Kth Smallest Element in a BST","content":"\n## Problem Statement\n\n\nPattern: \n\n---\n\n## Iterative Inorder Traversal Solution\n``` java\npublic int kthSmallest(TreeNode root, int k) {\n\tDeque\u003cTreeNode\u003e stack = new LinkedList\u003c\u003e();\n\twhile(root!=null || !stack.isEmpty()) {\n\t\tif(root != null) {\n\t\t\tstack.push(root);\n\t\t\troot = root.left;\n\t\t} else {\n\t\t\troot = stack.pop();\n\t\t\tif(k-- == 1) return root.val;\n\t\t\troot = root.right;\n\t\t}\n\t}\n\treturn -1; \n}\n```\n\n## Recursive Inorder Traversal Solution\n``` java\n    int count = 0;\n    public int kthSmallest (TreeNode root, int k){\n        if(root == null) return -1;\n\n        int left = kthSmallest(root.left, k);\n        if(++count == k) return root.val;\n        int right = kthSmallest(root.right, k);\n\n        return (left != -1) ? left : right;\n    }\n```\n\n\n## Morris Traversal Solution\n#todoleetcode \n","lastmodified":"2024-07-04T20:24:17.033181857Z","tags":["dsadeck","bst"]},"/dsa/236.-Lowest-Common-Ancestor-of-a-Binary-Tree":{"title":"236. Lowest Common Ancestor of a Binary Tree","content":"\n## Problem Statement\n\n\nPattern: \n\n---\n\n## Solution\n``` java\npublic TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\n\tif(root == null) return null;\n\t\n\tif(root == p || root == q) return root;\n\t\n\tTreeNode left = lowestCommonAncestor(root.left, p, q);\n\tTreeNode right = lowestCommonAncestor(root.right, p, q);\n\t\n\t// not found\n\tif(left == null \u0026\u0026 right == null) return null;\n\t\n\t// both found\n\tif(left != null \u0026\u0026 right != null) return root;\n\t\n\t// right found\n\tif(left == null) return right;\n\t\n\t// left found\n\telse return left;\n}\n```\n\n### Notes\n- even if both nodes are in the same bloodline, the ancestor (first one) gets returned\n\nConcise version\n``` java\npublic TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\n    if (root == null || root == p || root == q) return root;\n    TreeNode left = lowestCommonAncestor(root.left, p, q);\n    TreeNode right = lowestCommonAncestor(root.right, p, q);\n    return left == null ? right : right == null ? left : root;\n}\n```\n\n\n","lastmodified":"2024-07-04T20:24:17.033181857Z","tags":["dsadeck","binarytrees"]},"/dsa/238.-Product-of-Array-Except-Self":{"title":"238. Product of Array Except Self","content":"\n## Problem Statement\n![](https://i.imgur.com/K0XyLzI.png)\n\n\nPattern: [[Pattern Prefix Array]]\n\n---\n\n## Naive Solution\n``` java\npublic int[] productExceptSelf(int[] nums) {\n\tint prod = 1, zero = 0;\n\tfor (int num : nums)\n\t\tif (num == 0) zero++;\n\t\telse prod *= num;\n\t\n\tfor (int i = 0; i \u003c nums.length; i++) {\n\t\tswitch (zero) {\n\t\t\tcase 0: {\n\t\t\t\tnums[i] = divide(prod, nums[i]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 1: {\n\t\t\t\tif(nums[i] == 0) nums[i] = prod;\n\t\t\t\telse nums[i] = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdefault: {\n\t\t\t\tnums[i] = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn nums;\n}\n// count the no. of times b can be subtracted from a\nprivate  int divide(int a, int b) {\n\t// get absolute a b\n\tint sign = ((a \u003e 0 \u0026\u0026 b \u003e 0) || (a \u003c 0 \u0026\u0026 b \u003c 0)) ? 1 : -1;\n\ta = Math.abs(a);\n\tb = Math.abs(b);\n\t\n\t// edge cases\n\tif(a == 0) return 0;\n\tif(b == 1 || b == 0) return a*sign;\n\t\n\t// init\n\tint B = b, pow = 1, count = 0;\n\t\n\t// get the highest power of b less than a\n\twhile(a \u003e= B*b) {\n\t\tpow++;\n\t\tB *= b;\n\t}\n\t\n\twhile (a!=0) {\n\t\t// get correct pow\n\t\twhile(a \u003c B)\n\t\t\tB = (int) Math.pow(b, --pow);\n\t\t// divide\n\t\ta -= B;\n\t\t// update count\n\t\tcount += Math.pow(b, pow-1);\n\t\t//System.out.printf(\"Pow: %d  Count: %d\\n\", pow, count);\n\t}\n\treturn count * sign;\n}\n```\n\n### Notes\n- Works perfectly, but TLE if Input is too large ð¤·ââï¸\n- Basically we diviide how division works, except we increment decrement denominator in powers of itself `3 -\u003e 3, 9, 27, 81`\n\t- First increment to find largest power \n\t- Then as we start dividing (substracting from a) we reduce power when needed. \n\t- We update how many times we had to to remove `b` from `a`  in the variable `count`\n\n## Smart Solution\n``` java\npublic int[] productExceptSelf(int[] nums) {\n\t// init result array\n\tint n = nums.length;\n\tint[] res = new int [n];\n\t\n\t// convert res into prefix product array\n\tres[0] = 1;\n\tfor (int i = 1; i \u003c n ; i++) {\n\t\tres[i] = res[i-1]*nums[i-1];\n\t}\n\t\n\t// instead of suffix array we use suffix variable suffixProd\n\tint suffixProd = 1;\n\t// last el has no suffix i = n-2\n\tfor (int i = n-2; i \u003e= 0; i--) {\n\t\t// get suffix product\n\t\tsuffixProd *= nums[i+1];\n\t\tres[i] *= suffixProd;\n\t}\n\treturn res;\n}\n```\n\n### Notes\n- Simply put\n\t- create 2 arrays\n\t\t- prefix array : store the product of all the elements **BEFORE** i at `prefix[i]`\n\t\t- suffix array : store the product of all the elements **AFTER** i at `suffix[i]`\n\t- so `nums[i]` would simply be `prefix[i] * suffix[i]` - that is the product of all the numbers before and after `i`\n\t- since we can't have 2 extra arrays for storing the prefix and suffix separately\n\t\t- we store the prefix in the result array `res`, and multiply it with the current suffix `suffixProd` when we are moving backwards!!\n- `res` is the result array so it does not count as extra space. It is still constant space. If they had asked for an in-place solution, only then would we have been unable to create the result array\n\n","lastmodified":"2024-07-04T20:24:17.033181857Z","tags":["dsadeck","arrays"]},"/dsa/25.-Reverse-Nodes-in-k-Group":{"title":"25. Reverse Nodes in k-Group","content":"\n## Problem Statement\n\n\nPattern: \n\n---\n\nSimliar to [[Reverse LinkedList in Groups of K]] except If the number of nodes is not a multiple ofÂ `k`Â then left-out nodes, in the end, should remain as it is.\n\nthis is the iterative version\n## Solution\n``` java\npublic ListNode reverse (ListNode curr, ListNode prev, int k) {\n\twhile(k-- \u003e 0) {\n\t\tListNode next = curr.next;\n\t\tcurr.next = prev;\n\t\tprev = curr;\n\t\tcurr = next;\n\t}\n\treturn prev;\n}\n\npublic ListNode reverseKGroup (ListNode head, int k){\n\tListNode dummy = new ListNode(-1, head), dummyHead = dummy, successor = dummy.next;\n\n\twhile(successor != null) {\n\t\tint count = k;\n\t\t// check if k-reversible\n\t\twhile(count \u003e 0 \u0026\u0026 successor != null) {\n\t\t\tsuccessor = successor.next;\n\t\t\tcount--;\n\t\t}\n\t\tif(successor == null \u0026\u0026 count \u003e 0) break;\n\t\t\n\t\tdummy.next = reverse(dummy.next, successor, k);\n\t\twhile(count++ \u003c k \u0026\u0026 dummy != null) dummy = dummy.next;\n\t}\n\n\treturn dummyHead.next;\n}\n```\n\n### Notes\n- \n\n","lastmodified":"2024-07-04T20:24:17.033181857Z","tags":["dsadeck","linkedlist"]},"/dsa/26.-Remove-Duplicates-from-Sorted-Array":{"title":"26. Remove Duplicates from Sorted Array","content":"\n## Problem Statement\n\n\nPattern: [[Pattern Ghost Array]]\nRelated: [[80.Â Remove Duplicates from Sorted Array II]] [[27. Remove Element]]\n\n---\n\n## Solution\n``` java\npublic int removeDuplicates(int[] nums) {\n\t// init index\n\tint index =0;\n\t// get next element array\n\tfor (int num : nums) {\n\t\t// if first el of array or el \u003e last el inserted -\u003e insert element\n\t\tif(index == 0 || num \u003e nums[index-1]) nums[index++] = num;\n\t}\n\treturn index;\n}\n```\n\n### Notes\n- Only add to result array if next element is larger than last element\n- A naive appraoch to this problem is to manaully shift elements forward everytime an element gets repeated.\n\t- dw i did that too. find on intellij\n\n\n","lastmodified":"2024-07-04T20:24:17.033181857Z","tags":["dsadeck","arrays"]},"/dsa/268.-Missing-Number":{"title":"268. Missing Number","content":"\n## Problem Statement\n\n\nPattern: [[Pattern 1-n range array]]\n\n---\n\n## Solution\n``` java\nclass Solution {\n\tpublic void swap(int[] x, int a, int b) {\n\t\tint t = x[a];\n\t\tx[a] = x[b];\n\t\tx[b] = t;\n\t}\n\n\tpublic int missingNumber(int[] nums) {\n\t\tint n = nums.length, ans = n;\n\n\t\t// cycle sort\n\t\tfor (int i = 0; i \u003c n; i++)\n\t\t\twhile (nums[i] != i) {\n\t\t\t\t// if final no.\n\t\t\t\tif (nums[i] == n) break;\n\t\t\t\tswap(nums, i, nums[i]);\n\t\t\t}\n\n\t\t// scan for el not matching index\n\t\tfor (int i = 0; i \u003c n; i++) {\n\t\t\tif (nums[i] != i)\n\t\t\t\tans = i;\n\t\t}\n\t\treturn ans;\n\t}\n}\n```\n\n### Notes\n- Cna also bee done with self-freq array\n\n\n","lastmodified":"2024-07-04T20:24:17.033181857Z","tags":["easy","arrays","completed","dsadeck"]},"/dsa/27.-Remove-Element":{"title":"27. Remove Element","content":"\nResources: [Remove Element - LeetCode](https://leetcode.com/problems/remove-element/)\n\n\n# Problem Statement\nGiven an integer array `nums` and an integer `val`, remove all occurrences of `val` in `nums` [**in-place**](https://en.wikipedia.org/wiki/In-place_algorithm). The relative order of the elements may be changed.\n\n\n###  Stack\n- DS: [[Arrays]]\n- Algo: \n- Technique: [[Pattern Ghost Array]]\n---\n\n# Solutions\n**Mine**\n``` cpp\nclass Solution {\npublic:\n    \n    int removeElement(vector\u003cint\u003e\u0026 nums, int val) {\n        \n        if(nums.size()==0){\n            return 0;\n        }\n        \n        vector \u003cint\u003e::iterator valit = nums.end()-1;\n        vector \u003cint\u003e::iterator arrit = nums.end() -2;\n\n        // find first non val\n        while(*valit == val \u0026\u0026 valit \u003e nums.begin()) {\n            valit--;    \n        }\n        \n        // if valit reaches begin\n        if(valit == nums.begin()){\n            if(*valit == val)\n                return 0;\n            return 1;\n        }\n            \n        \n        arrit = valit-1;\n        \n        // if *arrit = *valit\n        while(arrit \u003e= nums.begin()){\n            if(*arrit == val){\n                iter_swap(valit, arrit);\n                valit--;\n            }\n            arrit--;\n        }\n        \n        // return count of remaingin array\n        int count = 0;\n        while(valit \u003e= nums.begin()){\n            valit--;\n            count++;\n        }\n        \n        return count;\n    }\n};\n```\n\n**Official**\n``` cpp\npublic int removeElement(int[] nums, int val) {\n    int i = 0;\n    for (int j = 0; j \u003c nums.length; j++) {\n        if (nums[j] != val) {\n            nums[i] = nums[j];\n            i++;\n        }\n    }\n    return i;\n}\n```\n\n``` cpp\npublic int removeElement(int[] nums, int val) {\n    int i = 0;\n    int n = nums.length;\n    while (i \u003c n) {\n        if (nums[i] == val) {\n            nums[i] = nums[n - 1];\n            // reduce array size by one\n            n--;\n        } else {\n            i++;\n        }\n    }\n    return n;\n}\n```\n\n\n\n## Explanation\n**Mine**\nSimple Reverse two pointer, at the same end, one stays in front of the first non-target element from the back. The other traverses the array to find targets to swap with.\n**Official**\nRewrite the array from the start, as thought it were a ghost array using a pointer, and let the other pointer run forward to find the next element thats not a \"val\"\n**Second Official**\njust keep writing elements from the end of the array to the val indexes\n\n## Insights\n-  \n\n`Time Complexity: O(N)`\n`Space Complexity: O(1)`\n\n## Related\n- \n","lastmodified":"2024-07-04T20:24:17.033181857Z","tags":["dsadeck"]},"/dsa/278.-First-Bad-Version":{"title":"278. First Bad Version","content":"\n\n## Problem Statement\n[First Bad Version - LeetCode](https://leetcode.com/problems/first-bad-version/)\n\nPattern: [[Binary Search#Floor Ceil]]\nSimilar to: [Peak Index in a Mountain Array - LeetCode](https://leetcode.com/problems/peak-index-in-a-mountain-array/) |  [Valid Mountain Array - LeetCode](https://leetcode.com/problems/valid-mountain-array/)\n\n---\n\n## Solution\n``` java\npublic int firstBadVersion(int n) {\n\tint start = 0, end = n, mid ;\n\twhile(start \u003c= end) {\n\t\tmid = start + (end-start)/2;\n\t\tif(isBadVersion(mid)) // mid \u003e key\n\t\t\tend = mid - 1;\n\t\telse                  // mid  \u003c key\n\t\t\tstart = mid + 1;\n\t}\n\treturn start;\n}\n```\n\n### Notes\n- A glorfied binary search ceil problem.\n\n\n## Peak Index in Mountain Array\n``` java\npublic int peakIndexInMountainArray(int[] arr) {\n\tint start = 0, end =arr.length-1;\n\twhile(start \u003c end) {\n\t\tint mid = start + (end-start)/2;\n\t\tif(arr[mid + 1] \u003e arr[mid]) start = mid + 1;\n\t\telse end = mid;\n\t}\n\treturn start;\n}\n```\n\n### Notes\n- Here we use the binary search ceiling approach\n- this allows us to simplify the logic for `(arr[mid+1] \u003e arr[mid])` we can use this, since we dont have to worry about start or end ever being out of bounds, since the loop will break when `start == end` \n\t- Firstly `start + (end - start) / 2` will always result in ` start \u003c= mid  \u003c end`. i.e. `mid` will never be equal to `end` since the division operation always returns the `floor` of the result. so when it comes down to 2 adjacent numbers `start` and `end`, mid will always point to `start`\n\t- secondly instead of returning when the element is found we keep it in range by adjusting `end` to  `end = mid` and not `end = mid - 1` which is typically the case.\n\t- if the key value is reached, then end will be reassigned to it.\n\t- at the end `start` and `end` will converge onto a singular value so any which one may be returned\n- We can do the same thing the other way around\n\t- return ceil of the division `int mid = start + (end-start + 1)/2`. at the end `mid` will always point to `end`\n\t- keep `key` in range by reassigning `start = mid`\n\t- at the end `start` and `end` will converge onto a singular value so any which one may be returned\n\n``` java\npublic int peakIndexInMountainArray(int[] arr) {\n\tint start = 0, end =arr.length-1;\n\twhile(start \u003c end) {\n\t\tint mid = start + (end-start + 1)/2;\n\t\tif(arr[mid - 1] \u003e arr[mid]) end = mid- 1;\n\t\telse start = mid;\n\t}\n\treturn start;\n}\n```\n\n\n","lastmodified":"2024-07-04T20:24:17.033181857Z","tags":["dsadeck","arrays","completed","incomplete"]},"/dsa/287.-Find-the-Duplicate-Number":{"title":"287. Find the Duplicate Number","content":"\n## Problem Statement\nGiven an array of integersÂ `nums`Â containingÂ `n + 1`Â integers where each integer is in the rangeÂ `[1, n]`Â inclusive.\n\nThere is onlyÂ **one repeated number**Â inÂ `nums`, returnÂ _thisÂ repeatedÂ number_.\n\n\u003e You must solve the problemÂ **without**Â modifying the arrayÂ `nums`Â and uses only constant extra space.\n\nPattern:  [[Pattern 1-n range array]] [[Pattern Fast and Slow Pointer]]\n\n---\n#todoleetcode \n## Solution\n``` java\n\n```\n\n### Notes\n- This can also be solved via the [[Pattern 1-n range array#Self Freq Array Approach|self-freq array method]] . Negative mark an array, then unmark it\n- Fast and slow pointer to find cycle, then find the start of the cycle\n\n``` java\npublic int findDuplicate(int[] nums) {\n\t// Find the intersection point of the two runners.\n\tint tortoise = nums[0];\n\tint hare = nums[0];\n\t\n\tdo {\n\t\ttortoise = nums[tortoise];\n\t\thare = nums[nums[hare]];\n\t} while (tortoise != hare);\n\n\t// Find the \"entrance\" to the cycle.\n\ttortoise = nums[0];\n\t\n\twhile (tortoise != hare) {\n\t\ttortoise = nums[tortoise];\n\t\thare = nums[hare];\n\t}\n\treturn hare;\n}\n```\n\n","lastmodified":"2024-07-04T20:24:17.033181857Z","tags":["easy","arrays","completed","dsadeck"]},"/dsa/295.-Find-Median-from-Data-Stream":{"title":"295. Find Median from Data Stream","content":"\n## Problem Statement\n[Find Median from Data Stream - LeetCode](https://leetcode.com/problems/find-median-from-data-stream/)\n\nPattern: \n\n---\n\n## Solution\n``` java\npublic class FindMedianinStream295 {\n\tstatic class MedianFinder {\n\t\t\n\t\tprivate PriorityQueue\u003cInteger\u003e lMax;\n\t\tprivate PriorityQueue\u003cInteger\u003e rMin;\n\t\tprivate double currMedian;\n\t\t\n\t\t// constructor\n\t\tpublic MedianFinder() {\n\t\t\tlMax = new PriorityQueue\u003c\u003e(Collections.reverseOrder());\n\t\t\trMin = new PriorityQueue\u003c\u003e();\n\t\t\tcurrMedian = 0;\n\t\t}\n\t\t\n\t\t// add num to DS\n\t\tpublic void addNum (int num) {\n\t\t\tswitch (lMax.size() - rMin.size()) {\n\t\t\t\t// l == r\n\t\t\t\tcase 0 : {\n\t\t\t\t\t// add to right\n\t\t\t\t\tif(num \u003e= currMedian) rMin.add(num);\n\t\t\t\t\t// add to left\n\t\t\t\t\telse lMax.add(num);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t// l \u003e r\n\t\t\t\tcase 1 : {\n\t\t\t\t\t// add to right\n\t\t\t\t\tif(num \u003e= currMedian) rMin.add(num);\n\t\t\t\t\t// add to left\n\t\t\t\t\telse {\n\t\t\t\t\t\t// balance heaps\n\t\t\t\t\t\trMin.add(lMax.poll());\n\t\t\t\t\t\t// add num to left heap\n\t\t\t\t\t\tlMax.add(num);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t// r \u003e l\n\t\t\t\tcase -1 : {\n\t\t\t\t\t// add to right\n\t\t\t\t\tif(num \u003e= currMedian){\n\t\t\t\t\t\t// balance heaps\n\t\t\t\t\t\tlMax.add(rMin.poll());\n\t\t\t\t\t\t// add to rMin\n\t\t\t\t\t\trMin.add(num);\n\t\t\t\t\t}\n\t\t\t\t\t// add to left\n\t\t\t\t\telse lMax.add(num);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// update median\n\t\t\tfindMedian();\n\t\t\t//System.out.printf(\"num :%d , currMedian: %f , lMax: %d, rMin: %d\\n\", num, currMedian, lMax.peek(), rMin.peek());\n\t\t}\n\t\t\n\t\t// find median\n\t    public double findMedian (){\n\t\t\tint size = lMax.size() + rMin.size();\n\t\t\t// even size -\u003e avg of heap peeks\n\t\t\tif((size \u0026 1) == 0) currMedian = ((double) lMax.peek()+ (double) rMin.peek())/ (double)2;\n\t\t\t// larger heap peek is the median\n\t\t\telse if (lMax.size() \u003e rMin.size()) currMedian = lMax.peek();\n\t\t\telse currMedian = rMin.peek();\n\t\t\t// return median\n\t\t\treturn currMedian;\n\t\t}\n\t}\n\t\n\t// region MAIN\n\tpublic static void main(String[] args) {\n\t    MedianFinder mf = new MedianFinder();\n\t\tmf.addNum(1);\n\t\tmf.addNum(2);\n\t\tSystem.out.println(mf.findMedian());\n\t\tmf.addNum(3);\n\t\tSystem.out.println(mf.findMedian());\n\t}\n\t// endregion\n}\n\n```\n### Output:\n```txt\n1.5\n2.0\n```\n\n\n### Notes\n- an array can be thought of as to heaps left and right. left heap is a maxHeap whose greatest element is less than the median, and right heap is a min heap whose smallest element is larger than the median.\n- insert element in the left or right heap depending on if it is greater or smaller than median\n\t- update median\n\t- repeat till needed\n- inserting elements is not super straightforward. the idea is to maintain heaps in such a way that all the elements in the leftMax heap are always less than the currentMedian and the elements in the rightMin heap are always greater than the currentMedian\n\t- So say 2 consecutive elements added are greater than the currentMedian, the median would shift towards the right heap. \n\t- this is why we must always make sure `leftMax.size - rightMin.size \u003c= 1`\n\t- [Love Babbar Video Explaining Solution](https://youtu.be/RrxpTWqj97A?t=2270)\n\n","lastmodified":"2024-07-04T20:24:17.033181857Z","tags":["dsadeck","arrays"]},"/dsa/297.-Serialize-and-Deserialize-Binary-Tree":{"title":"297. Serialize and Deserialize Binary Tree","content":"\n## Problem Statement\n\n\nPattern: \nRelated: [[652. Find Duplicate Subtrees]]\n\n---\n\n## Solution\n``` java\n// preorder build string fun\nvoid preString(TreeNode root, StringBuilder sb) {\n\tif (root == null) {\n\t\tsb.append(\"#\").append(\" \");\n\t\treturn;\n\t}\n\tsb.append(root.val).append(\" \");\n\tpreString(root.left, sb);\n\tpreString(root.right, sb);\n}\n\n// preorder build nodes fun\nTreeNode preNode(Queue\u003cString\u003e nodes) {\n\tString val = nodes.remove();\n\tif (val.equals(\"#\")) return null;\n\t\n\tTreeNode root = new TreeNode(Integer.parseInt(val));\n\troot.left = preNode(nodes);\n\troot.right = preNode(nodes);\n\t\n\treturn root;\n}\n\n// Encodes a tree to a single string.\npublic String serialize(TreeNode root) {\n\tStringBuilder sb = new StringBuilder();\n\tpreString(root, sb);\n\treturn sb.toString();\n}\n\n// Decodes your encoded data to tree.\npublic TreeNode deserialize(String str) {\n\tQueue\u003cString\u003e nodes = new LinkedList\u003c\u003e(Arrays.asList(str.split(\" \")));\n\treturn preNode(nodes);\n}\n```\n\n### Notes\n- preorder traverse, build string\n- preorder traverse, build tree\nð¤·\n\n\n","lastmodified":"2024-07-04T20:24:17.033181857Z","tags":["dsadeck","binarytrees"]},"/dsa/31.-Next-Permutation":{"title":"31. Next Permutation","content":"\n## Problem Statement\n\n\nPattern: [[Next Permutation]]\n\n---\n\n## Solution\n\n``` java\npublic static void swap(int[] x, int a, int b) {\n\tint t = x[a];\n\tx[a] = x[b];\n\tx[b] = t;\n}\n\n\npublic void nextPermutation(int[] nums){\n\tif (nums.length == 1) return;\n\t\n\t// pivot -\u003e first smaller el in reverse, el right before the decreasing suffix\n\tint pivot = findPivot(nums);\n\t\n\tif(pivot != -1) {\n\t\t// nextPivot -\u003e rightmost-element \u003e pivot\n\t\tint nextPivot = findNextPivot(nums, nums[pivot]);\n\t\t// swap with pivot\n\t\tswap(nums, pivot, nextPivot);\n\t}\n\t// sort decreasing suffix to ascending\n\tArrays.sort(nums, pivot+1, nums.length);\n}\n\nprivate int findNextPivot(int[] nums, int pivotElement) {\n\t// npi -\u003e next pivot index\n\t// return index of first element \u003e pivotElement in reverse\n\tfor (int npi = nums.length-1; npi \u003e= 0; npi--)\n\t\tif(nums[npi] \u003e pivotElement) return npi;\n\treturn -1;\n}\n\nprivate int findPivot(int[] nums) {\n\t// return first non-increasing element in reverse\n\tfor(int pivot = nums.length-1; pivot \u003e= 0 ; pivot--)\n\t\tif(pivot \u003c nums.length-1 \u0026\u0026 nums[pivot] \u003c nums[pivot+1])\n\t\t\treturn pivot;\n\treturn -1;\n}\n```\n\n### Notes\n- \n\n","lastmodified":"2024-07-04T20:24:17.033181857Z","tags":["dsadeck","arrays","permutation"]},"/dsa/315.-Count-of-Smaller-Numbers-After-Self":{"title":"315. Count of Smaller Numbers After Self","content":"\n## Problem Statement\n[Count of Smaller Numbers After Self - LeetCode](https://leetcode.com/problems/count-of-smaller-numbers-after-self/)\n![](https://i.imgur.com/I1txxJP.png)\n\n\nPattern: [[Merge Sort]] \n\n---\n\n## Naive Solution\n``` java\npublic List\u003cInteger\u003e countSmaller1(int[] nums) {\n\tArrayList\u003cInteger\u003e res = new ArrayList\u003c\u003e();\n\tfor (int i = 0; i \u003c nums.length; i++) {\n\t\tint count = 0;\n\t\tfor (int j = i + 1; j \u003c nums.length; j++)\n\t\t\tif (nums[j] \u003c nums[i]) count++;\n\t\tres.add(count);\n\t}\n\treturn res;\n}\n```\n\nFor every element count no.  of elements to its right smaller thant it. that is the inverstion count of that number.\n\n\n## Optimised Solution\n\n``` java\nprivate class IndexedInteger {\n\tint val;\n\tint originalIdx;\n\t\n\tpublic IndexedInteger(int val, int originalIdx) {\n\t\tthis.val = val;\n\t\tthis.originalIdx = originalIdx;\n\t}\n}\n\npublic List\u003cInteger\u003e countSmaller(int[] nums) {\n\t// create numsList to keep track of original index\n\tIndexedInteger[] numsList = new IndexedInteger[nums.length];\n\tfor (int i = 0; i \u003c nums.length; i++) numsList[i] = new IndexedInteger(nums[i], i);\n\t\n\t// find and store Inversion count for numbers in numsList in res using their original index\n\tint[] res = new int[nums.length];\n\tmergeSort(numsList, 0, nums.length - 1, res);\n\t\n\t// convert to arrayList and return\n\tArrayList\u003cInteger\u003e result = new ArrayList\u003c\u003e();\n\tfor (int num : res) result.add(num);\n\treturn result;\n}\n\nprivate void mergeSort(IndexedInteger[] numsList, int start, int end, int[] res) {\n\t// single element exit condition\n\tif (start \u003e= end) return;\n\t\n\t// find mid\n\tint mid = start + (end - start) / 2;\n\t\n\t// recurse for left and right subarray\n\tmergeSort(numsList, start, mid, res);\n\tmergeSort(numsList, mid + 1, end, res);\n\t\n\tmerge(numsList, start, end, res);\n}\n\nprivate void merge (IndexedInteger[] numsList, int start, int end, int[] res) {\n\t// temp LL to store merged/sorted arr\n\tLinkedList\u003cIndexedInteger\u003e temp = new LinkedList\u003c\u003e();\n\t\n\t// left \u0026 right subarray pointers, inversionCount -\u003e count of smaller els in right subarr\n\tint mid = start + (end - start) / 2, left = start, right = mid + 1, inversionCount = 0;\n\t\n\t// merge subarrs into temp\n\twhile (left \u003c= mid \u0026\u0026 right \u003c= end) {\n\t\t// left is (strictly) smaller (not equal to)\n\t\tif (numsList[right].val \u003c numsList[left].val) {\n\t\t\tinversionCount++;                   // increment inversion count\n\t\t\ttemp.add(numsList[right++]);\n\t\t}\n\t\t// right is smaller\n\t\telse {\n\t\t\tres[numsList[left].originalIdx] += inversionCount;    // update res inversionCount\n\t\t\ttemp.add(numsList[left++]);\n\t\t}\n\t}\n\t\n\t// merge leftovers\n\twhile (left \u003c= mid) {\n\t\tres[numsList[left].originalIdx] += inversionCount;\n\t\ttemp.add(numsList[left++]);\n\t}\n\twhile (right \u003c= end) {\n\t\ttemp.add(numsList[right++]);\n\t}\n\t\n\t// update sorted array in numsList\n\tfor (IndexedInteger t : temp) numsList[start++] = t;\n}\n```\n\n- we update inversion count, only when right is smaller, since only then it would be called an inversion, else it would just be an equal element to the right of the same element, it wouldnt count as an inversion\n- we have a temp array \n\n\nRelated: [Count Inversions | Practice | GeeksforGeeks](https://practice.geeksforgeeks.org/problems/inversion-of-array-1587115620/1)","lastmodified":"2024-07-04T20:24:17.033181857Z","tags":["dsadeck","arrays"]},"/dsa/316.-Remove-Duplicate-Letters":{"title":"316. Remove Duplicate Letters","content":"\n## Problem Statement\n\n\nPattern: \n\n---\n\n## Solution\n``` java\npublic String removeDuplicateLetters(String s) {\n\t// find smallest char\n\tint[] lastIndex = new int[26];\n\tchar[] chars = s.toCharArray();\n\tint si = 0, n = s.length();\n\tDeque\u003cCharacter\u003e stack = new LinkedList\u003c\u003e();\n\tHashSet\u003cCharacter\u003e stackSet = new HashSet\u003c\u003e();\n\n\t// get last indices\n\tfor (int i = 0; i \u003c chars.length; i++) lastIndex[chars[i] - 'a'] = i;\n\n\tfor (int i = 0; i \u003c n; i++) {\n\t\tchar ch = chars[i];\n\t\tif (!stackSet.contains(ch)) {\n\t\t\twhile (!stack.isEmpty() \u0026\u0026 ch \u003c stack.peek() \u0026\u0026 lastIndex[stack.peek() - 'a'] \u003e i ) stackSet.remove(stack.pop());\n\t\t\tstack.push(ch);\n\t\t\tstackSet.add(ch);\n\t\t}\n\t}\n\n\t// convert to string\n\tStringBuilder sb = new StringBuilder();\n\tfor (char ch : stack) sb.append(ch);\n\treturn sb.reverse().toString();\n}\n```\nTC : $O(n)$\nSC : $O(n)$\n\n### Notes\n- \n\n\n\n","lastmodified":"2024-07-04T20:24:17.033181857Z","tags":["dsadeck","strings","stacks"]},"/dsa/34.-Find-First-and-Last-Position-of-Element-in-Sorted-Array":{"title":"34. Find First and Last Position of Element in Sorted Array","content":"## Problem Statement\n\n\nPattern: [[Binary Search]]\n\n---\n\n## Solution\n\n``` java\nstatic int search(int[] nums, int target, boolean findLeft) {  \n   int start = 0, end = nums.length - 1, mid ans = -1;  \n   // find left-most occurrence  \n   while (start \u003c= end) {  \n      mid = start + (end - start) / 2;  \n      if (nums[mid] \u003c target) start = mid + 1;  \n      else if (nums[mid] \u003e target) end = mid - 1;  \n         // if target found  \n      else {  \n         ans = mid;   // update ans  \n         if (findLeft) end = mid - 1;  // keep searching left of mid  \n         else start = mid + 1;       // keep searching right of mid  \n      }  \n   }  \n   return ans;  \n}  \n  \npublic static int[] searchRange(int[] nums, int target) {  \n   int[] ans = {-1, -1};  \n   ans[0] = search(nums, target, true);  \n   ans[1] = search (nums, target, false);  \n   return ans;  \n}\n```\n\n\n### Notes\n\n\n\n","lastmodified":"2024-07-04T20:24:17.033181857Z","tags":["medium","arrays","completed","binarysearch"]},"/dsa/35.-Search-Insert-Position":{"title":"35. Search Insert Position","content":"\n\t\n## Problem Statement\n\n\nPattern: \n\n---\n\n## Solution\n``` java\npublic int searchInsert(int[] nums, int target) {\n\t// perform binary search\n\tint start = 0, end = nums.length - 1, mid;\n\n\twhile (start \u003c= end) {\n\t\tmid = start + (end - start) / 2;\n\n\t\tif (nums[mid] \u003e target) end = mid - 1;\n\t\telse if (nums[mid] \u003c target) start = mid + 1;\n\t\telse return mid;\n\t}\n\t// mid not returned -\u003e el not found\n\treturn start;                                \t\t\n}\n```\n\n### Notes\n- Simple [[Binary Search#Floor Ceil]] problem. This is a ceiling problem so we return the `start` since it will point to the ceiling at the exit condition\n\n","lastmodified":"2024-07-04T20:24:17.033181857Z","tags":["easy","arrays","dsadeck","binarysearch"]},"/dsa/372.-Super-Pow":{"title":"372. Super Pow","content":"\n[Super Pow - LeetCode](https://leetcode.com/problems/super-pow/)\n\n## Problem Statement\n\n\nPattern: [[Pattern Modulo]]\n\n---\n\n## Solution\n``` java\n\n```\n\n### Notes\n- \n\n","lastmodified":"2024-07-04T20:24:17.033181857Z","tags":["dsadeck","arrays","completed","incomplete"]},"/dsa/378.-Kth-Smallest-Element-in-a-Sorted-Matrix":{"title":"378. Kth Smallest Element in a Sorted Matrix","content":"\n## Problem Statement\n\n\nPattern: \n\n---\n\n## Solution\n``` java\npublic int kthSmallest(int[][] matrix, int k) {\n\t// prepare min-heap\n\tint n = matrix.length, m = matrix[0].length;\n\tPriorityQueue\u003cint[]\u003e pq = \n\t\tnew PriorityQueue\u003c\u003e((a, b) -\u003e Integer.compare(a[0], b[0]));\n\tfor (int i = 0, j = 0; i \u003c n ; i++) \n\t\tpq.add(new int[] {matrix[i][j], i, j});\n\t\n\t// get kth element\n\tint ans = -1;\n\tfor (int i = 0 ; i \u003c k ; i++) {\n\t\tint[] arr = pq.poll();\n\t\tans = arr[0];\n\t\tint row = arr[1], col = arr[2];\n\t\t// reinsert into priority queue\n\t\tif(col+1 \u003c m) pq.add(new int[]{matrix[row][col+1], row, col+1});\n\t}\n\treturn ans;\n}\n```\n\n### Notes\n- pointer to the start of all rows in a priority queue, get the kth element\n\n","lastmodified":"2024-07-04T20:24:17.033181857Z","tags":["easy","arrays","tbdone","dsadeck"]},"/dsa/38.-Count-and-Say":{"title":"38. Count and Say","content":"\n## Problem Statement\n\n\nPattern: \n\n---\n\n## Solution\n``` java\npublic String countAndSay(int n) {\n\tif (n \u003c= 1) return \"1\";\n\tString num = countAndSay(n - 1);\n\t\n\tint count = 0;\n\tchar curr = num.charAt(0);\n\tStringBuilder sb = new StringBuilder();\n\t\n\tfor (char ch : num.toCharArray()) {\n\t\tif (ch == curr) count++;\n\t\telse {\n\t\t\tsb.append(count).append(curr) ;\n\t\t\tcount = 1; curr = ch;\n\t\t}\n\t}\n\tsb.append(count).append(curr);\n\treturn sb.toString();\n}\n\n```\nTC : \nSC : \n\n### Notes\n- \n\n\n\n","lastmodified":"2024-07-04T20:24:17.033181857Z","tags":["dsadeck","strings"]},"/dsa/4.-Median-of-Two-Sorted-Arrays":{"title":"4. Median of Two Sorted Arrays","content":"\n## Problem Statement\n![](https://i.imgur.com/PoWcqq4.png)\n\n\nPattern: [[Binary Search]]\n\n---\n\n## Solution\n``` java\npublic double findMedianSortedArrays(int[] a, int[] b) {\n\tint n1 = a.length, n2 = b.length, total = n1 + n2, half = total / 2;\n\tif (n1 \u003e n2) return findMedianSortedArrays(b, a);   // let a -\u003e shorter array\n\t\n\tint start = -1, end = n1;\n\twhile (true) {\n\t\t// a partition's ptr\n\t\tint mid = start + (end-start)/ 2;\n\t\t// b partition's ptr -\u003e determined a-pointer 'mid'\n\t\tint bmid = half - mid - 2;   // -2 to offset 0-based error\n\t\t\n\t\t// a and b partition's left and right values, accounting for Out Of Bounds\n\t\tint aleft = (mid \u003e= 0) ? a[mid] : Integer.MIN_VALUE;\n\t\tint aright = (mid + 1 \u003c n1) ? a[mid + 1] : Integer.MAX_VALUE;\n\t\tint bleft = (bmid \u003e= 0) ? b[bmid] : Integer.MIN_VALUE;\n\t\tint bright = (bmid + 1 \u003c n2) ? b[bmid + 1] : Integer.MAX_VALUE;\n\t\t\n\t\t// aleft partition is overextending\n\t\tif (aleft \u003e bright) end = mid - 1;\n\t\t// bleft partition is overextending\n\t\telse if (bleft \u003e aright) start = mid + 1;\n\t\t// both partitions are perfect -\u003e return median\n\t\telse {   // aleft \u003c= bright \u0026\u0026 bleft \u003c= aright\n\t\t\t// odd\n\t\t\tif (total % 2 != 0) return Math.min(aright, bright);\n\t\t\t// even\n\t\t\telse return (double) (Math.max(aleft, bleft) + Math.min(aright, bright)) / 2;\n\t\t}\n\t}\n}\n```\n\n### Notes\n- Solution: is 'adapted' from this video ð\n\t- [Median of Two Sorted Arrays - Binary Search - Leetcode 4 - YouTube](https://www.youtube.com/watch?v=q6IEA26hvXc)\n\t- ![](https://i.imgur.com/5gLuACp.png)\n\t- the only caveat being ð\n\t- for that test case to pass, we need to quite unintuitively set `start = -1` and `end = n1`\n\n## Explanation:\n[Median of Two Sorted Arrays - Binary Search - Leetcode 4 - YouTube](https://www.youtube.com/watch?v=q6IEA26hvXc)\n- First take a glance at the approach we took towards the problem [[GFG Median of 2 Sorted Arrays of Same Size]]\n- In this case, instead of `n` the position where we will find the median is (n1+n2)/2, which here we take to be `half = total / 2`\n- start and end are unintuitively intialised to `int start = -1, end = n1`  to address an edge case, where `a` is of length 1, and `aleft \u003e bright` (check [[#Notes]])\n- now with that out of the way\n- the final 'merged' array will have some elements from the 'smaller' array and some from the other one.\n- when we pick let's say `x` elements from `a`, we are forced to pick `half - x` elemebts from `b`. Since `a` and `b` are the only 2 arrays to be merged\n- This question can be rephrased as PICK THE SMALLEST 'M+N/2' ELEMENTS FROM 2 SORTED ARRAYS.\n- so we apply binary search to find that sweet spot `x` in a.\n- just watch the video\n\n\n\n\n","lastmodified":"2024-07-04T20:24:17.033181857Z","tags":["dsadeck","arrays","hard","incomplete"]},"/dsa/41.-First-Missing-Positive":{"title":"41. First Missing Positive","content":"\n## Problem Statement\n[First Missing Positive - LeetCode](https://leetcode.com/problems/first-missing-positive/)\n[Apna College Video](https://youtu.be/kJW_iXrwePE?list=PLfqMhTWNBTe0b2nM6JHVCnAkhQRGiZMSJ)\n\nRelated:   [[Pattern 1-n range array]] \n\n---\nRelated : [[Cycle Sort]]\n\n## Naive Solution\nN time N Space Solution\n\n``` cpp\n// naive approach O(n) space\nint findNumber(int* arr, int n) {\n    // create freq arr of positive number\n    const int N = 1e6 + 2;\n    bool freq_arr[N] = {false};\n    for (int i = 0; i \u003c n; i++) {\n        if (arr[i] \u003e 0)\n            freq_arr[arr[i]] = true;\n    }\n\n    // find gap\n    bool ansFound = false;\n    int ans = 1;\n    for (ans; ans \u003c N; ans++)\n        if (freq_arr[ans] == false) {\n            ansFound = true;\n            break;\n        }\n\n    if (!ansFound)\n        return -1;\n\n    return ans;\n}\n\n// optimized approach O(1) Space\n\n```\n\nN time 1 Space Solution\n\n\n\n\n## Cycle sort Solution\n\n- Assume that array only contains numbers from 1-n\n- while element at ith position is not i+1, then swap it to its correct positon\n\t- if el is negative or greater than n, moce onto next element\n\t- if target el is same as target element, move onto next element\n\n![[Cycle Sort#Range 1-n]]","lastmodified":"2024-07-04T20:24:17.033181857Z","tags":["hard","arrays","incomplete","dsadeck"]},"/dsa/416.-Partition-Equal-Subset-Sum":{"title":"416. Partition Equal Subset Sum","content":"\n## Problem Statement\n[Partition Equal Subset Sum - LeetCode](https://leetcode.com/problems/partition-equal-subset-sum/)\nSubset Sum Problem : Find if there is a subset in array whose sum equals `target`\n\nPattern: [[Pattern DP Subset Sum]]\n\n---\n# Approach 1 \n## Brute Force\n``` java\npublic boolean canPartition (int[] nums){\n\treturn f(nums, nums.length-1, 0, 0);\n}\nboolean f(int[] nums, int n, int sum1, int sum2) {\n\tif(n \u003c 0) return sum1==sum2;\t\t\n\treturn f(nums, n-1, sum1+nums[n], sum2)\n\t\t|| f(nums, n-1, sum1, sum2+nums[n]);\n}\n```\nTC : $O(2^n)$\nSC :  \n\n## Memoised\n``` java\nint[][] cache;\npublic boolean canPartition (int[] nums){\n\tcache = new int[nums.length][20000+1];\n\tfor(int[] row : cache) Arrays.fill(row, -1);\n\treturn f(nums, nums.length-1, 0, 0);\n}\n\nboolean f(int[] nums, int n, int sum1, int sum2) {\n\tif(n \u003c 0) return sum1==sum2;\n\tif(cache[n][sum1] != -1){ return cache[n][sum1] == 1;}\n\t\n\tboolean found = f(nums, n-1, sum1+nums[n], sum2)\n\t\t\t\t || f(nums, n-1, sum1, sum2+nums[n]);\n\tcache[n][sum1] = found ? 1 : 0;\n\treturn found;\n}\n```\nTC : ` n*sum `\n\n# Approach 2\n## Optimised Brute Force\n``` java\npublic boolean canPartition(int[] nums) {  \n   int sum = 0;  \n   for (int num : nums) sum += num;  \n   if(sum%2 != 0) return false;  \n   return f(nums, nums.length - 1, sum/2);  \n}  \n  \nboolean f(int[] nums, int n, int target) {  \n   if (n \u003c 0) return target == 0;  \n   if(target == 0) return true;  \n   if(nums[n] \u003c= target) \n\t   return f(nums, n - 1, target-nums[n]) || f(nums, n - 1, target);\n   return f(nums, n - 1, target);\n}\n```\n- 2 partitions can be equal only if the sum is even\n- so simply track if a single `sum/2` can be reached, by any subset in the array\n\n## Optimised Memoised\n\n``` java\nBoolean[][] cache;\n\npublic boolean canPartition(int[] nums) {\n\tint sum = 0;\n\tfor (int num : nums) sum += num;\n\n\tif(sum%2 != 0) return false;\n\tcache = new Boolean[nums.length][sum/2+1];\n\n\treturn f(nums, nums.length - 1, sum/2);\n}\n\nboolean f(int[] nums, int n, int target) {\n\tif (n \u003c 0) return target == 0;\n\tif(target == 0) return true;\n\n\tif(cache[n][target] != null) return cache[n][target];\n\n\tif(nums[n] \u003c= target) \n\t\tcache[n][target] = f(nums, n - 1, target-nums[n]) || f(nums, n - 1, target);\n\telse \n\t\tcache[n][target] = f(nums, n - 1, target);\n\t\n\treturn cache[n][target];\n}\n```\nTC : ` n*sum/2`\n\n## Iterative\n``` java\npublic boolean canPartition(int[] nums) {\n\tint k = 0, n = nums.length;\n\tfor (int num : nums) k += num;\n\tif (k % 2 != 0) return false;\n\tk/=2;\n\n\t// init dp\n\tboolean dp[][] = new boolean[n + 1][k + 1];\n\tfor (int j=0, i = 1; i \u003c n+1; i++) dp[i][j] = true;\n\t// for (int j=1, i = 0; j \u003c k+1; j++) dp[i][j] = false; // redundant\n\n\tfor (int i = 1; i \u003c n+1; i++)\n\t\tfor (int j = 1; j \u003c k + 1; j++)\n\t\t\tif(nums[i-1] \u003c= j)\n\t\t\t\tdp[i][j] = dp[i-1][j-nums[i-1]] || dp[i-1][j];\n\t\t\telse dp[i][j] = dp[i-1][j];\n\treturn dp[n][k];\n}\n```\nTC : $n \\times k$\n\n### Notes\n\n``` java\nif(nums[i-1] \u003c= j)\n\tdp[i][j] = dp[i-1][j-nums[i-1]] || dp[i-1][j]; // ð what does this mean\nelse dp[i][j] = dp[i-1][j];\n```\n\n```\ndp[ith item][sum equalling j] is true if either of the following is true\t\n- dp[i-1th item][sum = j  value of the ith item] is true\n- dp[i-1th item][sum = j] is true\n```\n","lastmodified":"2024-07-04T20:24:17.033181857Z","tags":["dsadeck","dp"]},"/dsa/42-Trapping-Rain-Water":{"title":"42 Trapping Rain Water","content":"\n## Problem Statement\n\n\nPattern: \n\n---\n\n## Solution\n``` java\npublic int[] getWaterHeight (int[] arr, int n) {\n\tint end = 0, start = 0;\n\tint[] waterHeight = new int[n];\n\t\n\twhile(end \u003c n-1) {\n\t\tend++;\n\t\t// if taller block found\n\t\tif(arr[end] \u003e= arr[start]){\n\t\t\t// store start height\n\t\t\tint wh = arr[start];\n\t\t\t// rewrite waterHeight[start] upto end with wh\n\t\t\twhile (start \u003c end)\twaterHeight[start++] = wh;\n\t\t}\n\t}\n\tSystem.out.printf(\"Water Height: \" + Arrays.toString(waterHeight));\n\t// ptr to traverse backwards\n\tint mid = end;\n\twhile (mid \u003e start) {\n\t\tmid--;\n\t\t// if mid-block is greater\n\t\tif (arr[mid] \u003e arr[end]) {\n\t\t\t// store end height\n\t\t\tint wh = arr[end];\n\t\t\t// rewrite waterHeight[end] upto mid with wh\n\t\t\twhile (end \u003e mid) waterHeight[end--] = wh;\n\t\t}\n\t}\n\tSystem.out.printf(\"Water Height: \" + Arrays.toString(waterHeight));\n\treturn waterHeight;\n}\n\npublic int trap (int[] arr){\n\tint n = arr.length;\n\tint [] waterHeight = getWaterHeight(arr, n);\n\tint volume = 0;\n\tfor (int i = 0; i \u003c n; i++) {\n\t\tlong water = waterHeight[i] - arr[i];\n\t\tif(water \u003e 0) volume += water;\n\t}\n\treturn volume;\n}\n```\n\n### Notes\n- Optimised Solution Can Solve the problem with 2 pointers at the start and end of the array\n\n\n### Optimise Solution\nBy gaurav\n``` cpp\nlong long trappingWater(int arr[], int n) {\n    int minHeight = 0, i = 0, j = n - 1;\n    long long ans = 0;\n    while (i \u003c j) {\n        minHeight = max(minHeight, min(arr[i], arr[j]));\n        if (arr[i] \u003c arr[j]) {\n            if (arr[i] \u003c minHeight) ans += (minHeight - arr[i]);\n            i++;\n        } else {\n            if (arr[j] \u003c minHeight) ans += (minHeight - arr[j]);\n            j--;\n\t}\t}\n    return ans;\n}\n```\n","lastmodified":"2024-07-04T20:24:17.033181857Z","tags":["dsadeck","arrays","tboptimised"]},"/dsa/435.-Non-Overlapping-Intervals":{"title":"435. Non-Overlapping Intervals","content":"\n## Problem Statement\n\n\nPattern: \n\n---\n\n## Solution\n``` java\npublic int eraseOverlapIntervals(int[][] intervals) {\n\tArrays.sort(intervals, Comparator.comparingInt(a -\u003e a[1]));\n\tint prevEnd = Integer.MIN_VALUE, count = 0;\n\tfor (int[] curr : intervals) {\n\t\tif(prevEnd \u003e curr[0]){      //curr is overlapping\n\t\t\tcount++;\n\t\t} else prevEnd = curr[1];   // curr is non-overlapping\n\t}\n\treturn count;\n}\n```\n\n### Notes\nbascically the inverse of [[452. Minimum Number of Arrows to Burst Balloons]]\n`prevEnd` denotes the end of the last **non-overlapping** interval. if any interval overlaps with this interval remove it (increase count), until you find the next **non-overlappping element**\n\n\n","lastmodified":"2024-07-04T20:24:17.033181857Z","tags":["dsadeck","arrays"]},"/dsa/437.-Path-Sum-III":{"title":"437. Path Sum III","content":"\n## Problem Statement\n\n\nPattern: \n\n---\n\n## Solution\n``` java\npublic int pre(TreeNode root, int target, HashMap\u003cInteger, Integer\u003e map, int currSum) {\n\tif(root == null) return 0;\n\t\n\tcurrSum += root.val;                                // update currSum\n\tint count = map.getOrDefault(currSum-target, 0);    // update count of currSum-target\n\t\n\tmap.put(currSum, map.getOrDefault(currSum, 0) + 1); // increment count of currSum\n\tcount +=                                            // get counts from left, right subtree\n\t\tpre(root.left, target, map, currSum) + \n\t\tpre(root.right, target, map, currSum);\n\n\tmap.put(currSum, map.get(currSum) - 1);             // decrement count of currSum\n\treturn count;                                       // return count of currSum-target\n}\n\npublic int pathSum(TreeNode root, int targetSum) {\n\tHashMap\u003cInteger, Integer\u003e map = new HashMap\u003c\u003e();\n\tmap.put(0, 1); // root condition\n\treturn pre(root, targetSum, map, 0);   \n}\n```\n\n### Notes\n- bascially every path you travel, create a prefix sum array, and count the number of times `currSum-target` has ocurred in the array\n- to maintain the array, for every path, increment the count of `currSum` when traversing a node, and decrement it when returning from the node\n\n","lastmodified":"2024-07-04T20:24:17.033181857Z","tags":["dsadeck","binarytrees"]},"/dsa/44.-Wildcard-Matching":{"title":"44. Wildcard Matching","content":"\n## Problem Statement\n[Wildcard Matching - LeetCode](https://leetcode.com/problems/wildcard-matching/)\n\nPattern: \n\n---\n\n## Solution\n\n``` java\nBoolean cache[][];\n\npublic boolean dp (char[] s, char[] p, int i, int j) {\n\tif(i == s.length \u0026\u0026 j == p.length) return true;\n\tif(j == p.length) return i == s.length;\n\t \n\tif(i \u003c s.length \u0026\u0026 cache[i][j] != null)\n\t\treturn cache[i][j];\n\t\n\tif(i \u003c s.length \u0026\u0026 (s[i] == p[j] || p[j] == '?')) \n\t\treturn cache[i][j] = dp(s, p, i+1, j+1);\n\t\n\tif(p[j] == '*') return cache[i][j] = \n\t\ti \u003c s.length ? (\n\t\t\tdp(s, p, i+1, j+1) ||   // advance both   OR\n\t\t\tdp(s, p, i+1, j) ||     // advance string OR\n\t\t\tdp(s, p, i, j+1)        // advance pattern\n\t\t\t) : dp(s, p, i, j+1);   // advance pattern only       \n\t\n\treturn cache[i][j] = false;\n}\n\npublic boolean isMatch(String s, String p) {\n\tif(s.length() == 0 \u0026\u0026 p.length() == 0) return true;\n\tif (s.length()==0) {\n\t\tfor (char ch : p.toCharArray()) if(ch!='*') return false;\n\t\treturn true;\n\t}\n\tcache = new Boolean[s.length()+1][p.length()+1];\n\treturn dp(s.toCharArray(), p.toCharArray(), 0, 0);\n}\n```\nTC : $O(n*m)$\nSC : $O(n*m)$\n\n\n### Notes\n- Match both strings from start to finish\n\t- `if s[i]==p[j]`  or `p[j == '?'`  then increment both\n\t- else if `p[j] == '*'`\n\t\t- then there can be 3 cases\n\t\t\t- match `*` with `s[i]` and increment both\n\t\t\t- include `s[i]` in `*` string and increment `s[i]`\n\t\t\t- take `*` as empty string and increment only `p[j]`\n\t\t- but if `i == s.length` we can only increment the pattern `p[j]`\n\t\t\t- this will be the case if the asterisk is in the end `s = abac` `p = abac*****`\n\n\n","lastmodified":"2024-07-04T20:24:17.033181857Z","tags":["dsadeck","strings"]},"/dsa/442.-Find-All-Duplicates-in-an-Array":{"title":"442. Find All Duplicates in an Array","content":"\n## Problem Statement\n[Find All Duplicates in an Array - LeetCode](https://leetcode.com/problems/find-all-duplicates-in-an-array/)\nGiven an integer arrayÂ `nums`Â of lengthÂ `n`Â where all the integers ofÂ `nums`Â are in the rangeÂ `[1, n]`Â and each integer appearsÂ **once**Â orÂ **twice**, returnÂ _an array of all the integers that appearsÂ **twice**_.\n\nYou must write an algorithm that runs inÂ `O(n)`Â time and uses only constant extra space.\n\nPattern: [[Pattern 1-n range array]]\n\n---\n\n## Solution\n``` java\nclass Solution {  \n     \n   public void swap(int[] x, int a, int b) {  \n      int t = x[a];  \n      x[a] = x[b];  \n      x[b] = t;  \n   }  \n     \n   public List\u003cInteger\u003e findDuplicates(int[] nums) {  \n      // code here  \n      int n = nums.length;  \n      List\u003cInteger\u003e ans = new ArrayList\u003c\u003e();  \n      //cycle sort  \n      for (int i = 0; i \u003c n; i++)  \n         while (nums[i] != i + 1) {  \n            int swapLoc = nums[i] - 1;  \n            // if no. at swap location is same  \n            if (nums[i] == nums[swapLoc])  \n               break;  \n            // else swap with correct loc  \n            swap(nums, i, swapLoc);  \n         }  \n        \n      // iterate over sorted array  \n      for (int i = 0; i \u003c n; i++) {  \n         if(nums[i]!= i+1) ans.add(nums[i]);  \n      }  \n      return ans;  \n   }  \n}\n```\n\n### Notes\nApply cyclic sort/self freq approach\nCyclic Sort: Sort array, skip dupplicates, iterate over array\nall out of place elements are duplicates\n\nSelf Freq Approach: you know how. [Python O(n) time O(1) space - LeetCode Discuss](https://leetcode.com/problems/find-all-duplicates-in-an-array/discuss/92390/Python-O(n)-time-O(1)-space)\n\n\n","lastmodified":"2024-07-04T20:24:17.033181857Z","tags":["easy","arrays","completed","dsadeck"]},"/dsa/448.-Find-All-Numbers-Disappeared-in-an-Array":{"title":"448. Find All Numbers Disappeared in an Array","content":"\n## Problem Statement\n\n\nRelated : [[Pattern 1-n range array]] [[41. First Missing Positive]]\n\n\n\n---\n\n## Solution\n``` java\n// self-freq array approach\npublic List\u003cInteger\u003e findDisappearedNumbers (int[] nums){\n\t// code here\n\tList\u003cInteger\u003e missing = new ArrayList\u003c\u003e();\n\n\t// mark indices of array values as negative\n\tfor (int num : nums){\n\t\tint absNum = Math.abs(num);\n\t\tif(nums[(absNum-1)] \u003e 0)  nums[absNum-1] *= -1;\n\t}\n\t\n\t// therefore missing values are positive\n\tfor (int i = 0; i \u003c nums.length; i++) {\n\t\tif(nums[i] \u003e 0) missing.add(i+1);\n\t}\n\t\n\treturn missing;\n}\n```\n\n### Notes\n- This can also be done with the [[Cycle Sort]] method\n","lastmodified":"2024-07-04T20:24:17.033181857Z","tags":["easy","arrays","completed","dsadeck"]},"/dsa/452.-Minimum-Number-of-Arrows-to-Burst-Balloons":{"title":"452. Minimum Number of Arrows to Burst Balloons","content":"\n## Problem Statement\n\n\nPattern: [[Pattern Activity Selection Problem]]\nRelated: [[435. Non-Overlapping Intervals]]\n\n---\n\n## Solution\n``` java\n    public int findMinArrowShots (int[][] points){\n        Arrays.sort(points, Comparator.comparingInt(a -\u003e a[1]));\n        long prevEnd = Long.MIN_VALUE;\n        int count = 0;\n        for (int[] curr : points) {\n            if(prevEnd \u003c curr[0]){  // curr is overlapping\n                count++;\n                prevEnd = curr[1];\n            }\n        }\n        return count;\n    }\n```\n\n### Notes\n- sort intervals by their `end`s\n- every time you come across a non-overlapping element increment `count`\n\n\n","lastmodified":"2024-07-04T20:24:17.033181857Z","tags":["dsadeck","intervals","greedy"]},"/dsa/46.-Permutations":{"title":"46. Permutations","content":"\n## Problem Statement\n\n\nPattern: \n\n---\n\n## Solution\n``` cpp\nvector\u003cvector\u003cint\u003e\u003e ans;\nvoid solve(vector\u003cint\u003e \u0026nums, int t) {\n    if (t == nums.size()-1) {\n        ans.push_back(nums);\n        return;\n    }\n\n    for(int i = t; i \u003c nums.size() ; i++) {\n        swap(nums[t], nums[i]);\n        solve(nums, t+1);\n        swap(nums[t], nums[i]);\n    }\n}\n\n\nvector\u003cvector\u003cint\u003e\u003e permute(vector\u003cint\u003e\u0026 nums) {\n    ans.clear();\n    solve(nums, 0);\n    return ans;\n}\n```\nTC : n!\nSC : n!\n\n### Notes\n- \n\n\n\n","lastmodified":"2024-07-04T20:24:17.033181857Z","tags":["dsadeck","arrays"]},"/dsa/494.-Target-Sum":{"title":"494. Target Sum","content":"\n## Problem Statement\n\nPattern: [[Pattern DP Subset Partitioning ]]\n\n---\n\n## Solution\n``` java\nHashMap\u003cInteger, Integer\u003e[] cache;  \nint find(int[] nums, int target, int n, int currSum) {  \n   if (n \u003c 0 \u0026\u0026 currSum == target) return 1;  \n   if (n \u003c 0) return 0;  \n   \n   // check entry in cache  \n   HashMap\u003cInteger, Integer\u003e entry = cache[n];  \n   if(entry != null \u0026\u0026 entry.containsKey(currSum)) \n\t   return entry.get(currSum);\n     \n   int pos = find(nums, target, n - 1, currSum + nums[n]);  \n   int neg = find(nums, target, n - 1, currSum - nums[n]);  \n   \n   // update entry in cache  \n   if(entry == null) entry = new HashMap\u003c\u003e();  \n   entry.put(currSum, pos+neg); cache[n] = entry;  \n\n   return pos + neg;  \n}  \n  \npublic int findTargetSumWays(int[] nums, int target) {  \n   cache = new HashMap[nums.length];  \n   return find(nums, target, nums.length - 1, 0);  \n}\n```\nTC : ` O(ns) `\nSC : ` O(ns) `\n\n## Brute Force :\n``` java\nint find(int[] nums, int target, int n, int currSum) {  \n   if (n \u003c 0 \u0026\u0026 currSum == target) return 1;  \n   if (n \u003c 0) return 0;  \n   \n   int pos = find(nums, target, n - 1, currSum + nums[n]);  \n   int neg = find(nums, target, n - 1, currSum - nums[n]);  \n   \n   return pos + neg;  \n}  \n  \npublic int findTargetSumWays(int[] nums, int target) {  \n   return find(nums, target, nums.length - 1, 0);  \n}\n```\n\nTC : ` O(2^n) `\n\n","lastmodified":"2024-07-04T20:24:17.033181857Z","tags":["dsadeck","dp"]},"/dsa/50.-Powx-n":{"title":"50. Pow(x, n)","content":"\n## Problem Statement\n\n\nPattern: \n\n---\n\n## Solution\n``` java\n\nstatic class Solution {\n\tpublic static double simplePow(double x, int n) {\n\t\tif (n == 0) return 1;\n\t\tif (n \u003c 0) return (1 / x) * (simplePow(1 / x, -(n + 1)));\n\t\t\n\t\tdouble result = simplePow(x, n - 1);\n\t\treturn result * x;\n\t}\n\t\n\tpublic static double myPow(double x, int n) {\n\t\t// exit condition\n\t\tif (n == 0) return 1;\n\t\tif (n \u003c 0) return 1 / x * myPow(1 / x, -(n + 1)); // n=int.minVal -\u003e overflow avoided\n\t\tdouble result = myPow(x, n / 2);\n\t\tresult *= result;\n\t\tif ((n \u0026 1) != 0) result *= x;  // compensate for odd power\n\t\tSystem.out.println(result);\n\t\treturn result;\n\t}\n\t\n\tpublic static double myPowIterative(double x, int n) {\n\t\tdouble result = 1;\n\t\t\n\t\tif (n \u003c 0) {\n\t\t\tn = -(n + 1);   // sign flipped and integer overflow avoided\n\t\t\tx = 1 / x;      \n\t\t\tresult *= x;    // compensate for n-1\n\t\t}\n\t\t\n\t\twhile (n \u003e 0) {\n\t\t\t// if n is odd for a given x, multiply result by x\n\t\t\tif (n % 2 == 1) result *= x;\n\t\t\t// otherwise continue to square x\n\t\t\tx *= x;\n\t\t\tn /= 2;\n\t\t}\n\t\t// result always updated in the end cuz final n == 1\n\t\treturn result;\n\t}\n\t\n\t\n}\n\n// region MAIN\npublic static void main(String[] args) {\n\t// int[] arr = {};\n\tdouble x = 2;\n\tint n = 0;\n\tdouble ans = Solution.simplePow(x, n);\n\tSystem.out.println(ans);\n\tSystem.out.println(\"\\nFAST ANSWER\\n\");\n\tdouble fastAns = Solution.myPow(x, n);\n\tSystem.out.println(fastAns);\n\tSystem.out.println(\"\\nFASTER ANSWER\\n\");\n\tdouble fasterAns = Solution.myPowIterative(x, n);\n\tSystem.out.println(fasterAns);\n}\n\n```\n\n### Notes\n- Quck Explanation :[Binary Exponentiation - YouTube](https://www.youtube.com/watch?v=L-Wzglnm4dM)\n- for `n\u003c0` if n = Integer.MIN_VALUE, then n = -n will cause an overflow, since `MAX_VALUE - MIN_VALUE = -1`\n- \n\n","lastmodified":"2024-07-04T20:24:17.033181857Z","tags":["easy","arithmetic","completed","ChabraQuestion"]},"/dsa/523.-Continuous-Subarray-Sum":{"title":"523. Continuous Subarray Sum","content":"\n## Problem Statement\n\n\nPattern: [[Pattern Prefix Array]]\n\n---\n\n## Solution\n``` java\npublic static boolean checkSubArraySum(int[] nums, int k) {\n\tif (k == 0) return true;\n\n\tMap\u003cInteger, Integer\u003e map = new HashMap\u003c\u003e();\n\tint currSumMod = 0, index = -1;\n\tmap.put(currSumMod,index++);\n\t\n\tfor (; index \u003c nums.length; index++) {\n\t\t// currSumMod is mod of sum so far\n\t\tcurrSumMod = (currSumMod + nums [index]) % k;\n\t\t// get prevIndex of currSumMod\n\t\tInteger prevIndex = map.get(currSumMod);\n\t\t// if prevIndex exists\n\t\tif (prevIndex != null) {\n\t\t\t// and index - prevIndex \u003e 1\n\t\t\tif (index - prevIndex \u003e 1) return true;\n\t\t}\n\t\t// else insert index for currSumMod\n\t\telse map.put(currSumMod, index);\n\t}\n\treturn false;\n}\n```\n\n### Notes\n- We simply store the `Mod k` of the current sum, in currSumMod\n- If currSumMod gets repeated, then we know that the numbers in between the `prevIndex` and current `index` must add upto some multiple of `k`\n\t- For e.g. in case of the array` [23,2,6,4,7]` and `k=6` the running sum is `[23,25,31,35,42]` and the remainders are `[5,1,1,5,0]`. We got remainder 5 at index 0 and at index 3. That means, in between these two indexes we must have added a number which is multiple of the k.\n- Edge case: we initialise map with `currSumMod = 0`  and `index = -1` since sum starts with 0, and we store it before the start of the array so `index-prevIndex \u003e 1` works\n\t- say at  `index = 1` currSumMod  is 0.` nums[0] + nums[1]  == n . k`  (some multimple of k). \n\t- in that case it will look for `0` in the map, and  `if (index - prevIndex \u003e 1)` will `return true` like it should!\n\n","lastmodified":"2024-07-04T20:24:17.033181857Z","tags":["dsadeck","arrays","completed"]},"/dsa/53.-Maximum-Subarray":{"title":"53. Maximum Subarray","content":"\n## Problem Statement\n[Maximum Subarray - LeetCode](https://leetcode.com/problems/maximum-subarray/submissions/)\n\nPattern: [[Pattern Kadane's Algorithm]]\n\n---\n\n## Solution\n``` java\npublic static int maxSubArray (int[] nums){\n\tint max  = Integer.MIN_VALUE, currMax = Integer.MIN_VALUE;\n\tfor (int num : nums) {\n\t\tif (currMax \u003c= 0) currMax = num;\n\t\telse currMax += num;\n\t\tmax = Math.max(max, currMax);\n\t}\n\treturn max;\n}\n```\n\n### Notes\n- \n\n","lastmodified":"2024-07-04T20:24:17.033181857Z","tags":["easy","arrays","completed","subarrays","dsadeck"]},"/dsa/55.-Jump-Game":{"title":"55. Jump Game","content":"\n## Problem Statement\n![](https://i.imgur.com/dAyiQcA.png)\n\n\nPattern: \n\n---\n\n## Solution\n``` java\npublic boolean canJump(int[] nums) {\n\tif(nums.length \u003c= 1) return true;\n\tint limit = nums[0];\n\tfor (int index = 0; index \u003c= limit; index++) {\n\t\tif (index == nums.length - 1) return true;\n\t\tlimit = Math.max(limit, index+nums[index]);\n\t}\n\treturn false;\n}\n```\n\n### Notes\n- \n\n","lastmodified":"2024-07-04T20:24:17.033181857Z","tags":["dsadeck","arrays"]},"/dsa/56.-Merge-Intervals":{"title":"56. Merge Intervals","content":"\n## Problem Statement\n![](https://i.imgur.com/CxmFyIO.png)\n\n\nPattern: \nRelated: [[435. Non-Overlapping Intervals]], [252 Meeting Rooms](https://leetcode.com/problems/meeting-rooms/)  [253 Meeting Rooms II](https://leetcode.com/problems/meeting-rooms-ii/)\n\n---\n\n## Solution\n``` java\npublic int[][] merge (int[][] intervals){\n\t// Sort by interval start\n\tArrays.sort(intervals, Comparator.comparingInt(a -\u003e a[0]));\n\n\tArrayList\u003cint[]\u003e res = new ArrayList\u003c\u003e();\n\tint[] currInterval = intervals[0];\n\tfor(int[] newInterval: intervals) {\n\t\tif(newInterval[0] \u003c= currInterval[1])\n\t\t\t// extend the end of the currInterval\n\t\t\tcurrInterval[1] = Math.max(currInterval[1], newInterval[1]);\n\t\telse {\n\t\t\tres.add(currInterval);\n\t\t\t// set newInterval as the currInterval\n\t\t\tcurrInterval = newInterval;\n\t\t}\n\t}\n\tres.add(currInterval);   // add the final currInterval\n\treturn res.toArray(new int[0][]);\n}\n```\n\n### Notes\n- iterate through all intervals \n\t- keep the `currInterval` to compare with the `newInterval`\n\t- if they overlap, extend the `currInterval` (update the end of `currInterval` to `max(currInterval[1], newInterval[]))`\n\t- once `currInterval` stops overlapping with `newInterval`, we add the now (extended ) `currentInterval` to `res` arraylist\n- finally the last `newInterval` which is either extended in the `if` condition to the `currInterval` or is unique so gets set to `currInterval` in the else block. either ways the final `newInterval` ends up in `currInterval` so we add `currInterval` to result\n\n \n","lastmodified":"2024-07-04T20:24:17.033181857Z","tags":["dsadeck","arrays","intervals"]},"/dsa/560.-Subarray-Sum-Equals-K":{"title":"560. Subarray Sum Equals K","content":"\n## Problem Statement\n\n\nPattern: [[Pattern Prefix Array]]\n\n---\n\n## Solution\n``` java\npublic static int subArraySum(int[] nums, int k) {\n\tInteger count = 0, currSum = 0;\n\tMap\u003cInteger, Integer\u003e map = new HashMap\u003c\u003e();\n\t\n\t// edge case\n\tmap.put(currSum, 1);\n\t\n\tfor (int index = 0; index \u003c nums.length; index++) {\n\t\t// update currSum at index\n\t\tcurrSum += nums[index];\n\t\t// get freq of currSum-k\n\t\tInteger freq = map.get(currSum - k);\n\t\t// if freq found update count\n\t\tif (freq != null) count += freq;\n\t\t// increment currSum freq\n\t\tmap.put(currSum, map.getOrDefault(currSum, 0) + 1);\n\t}\n\treturn count;\n}\n```\n\n### Notes\n- In kadanes algo we know that \n\t- for a max sum problem\n\t\t- a negative `currSum` would never contribute to the a global `max` value\n\t- for a min sum problem\n\t\t- a positive `currSum` would never contribte to a global `min` value\n\t- so we reset `currSum` to the next element, and keep updating `max` and `min`\n\n- Concept :  update freq of `currSum` for each element in a hashmap\n\t- At any given index if `map.get(currSum-k)` let's say is `2` that means, 2 subarrays with the sum `k` exist!!! only then would a `sum = currSum-k` would exist!\n\t- update the `count` with `2`\n\t- so on...\n- edge case, if `currSum == k` then `map.get(0)` should return 1.\n \n","lastmodified":"2024-07-04T20:24:17.033181857Z","tags":["dsadeck","subarrays","completed","hashmap"]},"/dsa/566.-Reshape-the-Matrix":{"title":"566. Reshape the Matrix","content":"\n## Problem Statement\n\n\nPattern: \n\n---\n\n## Solution\n``` java\npublic int[][] matrixReshape(int[][] mat, int r, int c) {\n\tint n = mat.length, m = mat[0].length;\n\tint[][] result = new int[r][c];\n\t// if invalid array return original\n\tif (r * c != n * m) return mat;\n\t\n\tfor (int i = 0; i \u003c r*c; i++)\n\t\tresult[i/c][i%c] = mat[i/m][i%m];\n\treturn result;\n}\n```\n\n### Notes\n- total no. of elements is `r*c`\n\t- row and column are given by dividing and mod by no. of columns\n\n\n","lastmodified":"2024-07-04T20:24:17.033181857Z","tags":["dsadeck","arrays"]},"/dsa/6095.-Strong-Password-Checker-II":{"title":"6095. Strong Password Checker II","content":"\n## Problem Statement\n\n![](https://i.imgur.com/p0fMluK.png)\n\n\nPattern: \n\n---\n\n## Solution\n``` java\npublic boolean strongPasswordCheckerII (String password){\n\tboolean charLen = false, lowerCase = false, upperCase = false, digit = false,\n\t\tspecialChar = false, adjacentChars = false;\n\t\n\tString specialChars = \"!@#$%^\u0026*()-+\";\n\tchar[] chars = password.toCharArray();\n\t\n\tint index = 0;\n\tif (chars.length \u003e= 8) charLen = true;\n\tfor(char ch : chars) {\n\t\tif (ch \u003e= 'a' \u0026\u0026 ch \u003c= 'z') lowerCase = true;\n\t\tif (ch \u003e= 'A' \u0026\u0026 ch \u003c= 'Z') upperCase = true;\n\t\tif (ch \u003e= '0' \u0026\u0026 ch \u003c= '9') digit = true;\n\t\tif (specialChars.indexOf(ch) != -1) specialChar = true;\n\t\tif (index \u003e 0 \u0026\u0026 chars[index-1] == ch) adjacentChars = true;\n\t\tindex++;\n\t}\n\t\n\treturn charLen \u0026\u0026 lowerCase \u0026\u0026 upperCase \u0026\u0026 digit \u0026\u0026 specialChar \u0026\u0026 !adjacentChars;\n}\n```\n\n### Notes\n- \n\n","lastmodified":"2024-07-04T20:24:17.033181857Z","tags":["dsadeck","strings"]},"/dsa/6096.-Successful-Pairs-of-Spells-and-Potions":{"title":"6096. Successful Pairs of Spells and Potions","content":"\n## Problem Statement\n![](https://i.imgur.com/lGijW6K.png)\n\n\nPattern: [[Binary Search#Floor Ceil]]\n\n---\n\n## Solution\n``` java\nstatic class Solution {\n\tprivate int findCeil(int[] arr, long key) {\n\t\tint n = arr.length, start = 0, end = n - 1, mid = 0;\n\t\t// converge start\n\t\twhile (start \u003c= end) {\n\t\t\tmid = start + (end - start) / 2;\n\t\t\tif (key \u003c= arr[mid]) end = mid - 1;\n\t\t\telse start = mid + 1;\n\t\t}\n\t\t// element not found\n\t\tif (start == n) return 0;   // if all elements smaller than key, start OOB\n\t\treturn n - start;             // return no. of elements larger than key\n\t}\n\t\n\tpublic int[] successfulPairs(int[] spells, int[] potions, long success) {\n\t\tint[] res = new int[spells.length];\n\t\tArrays.sort(potions);\n\t\tfor (int i = 0 ; i \u003c spells.length ; i++) {\n\t\t\tlong key = (success + spells[i] - 1) / spells[i];   // ceil of division\n\t\t\tres[i] = findCeil(potions, key);\n\t\t}\n\t\treturn res;\n\t}\n}\n```\n\n### Notes\n- Element in Potions array will be smaller than `success/spell` \n\t- Now all you have to do is find the [[Binary Search#Floor Ceil|Ceil]] of that number\n\t- Sinc we are adding `success` and `spells` we need key to be of `long` since both can be `10^5` at max\n\n\n","lastmodified":"2024-07-04T20:24:17.033181857Z","tags":["dsadeck","arrays","binarysearch"]},"/dsa/61.-Rotate-List":{"title":"61. Rotate List","content":"\n## Problem Statement\n\n\nPattern: \n\n---\n\n## Solution\n``` java\npublic ListNode rotateRight (ListNode head, int k){\n\t// edge case\n\tif(head == null || head.next == null) return head;\n\t\n\t// get last pointer and length of LL\n\tint len = 1;\n\tListNode last = head;\n\twhile(last.next != null) {\n\t\tlast = last.next;\n\t\tlen ++;\n\t}\n\tlast.next = head;   // point last to head\n \n\t// fix k\n\tk = k%len;    // set k within bounds\n\tk = len - k;  // to rotate clockwise\n \n\t// break LL and return newHead\n\twhile (--k \u003e 0) head = head.next;   // shift head to b4 breakpoint\n\tListNode newHead = head.next;       // set newHead\n\thead.next = null;                   // break LL\n\treturn  newHead;                    // return newHead\n}\n```\n\n### Notes\n- [Simple Java Solution - LeetCode Discuss](https://leetcode.com/problems/rotate-list/discuss/2193575/Simple-Java-Solution)\n\nSteps\n1.  Make LL Circular\n2.  Break at k\n3.  return k.next as new head\n\nPotential Issues:\n-   K could be much larger than LL Length\n-   Direction of Rotation needs to be taken into account\n\n","lastmodified":"2024-07-04T20:24:17.033181857Z","tags":["dsadeck","linkedlist"]},"/dsa/6121.-Query-Kth-Smallest-Trimmed-Number":{"title":"6121. Query Kth Smallest Trimmed Number","content":"\n### 6121.Â Query Kth Smallest Trimmed Number\n\n[My Submissions](https://leetcode.com/contest/weekly-contest-302/problems/query-kth-smallest-trimmed-number/submissions/)[Back to Contest](https://leetcode.com/contest/weekly-contest-302/)\n\n","lastmodified":"2024-07-04T20:24:17.033181857Z","tags":[]},"/dsa/6122.-Minimum-Deletions-to-Make-Array-Divisible":{"title":"6122. Minimum Deletions to Make Array Divisible","content":"\n### 6122.Â Minimum Deletions to Make Array Divisible\n\n[My Submissions](https://leetcode.com/contest/weekly-contest-302/problems/minimum-deletions-to-make-array-divisible/submissions/)[Back to Contest](https://leetcode.com/contest/weekly-contest-302/)\n","lastmodified":"2024-07-04T20:24:17.033181857Z","tags":[]},"/dsa/632.-Smallest-Range-Covering-Elements-from-K-Lists":{"title":"632. Smallest Range Covering Elements from K Lists","content":"\n## Problem Statement\n\n\nPattern: \nRelated : [[Smallest Distinct Window]]\n\n---\n\n## Solution\n``` java\nclass Node {\n\tList\u003cInteger\u003e list;\n\tint index;\n\t\n\tpublic boolean hasNext () {return (list.size() \u003e index+1);}\n\t\n\tpublic int get() {\n\t\treturn list.get(index);\n\t}\n\t\n\tNode(List\u003cInteger\u003e list) {\n\t\tthis.list = list;\n\t\tthis.index = 0;\n\t}\n}\n\npublic int[] smallestRange(List\u003cList\u003cInteger\u003e\u003e nums) {\n\t// create pq of Node\n\tPriorityQueue\u003cNode\u003e pq = new PriorityQueue\u003c\u003e(\n\t\tComparator.comparingInt(Node::get)\n\t);\n\t\n\t// add node heads to pq\n\tfor (List\u003cInteger\u003e list : nums) {\n\t\tNode node = new Node(list);\n\t\tpq.add(node);\n\t\tSystem.out.println(node.list.get(node.index));\n\t}\n\t\n\tint currMax = 0, currMin, max = Integer.MAX_VALUE, min = 0;\n\n\t// get currMax by emptying temp PQ\n\tPriorityQueue\u003cNode\u003e temp = new PriorityQueue\u003c\u003e(pq);\n\twhile (!temp.isEmpty()) {\n\t\tNode node = temp.poll();\n\t\tcurrMax = node.get();\n\t}\n\t\n\t// while pq not empty -\u003e minimise range\n\twhile (!pq.isEmpty()) {\n\t\t// update currMin from node\n\t\tNode node = pq.poll();\n\t\tcurrMin = node.get();\n\t\t\n\t\t// check if currRange \u003c Range\n\t\tif ((currMax - currMin) \u003c (max - min)) {\n\t\t\t// update range\n\t\t\tmax = currMax;\n\t\t\tmin = currMin;\n\t\t}\n\t\t\n\t\t// if next el exists in node\n\t\tif (node.hasNext()) {\n\t\t\t// reinsert incremented node into pq\n\t\t\tnode.index++;\n\t\t\tpq.add(node);\n\t\t\t\n\t\t\t// update currMax, if newElement \u003e currMax\n\t\t\tcurrMax = Math.max(currMax, node.get());\n\t\t}\n\t\t// pointer cannot be incremented, and shortest ranges have been exhausted!\n\t\telse break;\n\t}\n\treturn new int[]{min, max};\n}\n\n```\n\n### Notes\n- This question is [[23. Merge k Sorted Lists]] with a twist\n\u003e [!CONCEPT]\n\u003e Heads of K Lists in a priority queue. Then track `min` and `max`, till the priority queue is empty, minimise `currMax - currMin`\n\u003e \n\n- In that question, we funnel k sorted linked lists through a minheap, and empty that minheap into a sorted array\n\t- The algorithm started by adding a pointer to the start of each of the K sortedarrays in a priority queue. And extract the smallest one while incrementing its pointer/index\n\t- Same here, Except\n\t\t- We keep track of the largest and smallest elements inside the minheap which gives us our range `range = currMax - currMin`\n\t\t-  Our goal is to minimise this `range`, find the combination of `currMin` and `currMax` which gives us the answer\n\t\t- So we update `min` and `max` when we find a smaller range\n","lastmodified":"2024-07-04T20:24:17.033181857Z","tags":["dsadeck","linkedlist","heap"]},"/dsa/645.-Set-Mismatch":{"title":"645. Set Mismatch","content":"\n## Problem Statement\n\n\nPattern: [[Pattern 1-n range array]]\n\n---\n\n## Solution\n``` java\nclass Solution {\n\t// self-freq-arr approach\n\tpublic int[] findErrorNums(int[] nums) {\n\t\t// mark value index -ve subsequently finding duplicate\n\t\tint duplicateNum = -1, missingNum = 0;\n\t\tfor (int num : nums) {\n\t\t\tint val = Math.abs(num);\n\t\t\tif (nums[val - 1] \u003c 0) {\n\t\t\t\t// -ve -\u003e duplicate number\n\t\t\t\tduplicateNum = val;\n\t\t\t} else {\n\t\t\t\t// num -\u003e -ve\n\t\t\t\tnums[val - 1] *= -1;\n\t\t\t}\n\t\t}\n\t\t\n\t\t// missing number's index has not been marked -ve\n\t\tfor (int i = 0; i \u003c nums.length; i++) {\n\t\t\tif (nums[i] \u003e 0) missingNum = i + 1;\n\t\t}\n\t\t\n\t\treturn new int[]{duplicateNum, missingNum};\n\t}\n\t\n\t// swap\n\tpublic void swap(int[] x, int a, int b) {\n\t\tint t = x[a];\n\t\tx[a] = x[b];\n\t\tx[b] = t;\n\t}\n\t\n\t// cycle sort approach\n\tpublic int[] findErrorNums2(int[] nums) {\n\t\tint missing = -1, repeated = -1;\n\t\t\n\t\tfor (int i = 0; i \u003c nums.length; i++)\n\t\t\twhile (\n\t\t\t\tnums[i] != i + 1 \u0026\u0026         // el is correct\n\t\t\t\t\tnums[i] != nums[nums[i] - 1]  // el is not same as swap el\n\t\t\t) {\n\t\t\t\tswap(nums, i, nums[i] - 1);\n\t\t\t}\n\t\tfor (int i = 0; i \u003c nums.length; i++) {\n\t\t\tif (nums[i] != i + 1) {\n\t\t\t\tmissing = i + 1;\n\t\t\t\trepeated = nums[i];\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn new int[]{repeated, missing};\n\t}\n}\n```\n\n### Notes\n- Both approaches are easy and return the ans\n\n","lastmodified":"2024-07-04T20:24:17.033181857Z","tags":["easy","arrays","completed","dsadeck"]},"/dsa/652.-Find-Duplicate-Subtrees":{"title":"652. Find Duplicate Subtrees","content":"\n## Problem Statement\n\n\nPattern: \n\n---\n\n## O(n^2) Solution\n``` java\nList\u003cTreeNode\u003e res;\nHashMap\u003cString, Integer\u003e serialCount;\n\n// post order serialise\nString pos(TreeNode root){\n\tif(root == null) return \"#\";\n\t\n\t// serialise curr subtree\n\tString serial = root.val + \",\" + pos(root.left) + pos(root.right);\n\t\n\t// update serialCount and res\n\tint freq = serialCount.getOrDefault(serial, 0);\n\tserialCount.put(serial, ++freq);\n\tif (freq == 2) res.add(root);\n\t\n\treturn serial;\n}\n\npublic List\u003cTreeNode\u003e findDuplicateSubtrees (TreeNode root){\n\tres = new LinkedList\u003c\u003e();\n\tserialCount = new HashMap\u003c\u003e();\n\tpos(root);\n\treturn res;\n}\n```\n\n### Notes\n- For every node, serialise its subtree convert its `root, left, right` values into a string. and save this serials frequency in a hashmap. \n- since we only have to return a single instance of duplicate subtrees, check if `freq == 2`, and add to result\n- effectively postorder traverse and serialise\n\nNow, **Why O(N^2)**\n- at the bottom left most node/subtree , the size of the `serial` string is `1`\n- at the root the size of the `serial` string is \u003e `n` where n is number of nodes.\n- why does this matter?\n- because concatenation, and hashing operations complexity increases linearly with the size of the string\n- so at the root the concatenation has to concatenate a string of characters for all nodes = n, its child n-1, for its child n-2, so on and so forth\n- therefore O(n^2)\n\n## O(n) Solution\nif we could instead of appending all the values, could somehow 'cache' the `serial`, effectively assign the serial an `id`, so we didnt have to concatenate, and append these `serial` s over and over again, and we could simply identify , concatenate and hash a serial based off if its `id`\n\n``` java\nint uniqueSerials = 1;\nHashMap\u003cString, Integer\u003e serialID;\nHashMap\u003cInteger, Integer\u003e idCount;\nList\u003cTreeNode\u003e res;\n\nint getSerial(String serial) {\n\t// get serialID if exists\n\tif (serialID.containsKey(serial)) return serialID.get(serial);\n\t// else get unique serial\n\tserialID.put(serial, ++uniqueSerials);\n\treturn uniqueSerials;\n}\n\n// post order serialise\nint pos(TreeNode root) {\n\tif (root == null) return 0;\n\t\n\t// serialise curr subtree\n\tString serial = pos(root.left) + \",\" + root.val + \",\" + pos(root.right);\n\t\n\t// get an ID for serial\n\tint srID = getSerial(serial);\n\t\n\t// update idCount and res\n\tint freq = idCount.getOrDefault(srID, 0);\n\tidCount.put(srID, ++freq);\n\tif (freq == 2) res.add(root);\n\t\n\treturn srID;\n}\n\npublic List\u003cTreeNode\u003e findDuplicateSubtrees(TreeNode root) {\n\tserialID = new HashMap\u003c\u003e();\n\tidCount = new HashMap\u003c\u003e();\n\tres = new LinkedList\u003c\u003e();\n\tpos(root);\n\treturn res;\n}\n```\n\n\n- In the first approach, imagine that from left side you got a string like \"2,3,4,5\" etc while from right you got \"7,8,9,10\", then you will be concatenating 4 + 4 operations(excluding commas and if you include them its even more).\n\n- Whereas with ids, this is always bounded to an integer at most from left side you will get 10 chars(-2147483647 or 2147483647) and from right you will get again max 10 chars. So at most your String concatenation will be 10 chars + 10 chars.","lastmodified":"2024-07-04T20:24:17.033181857Z","tags":["dsadeck","binarytrees"]},"/dsa/66.-Plus-One":{"title":"66. Plus One","content":"\n## Problem Statement\n\n\nPattern: \n\n---\n\n## Solution\n``` java\npublic int[] plusOne(int[] digits) {\n\t\tint n = digits.length;\n\tfor(int i=n-1; i\u003e=0; i--) {\n\t\tif(digits[i] \u003c 9) {\n\t\t\tdigits[i]++;\n\t\t\treturn digits;\n\t\t}\n\n\t\tdigits[i] = 0;\n\t}\n\n\tint[] newNumber = new int [n+1];\n\tnewNumber[0] = 1;\n\n\treturn newNumber;\n}\n```\n\n### Notes\n- ","lastmodified":"2024-07-04T20:24:17.033181857Z","tags":["dsadeck","arrays"]},"/dsa/686.-Repeated-String-Match":{"title":"686. Repeated String Match","content":"\n## Problem Statement\n\n\nPattern: \n\n---\n\n## Solution\n``` java\npublic static int getIndex(String pattern, String text) {\n\tint n = pattern.length(), m = text.length(),\n\t\tbase = 128, prime = 8_388,\n\t\tnbase = 1, pHash = 0, tHash = 0;\n\tif(m \u003c n) return -1;\n\n\t// get nbase\n\tfor(int i = 0; i \u003c n-1 ; i++) nbase = (nbase * base) % prime;\n\n\t// get pattern \u0026 text hash\n\tfor (int i = n - 1; i \u003e= 0; i--) {\n\t\tpHash = (base * pHash + pattern.charAt(n-1-i)) % prime;\n\t\ttHash = (base * tHash + text.charAt(n-1-i)) % prime;\n\t}\n\n\t// roll hash\n\tif(tHash == pHash \u0026\u0026 text.substring(0, n).equals(pattern)) return 0;\n\tfor (int i = 1; i \u003c= m-n; i++) {\n\t\t// update text hash\n\t\tint pre = text.charAt(i-1), post = text.charAt(i+n-1);\n\t\ttHash = (base * (tHash - (pre * nbase)) + post) % prime ;\n\t\tif(tHash \u003c 0) tHash += prime; // Avoid Integer Overflow\n\t\t// compare hashes\n\t\tif(tHash == pHash \u0026\u0026 text.substring(i, i+n).equals(pattern)) return i;\n\t}\n\treturn -1;\n}\n\npublic int repeatedStringMatch(String a, String b) {\n\tint times = (b.length() + a.length() - 1) / a.length();\n\tStringBuilder sb = new StringBuilder();\n\tfor (int i = 0; i \u003c times; i++) sb.append(a);\n\n\n\tif(getIndex(b, sb.toString()) != -1) return times;\n\tif(getIndex(b, sb.append(a).toString()) != -1) return times +1;\n\treturn -1;\n}\n```\nTC : $Î¸(max(m, n))$\nSC : $Î¸(m)$\n\n### Notes\n- quite simple\n\n\n\n\n","lastmodified":"2024-07-04T20:24:17.033181857Z","tags":["dsadeck","strings"]},"/dsa/713.-Subarray-Product-Less-Than-K":{"title":"713. Subarray Product Less Than K","content":"\n## Problem Statement\n\n\nPattern: [[Pattern Sliding Window]]\n\n---\n\n## Solution\n``` java\npublic static int numSubarrayProductLessThanK(int[] nums, int k) {\n\t// edge case\n\tif (k == 0) return 0;\n\t// init\n\tint start = 0, end = 0, count = 0, currProd = 1;\n\t// sliding window\n\twhile (end \u003c nums.length) {\n\t\t// update currProd\n\t\tcurrProd *= nums[end];\n\t\t// currProd \u003e k : increment start and update currProd\n\t\twhile (currProd \u003e= k \u0026\u0026 start \u003c= end) currProd /= nums[start++];\n\t\t// update count (if start=end+1, count=0)\n\t\tcount += end - start + 1;\n\t\tend++;\n\t}\n\treturn count;\n}\n```\n\n## Notes\n- Create a sliding window incrementally, where prod of all the elements is less than k.\n\t- at each increment add size of sliding window to count of subarrays ... *WHY*?\n\t\t- number of subarrays for an array of size n =` n + n-1 + n-2 + n-3...`  n(n+1)/2\n\n\u003e [!NOTE] CONCEPT\n\u003e Every element added to the front of a subarray forms `x` sub-arrays with the elements before it, where x is the size of the subarray\n^0967ca\n\n- Easier to understand it backwards\n\t- array of size 4 :  `[1, 2, 3, 4, 5]`\n\t\t- no. of subarrays that can be formed with the 4th element are 4\n\t\t\t- `4, 4 3,  4 3 2,  4 3 2 1`\n\t\t- no. of subs formed with third element : 3\n\t\t\t- `3,  3 2,  3 2 1`\n\t\t- no. of subs formed with second element: 2\n\t\t\t- `2,  2 1`\n\t\t- no. of subs formed with first element: 1\n\t\t\t- ` 1 ` \n\t\t- All together the above form all the sub arrays possible  \n\n- 'end-start+1' unique subarrays can be created with new el at 'end'\n","lastmodified":"2024-07-04T20:24:17.033181857Z","tags":["dsadeck","arrays","slidingwindow","completed"]},"/dsa/73.-Set-Matrix-Zeroes":{"title":"73. Set Matrix Zeroes","content":"\n## Problem Statement\n\n\nPattern: \n\n---\n\n## Solution\n``` java\npublic void setZeroes(int[][] matrix) {\n\t// flag if initial zero occurs in first row or column\n\tboolean fr = false, fc = false;\n\tint m = matrix.length, n = matrix[0].length;\n\n\t// set zero markers and flags\n\tfor (int i = 0; i \u003c m ; i++)\n\t\tfor (int j = 0; j \u003c n; j++)\n\t\t\t// mark first row and col of el as 0\n\t\t\tif(matrix[i][j] == 0) {\n\t\t\t\t// flag if el in fr or fc\n\t\t\t\tif (i == 0) fr = true;\n\t\t\t\tif (j == 0) fc = true;\n\t\t\t\tmatrix[0][j] = 0;\n\t\t\t\tmatrix[i][0] = 0;\n\t\t\t}\n\n\t// use markers to set rows and columns to zero\n\tfor (int i = 1; i \u003c m; i++)\n\t\tfor (int j = 1; j \u003c n; j++)\n\t\t\tif(matrix[0][j] == 0 || matrix[i][0] == 0)\n\t\t\t\tmatrix[i][j] = 0;\n\n\t// if fr set first row to zero\n\tint index = 0;\n\twhile(fr \u0026\u0026 index \u003c n)\n\t\tmatrix[0][index++] = 0;\n\n\t// if fc set first column to zero\n\tindex = 0;\n\twhile(fc \u0026\u0026 index \u003c m) matrix[index++][0] = 0;\n}\n```\n\n### Notes\n- Use the 0th row and column as markers. ie.\n\t- if any elment in the array is zero, set its currsponding 0'th row el and 0th column element as zero\n\t- Reiterate, set any element to zero if its 0th row or 0th cell is zero\n-  What if the 0th element is in the first row or column itself?\n\t- that why we have `fc` and `fr` flags\n\t- if any of those are found to be true, the first row and column itself if set to zero by the last while loops\n# - **==another point==**\n\n\n","lastmodified":"2024-07-04T20:24:17.033181857Z","tags":["dsadeck","arrays"]},"/dsa/744.-Find-Smallest-Letter-Greater-Than-Target":{"title":"744. Find Smallest Letter Greater Than Target","content":"\n## Problem Statement\n\n\nPattern: [[Binary Search#Floor Ceil]]\n\n---\n\n## Solution\n``` java\npublic char nextGreatestLetter (char[] letters, char target){\n\tint start = 0, end = letters.length-1, mid;\n\twhile(start \u003c= end){\n\t\tmid = start + (end-start)/2;\n\t\tif(target \u003e= letters[mid]) start = mid+1;\n\t\telse end = mid-1;\n\t}\n\t// wrap around\n\treturn letters[start % letters.length];\n}\n```\n\n### Notes\n- simple binary search but we return first, because after convergence, it will always point to the next/greater element. - ceiling binary search\n- also `if(target \u003e= letters[mid])` cuz even if target is found we want the greater element.\n\n","lastmodified":"2024-07-04T20:24:17.037181919Z","tags":["dsadeck","arrays","binarysearch"]},"/dsa/75.-Sort-Colors":{"title":"75. Sort Colors","content":"\n\n## Problem Statement\n\n![](https://i.imgur.com/sZ33CdM.png)\n\nPattern: [[Pattern Array Partitioning]]\n\n---\n\n## Naive Solution\n``` java\npublic void sortColors(int[] nums) {\n\tint[] freqs = new int[3];\n\tfor (int num : nums) \n\t\tfreqs[num]++;\n\tint index = 0, color=0;\n\tfor(int freq : freqs) {\n\t\twhile(freq-- \u003e 0)\n\t\t\tnums[index++] = color;\n\t\tcolor++;\n\t}\n}\n```\n\n### Notes\n- Simple Solution, but we need to build a freq array. still a O(1) time and place solution. But we can do better\n\n---\n\n## Dutch National Flag / 3 Way QuickSort / 3 Way Partition \n``` java\npublic void sortColors (int[] nums){\n\tint zero = 0, two = nums.length-1, i = 0;\n\t// 'i' hasn't crossed 'two' partition\n\twhile(i \u003c= two) {\n\t\tif(nums[i] \u003c 1) {\n\t\t\t// swap to the 'zero' partition\n\t\t\tswap(nums, i, zero);\n\t\t\ti++; zero++;\n\t\t}\n\t\telse if(nums[i] \u003e 1) {\n\t\t\t// swap to the 'two' partition\n\t\t\tswap(nums, i, two);\n\t\t\ttwo--;\n\t\t}\n\t\telse i++;\n\t}\n}\n```\n\n### Notes\nCheck [[GFG Three Way Paritioning]]\n- This is a specific implementation of the 3 way quicksort algorithm\n\t- `zero` and `two` pointers point to the partition of the array containing those respective element\n\t- we traverse the array from `zero` to `two` and swap suitable elements into those respective paritions\n\t- for more details Check [[GFG Three Way Paritioning]] ð\n\n\n[Sort Array By Parity - LeetCode](https://leetcode.com/problems/sort-array-by-parity/)\n[Move all negative numbers to beginning and positive to end with constant extra space - GeeksforGeeks](https://www.geeksforgeeks.org/move-negative-numbers-beginning-positive-end-constant-extra-space/)\n","lastmodified":"2024-07-04T20:24:17.037181919Z","tags":["dsadeck","arrays"]},"/dsa/76.-Minimum-Window-Substring":{"title":"76. Minimum Window Substring","content":"\n## Problem Statement\n\n\nPattern: \nRelated: [[Smallest Distinct Window]]\n\n---\n\n## Solution\n``` java\npublic String minWindow(String s, String t) {\n\t\n\t// prepare dict\n\tMap\u003cCharacter, Integer\u003e dict = new HashMap\u003c\u003e();\n\tfor(char c : t.toCharArray()) dict.put(c, dict.getOrDefault(c, 0) + 1);\n\t\n\tint required = dict.size(), formed = 0;     // required : no. of uniqe ch's in string\n\tint l = 0, r = 0;\n\tint[] ans = {-1, l, r};                     // size, l, r\n\t\n\tMap\u003cCharacter, Integer\u003e window = new HashMap\u003c\u003e();\n\t\n\t// sliding window\n\twhile(r \u003c s.length()) {\n\t\t\n\t\t// add char to window\n\t\tchar curr = s.charAt(r);\n\t\twindow.put(curr, window.getOrDefault(curr, 0) + 1);\n\t\tif(dict.containsKey(curr) \u0026\u0026 dict.get(curr).equals(window.get(curr))) formed++;\n\t\t   \n\t\t// contract window till invalid\n\t\twhile(l \u003c= r \u0026\u0026 formed == required) {   // check if valid window\n\t\t\tchar prev = s.charAt(l);\n\t\t\t\n\t\t\t// update ans if window smaller\n\t\t\tif(ans[0] == -1 || r - l + 1 \u003c ans[0]) {\n\t\t\t\tans[0] = r - l + 1;\n\t\t\t\tans[1] = l;\n\t\t\t\tans[2] = r;\n\t\t\t}\n\t\t\t\n\t\t\t// remove prev char from window\n\t\t\twindow.put(prev, window.get(prev)-1);\n\t\t\t// update formed\n\t\t\tif (dict.containsKey(prev) \u0026\u0026 window.get(prev).intValue() \u003c dict.get(prev).intValue())\n\t\t\t\tformed--;\n\t\t\t\n\t\t\t// shift l fwd\n\t\t\tl++;\n\t\t}\n\t\t\n\t\t// shift r fwd \n\t\tr++;\n\t}\n\treturn ans[0] == -1 ? \"\" : s.substring(ans[1], ans[2] + 1);\n}\n```\nTC : $O(|S| + |T|)$\nSC : $O(|S| + |T|)$\n\n### Notes\n- This is basically a slightly complex sliding window problem, a window which needs to know what is the freq of each character in it `window` , and the required minimum freq of each character `dict`.\n- We keep expanding a window, and once it is **valid** (`formed ==  required`) we start contracting it and updating the answer till its invalid (`formed != required`)\n- We return minimum substring\n\n\n### Optimised Solution\n`filtered_S` is the `S` string without the **extra** characters not present in `T`. Checkout [the solution](https://leetcode.com/problems/minimum-window-substring/solution/)\n\n\n\n\n\n","lastmodified":"2024-07-04T20:24:17.037181919Z","tags":["dsadeck","strings"]},"/dsa/765.-Couples-Holding-Hands":{"title":"765. Couples Holding Hands","content":"\n## Problem Statement\n[Couples Holding Hands - LeetCode](https://leetcode.com/problems/couples-holding-hands/)\n\nPattern: \n\n---\n\n## Solution\n``` java\nclass Solution {\n\tpublic void swap(int[] x, int a, int b) {\n\t\tint t = x[a];\n\t\tx[a] = x[b];\n\t\tx[b] = t;\n\t}\n\t\n\tpublic int findIndex(int[] arr, int start, int key) {\n\t\tfor (; start \u003c arr.length; start++)\n\t\t\tif (arr[start] == key)\n\t\t\t\tbreak;\n\t\treturn start;\n\t}\n\t\n\tpublic int minSwapsCouples(int[] row) {\n\t\tint swapcount = 0;\n\t\t// iterate over pairs in arr\n\t\t// row.length-2 last pair is already sorted\n\t\tfor (int i = 0; i \u003c row.length-2; i += 2) {\n\t\t\t// find correct pair value\n\t\t\tint pval = row[i] % 2 == 0 ? row[i] + 1 : row[i] - 1;\n\n\t\t\t// if row[i+1] is wrong pair\n\t\t\tif (row[i+1] != pval) {\n\t\t\t\t// find correct pairIndex\n\t\t\t\tint ctPairIndex = findIndex(row, i + 2, pval);\n\t\t\t\t// swap row[i+1] with correct pair\n\t\t\t\tswap(row, i + 1, ctPairIndex);\n\t\t\t\tswapcount++;\n\t\t\t}\n\t\t}\n\t\treturn swapcount;\n\t}\n}\n```\n\n### Notes\n- Iterate over first el of each pair \n\t- check if it's pair is correct\n\t- if not\n\t\t- find correct pair and swap\n- it is not sufficient that `Math.abs(row[i+1] - row[i]) == 0`\n\t- `0, 1` is a pair `1, 2` isn't\n\n","lastmodified":"2024-07-04T20:24:17.037181919Z","tags":["easy","arrays","completed","dsadeck"]},"/dsa/767.-Reorganise-Substring":{"title":"767. Reorganise Substring","content":"\n## Problem Statement\n\n\nPattern: \n\n---\n\n## Solution\n``` java\npublic String reorganizeString(String s) {\n\tPriorityQueue\u003cint[]\u003e pq = new PriorityQueue\u003c\u003e((a, b) -\u003e b[1] - a[1]);\n\tint[] freq = new int[26];\n\t\n\t// get char freqs\n\tfor(char ch : s.toCharArray()) \n\t\tif(freq[ch-'a'] + 1 \u003e (s.length() + 1) / 2) return \"\";\n\t\telse freq[ch-'a']++;\n\t\n\t// insert into pq\n\tfor(int i = 0 ; i \u003c 26 ; i++) \n\t\tif (freq[i] \u003e 0) pq.add(new int[]{i + 'a', freq[i]});\n\t\n\t\n\t// generate string\n\tStringBuilder sb = new StringBuilder();\n\twhile(!pq.isEmpty()) {\n\t\t// get highest freq char\n\t\tint[] first = pq.poll();\n\t\t\n\t\t// if same as last\n\t\tif(sb.isEmpty() || sb.charAt(sb.length()-1) != (char) first[0]) {\n\t\t\tsb.append((char) first[0]);\n\t\t\tif(--first[1] \u003e 0) pq.add(first);\n\t\t}\n\t\t\n\t\t// if different from last\n\t\telse {\n\t\t\tint[] second = pq.poll();\n\t\t\tsb.append((char) second[0]);\n\t\t\tif(--second[1] \u003e 0) pq.add(second);\n\t\t\tpq.add(first);\n\t\t}\n\t}\n\t\n\treturn sb.toString();\n}\n\n```\nTC : $O(nlog(26))$\nSC : $O(1)$\n\n### Notes\n- if any character's freq \u003e (size of the string + 1) / 2, the rearranging the string is impossible\n- else, you can follow greedy approach, to alternate between most frequent and second most frequent characters in the string\n\n\n\n","lastmodified":"2024-07-04T20:24:17.037181919Z","tags":["dsadeck","strings"]},"/dsa/796.-Rotate-String":{"title":"796. Rotate String","content":"\n## Problem Statement\n[Rotate String - LeetCode](https://leetcode.com/problems/rotate-string/)\n\n\nPattern: \n\n---\n[Interview question: Check if one string is a rotation of other string - Stack Overflow](https://stackoverflow.com/questions/2553522/interview-question-check-if-one-string-is-a-rotation-of-other-string)\n\n## Solution\n``` java\nboolean isRotation(String s1,String s2) {\n    return (s1.length() == s2.length()) \u0026\u0026 ((s1+s1).indexOf(s2) != -1);\n}\n```\nTC : $n*m$\nSC : $O(n)$\n\n\n## Rabin Karp\n![[Rabin Karp#Solution]]\n\n","lastmodified":"2024-07-04T20:24:17.037181919Z","tags":["dsadeck","strings"]},"/dsa/80.-Remove-Duplicates-from-Sorted-Array-II":{"title":"80. Remove Duplicates from Sorted Array II","content":"\n## Problem Statement\n\n\nPattern: \n\n---\n\n## Solution\n``` java\npublic int removeDuplicates(int[] nums) {\n\tint i = 0, j = 0;\n\twhile (j \u003c nums.length) {\n\t\tint seek = j; \n\t\twhile(seek+1 \u003c nums.length \u0026\u0026 nums[seek+1] == nums[seek]) seek++;\n\t\tif(seek - j + 1 \u003e= 2) {\n\t\t\tnums[i++] = nums[j];\n\t\t\tnums[i++] = nums[j];\n\t\t} else nums[i++] = nums[j];\n\t\tj = seek + 1;\n\t}\n\treturn i;\n}\n```\nTC : $O(n)$\nSC : $O(1)$\n\n### Notes\n- have a third pointer seek forwards to from the second pointer, if it reaches a distance \u003e= 2, then override the next 2 elements, else just a single element\n\n\n\n\n","lastmodified":"2024-07-04T20:24:17.037181919Z","tags":["dsadeck","arrays"]},"/dsa/832.-Flipping-an-Image":{"title":"832. Flipping an Image","content":"\n## Problem Statement\n[Flipping an Image - LeetCode](https://leetcode.com/problems/flipping-an-image/)\n\nPattern: \n\n---\n\n## Solution\n``` java\npublic int[][] flipAndInvertImage(int[][] A) {\n\tint n = A.length;\n\tfor (int[] row : A)\n\t\tfor (int i = 0; i * 2 \u003c n; i++)\n\t\t\tif (row[i] == row[n - i - 1])\n\t\t\t\trow[i] = row[n - i - 1] ^= 1;\n\treturn A;\n}\n```\n\n### Notes\n`row[i] = row[n - i - 1] ^= 1`\n\ncan be rewritten as,\n\n`row[i] = row[n - i - 1] = row[n - i - 1] ^ 1`\n\ncan be rewritten as, executed in sequence,\n\n`row[n - i - 1] = row[n - i - 1] ^ 1`  \n`row[i] = row[n - i - 1]`\n\na ^= b equals a = a ^ b  \nbit manipulation by XOR:Â [https://en.wikipedia.org/wiki/XOR_gate](https://en.wikipedia.org/wiki/XOR_gate)\n\n\n","lastmodified":"2024-07-04T20:24:17.037181919Z","tags":["dsadeck","arrays"]},"/dsa/86.-Partition-List":{"title":"86. Partition List","content":"\n## Problem Statement\n\n![](https://i.imgur.com/mRi8Eyi.png)\n\nPattern: [[Pattern Array Partitioning]]\n\n---\n\n## Solution\n``` java\npublic ListNode partition(ListNode head, int x) {\n\t// iterators\n\tListNode smaller = new ListNode(-1), bigger = new ListNode(-1);\n\t// heads\n\tListNode smallHead = smaller, bigHead = bigger;\n\t\n\twhile(head != null) {\n\t\t// append to smaller LL\n\t\tif(head.val \u003c x) smaller = smaller.next = head;\n\t\t// append to bigger LL\n\t\telse bigger = bigger.next = head;\n\t\t// increment head\n\t\thead = head.next;\n\t}\n\t// set last node to null\n\tbigger.next = null;\n\t// connect end of smaller iterator and larger linked list\n\tsmaller.next = bigHead.next;\n\t// return smallHead\n\treturn smallHead.next;\n}\n```\n\n### Notes\n- create 2 linked list heads and iterators, one for smaller than x numbers and one for larger than x\n- connect both\n- return small's head\n\n\n\n","lastmodified":"2024-07-04T20:24:17.037181919Z","tags":["dsadeck","linkedlist"]},"/dsa/863.-All-Nodes-Distance-K-in-Binary-Tree":{"title":"863. All Nodes Distance K in Binary Tree","content":"\n## Problem Statement\n[All Nodes Distance K in Binary Tree - LeetCode](https://leetcode.com/problems/all-nodes-distance-k-in-binary-tree/)\n![](https://i.imgur.com/aHAbCfU.jpg)\nPattern: \n\n---\n\n## Solution\n``` java\nMap\u003cNode, Integer\u003e map = new HashMap\u003c\u003e();\nList\u003cInteger\u003e res;\n\npublic List\u003cInteger\u003e distanceK (Node root, Node target, int K){\n\tres = new LinkedList\u003c\u003e();\n\t\n\tfind(root, target);            // find distances for all in target path\n\tdfs(root, map.get(root), K);   // dfs tree to find all k-distant nodes to target\n\t\n\treturn res;\n}\n\nprivate void dfs (Node root, int dist, int K) { // dist -\u003e distance from Target\n\tif(root == null) return;\n\t\n\t// override dist if in target path\n\tdist = map.getOrDefault(root, dist);\n\t\n\t// if dist == k ans found, append result\n\tif(dist == K) res.add(root.val);\n\n\t// recurse for left right\n\tdfs(root.left, dist+1, K);  // inc dist by 1\n\tdfs(root.right, dist+1, K); // inc dist by 1\n}\n\n// find distances for all in target path from root\nprivate int find(Node root, Node target) {\n\t// BASE CASES\n\tif(root == null) return -1;\n\tif(root == target) {        // target found\n\t\tmap.put(root, 0);\n\t\treturn 0;\n\t}\n\t// recurse for left\n\tint leftDist = find(root.left, target);\n\tif (leftDist \u003e -1){             // leftDist to target found\n\t\tmap.put(root, leftDist+1);  // map -\u003e root, leftDist\n\t\treturn leftDist+1;\n\t}\n\t// recurse for right\n\tint rightDist = find(root.right, target);\n\tif(rightDist \u003e -1) {            // rightDist to target found\n\t\tmap.put(root, rightDist+1); // map -\u003e root, rightDist\n\t\treturn rightDist+1;\n\t}\n\treturn -1;  // target not found in subtree\n}\n```\n\n### Notes\nAs we know, if the distance from a node to target node isÂ `k`, the distance from its child to the target node isÂ `k + 1`Â **unless**Â the child node is closer to the target node which means the target node is in it's subtree.\n\nTo avoid this situation, we need to travel the tree first to find the path fromÂ `root`Â toÂ `target`, to:\n\n-   store the value of distance in hashamp from theÂ `all nodes in that path`Â toÂ `target`\n\nThen we can easily use dfs to travel the whole tree. Every time when we meet a treenode which has already been stored in map, use the stored value in hashmapÂ **instead of**Â plus 1. and the distance to **it's** child node is `++dist`\n\n\nStill dont understand :[Nodes at Distance K in Binary Tree | C++ Placement Course | Lecture 27.14 - YouTube](https://www.youtube.com/watch?v=f-oTsCUCiXk)\n","lastmodified":"2024-07-04T20:24:17.037181919Z","tags":["dsadeck","binarytrees"]},"/dsa/867.-Transpose-Matrix":{"title":"867. Transpose Matrix","content":"\n\n## Problem Statement\n\n\nPattern: \n\n---\n\n## Solution\n``` java\npublic int[][] transpose(int[][] matrix) {\n\t\n\tint n = matrix.length, m = matrix[0].length;\n\tint[][] trans = new int[m][n];\n\t\t\n\tfor(int i = 0 ; i \u003cn ; i++) \n\t\tfor(int j = 0 ; j \u003cm ; j++) \n\t\t  trans[j][i] = matrix[i][j];\n\t\t\n\treturn trans;\n}\n```\n\n### Notes\n- \n","lastmodified":"2024-07-04T20:24:17.037181919Z","tags":["dsadeck","arrays"]},"/dsa/876.-Middle-of-the-Linked-List":{"title":"876. Middle of the Linked List","content":"\n## Problem Statement\n\n\nPattern: \n\n---\n\n## Solution\n``` java\npublic static ListNode getMid (ListNode head) {\n\tListNode slow = head, fast = head; \n\t//fast = fast.next; // increment fast to get floor of mid\n\t\n\twhile (fast!= null \u0026\u0026 fast.next!=null) {\n\t\tslow = slow.next;\n\t\tfast = fast.next.next;\n\t}\n\t// when fast / fast.next becomes null, slow would have reached floor of mid\n\treturn slow;\n}\n```\n\n### Notes\n- this question asks for ceil of mid, but if we wanted floor of mid we'de have uncommented `fast = fast.next;`\n- used in merge sorting linked lists : [[148.Â Sort List]] etc.\n\n\n\n","lastmodified":"2024-07-04T20:24:17.037181919Z","tags":["dsadeck","linkedlist"]},"/dsa/919-Meeting-Rooms-II":{"title":"919 Â· Meeting Rooms II","content":"\n## Problem Statement\n==Leetcode Premium Problem== \n[919 Â· Meeting Rooms II - LintCode](https://www.lintcode.com/problem/919/)\n\n\nPattern: [[Pattern Activity Selection Problem]]\nRelated: [[986. Interval List Intersections]]\n\n---\n\nWhat do you have to do:\nFind and return the max number of overlapping intervals. to do that, you cannot simply check if a new non-overlapping interval has started, and update count. you need to be aware of every interval that ahas started, and ended at a given point in time to increment or decrement `overlapCount` or `sim` at a given point in time, to get an accurate \n\nso either\n- sort intervals comparing both start and end, the one with earliear start \u003c earlier end \u003c later start \u003c later end\n- then increse or decrease `sim` or `height` depending on overlap\n\nor, break up the interval into points sort by val, then if it is `end \u003c start`\n- every start increment `sim++`\n- every end decrement  `sim--`\n\n## Solutions\nDS used in problem\n``` java\nstatic class Interval {\n\tpublic int start;\n\tpublic int end;\n\t\n\tInterval(int s, int e) {\n\t\tthis.start = s;\n\t\tthis.end = e;\n\t}\n}\n```\n\n### Verbose Slower Solution\n``` java\nstatic class Point implements Comparable\u003cPoint\u003e {\n\tint val;\n\tboolean isStart;\n\t\n\tPoint(int val, boolean start) {\n\t\tthis.val = val;\n\t\tthis.isStart = start;\n\t}\n\t\n\t@Override\n\tpublic int compareTo(Point p2) {\n\t\tPoint p1 = this;\n\t\tint res = p1.val - p2.val;\n\t\tif (res == 0) {                                      // p1 = p2\n\t\t\tif (!p1.isStart \u0026\u0026 p2.isStart) res = -1;         // p1 \u003c p2\n\t\t\telse if (!p2.isStart \u0026\u0026 p1.isStart) res = 1;   // p2 \u003c p1\n\t\t}\n\t\treturn res;\n\t}\n}\n\npublic int minMeetingRooms(List\u003cInterval\u003e intervals) {\n\tArrayList\u003cPoint\u003e points = new ArrayList\u003c\u003e();\n\t// get interval start and end points\n\tfor (Interval i : intervals) {\n\t\tpoints.add(new Point(i.start, true));\n\t\tpoints.add(new Point(i.end, false));\n\t}\n\tCollections.sort(points);\n\t\n\t// count simultaneous meetings\n\tint sim = 0, maxSim = 0;\n\t\n\tfor (Point p : points) {\n\t\tif (p.isStart) sim++;\n\t\telse sim--;\n\t\tmaxSim = Math.max(sim, maxSim);\n\t}\n\t\n\t// return max simultaneous meetings recorded\n\treturn maxSim;\n}\n```\n- Slow just becuase of the extra class, and `ArrayList\u003cPoint\u003e` \n- Similiar to the [[Line Sweep Algorithm]] you extract and sort points from an interval, every time an interval starts, increment `sim` (which is the count of simultaneous intervals), and every time an interval ends `p.isStart == false` decrement `sim--`\n- keep track of `maxSim` and return it\n\n### Non-Verbose Faster Solution\n``` java\npublic int minMeetingRooms(List\u003cInterval\u003e intervals) {\n\tint n = intervals.size();\n\t// get start and ending points of intervals\n\tint[] start = new int[n], end = new int[n];\n\tfor (int i = 0; i \u003c n; i++) {\n\t\tstart[i] = intervals.get(i).start;\n\t\tend[i] = intervals.get(i).end;\n\t}\n\tArrays.sort(start);\n\tArrays.sort(end);\n\t\n\t// find max simultaneous intervals\n\tint sim = 0, maxSim = 0, s = 0, e = 0;\n\twhile (s \u003c n) {\n\t\tif (start[s] \u003c end[e]) {\n\t\t\ts++;\n\t\t\tsim++;\n\t\t} else {\n\t\t\te++;\n\t\t\tsim--;\n\t\t}\n\t\t// update maxSim\n\t\tmaxSim = Math.max(sim, maxSim);\n\t}\n\t// return maxSim\n\treturn maxSim;\n}\n```\n\n- Same thing here but without the extra `Point` class\n- extract all start and end pointers of intervals into a `start` and `end` array and sort them respectively\n- whichever comes first (is smaller) `start[s]` or `end[e]` visit it\n\t- if start point comes first `if (start[s] \u003c end[e])` then increment `sim` and increment start pointer `s`\n\t- else if `start[s] \u003e= end[e]` even if start and end come together, end has precedence, since acc to the questions, if 2 meetings start and end at the same time, the ending meeting ends first.\n\n## Similar Problem\n","lastmodified":"2024-07-04T20:24:17.037181919Z","tags":["dsadeck","intervals"]},"/dsa/92.-Reverse-Linked-List-II":{"title":"92. Reverse Linked List II","content":"\n## Problem Statement\n\n\nPattern: \n\n---\n\n## Solution\n``` java\n// successor is the continuation of non-reversed LL\nListNode successor = null;\n\npublic ListNode reverseBetween(ListNode head, int l, int r) {\n\tif (l == 1) return reverseN(head, r);\n\t\n\thead.next = reverseBetween(head.next, l - 1, r - 1);\n\treturn head;\n}\n\nListNode reverseN(ListNode head, int n) {\n\tif (n == 1) {\n\t\tsuccessor = head.next;\n\t\treturn head;\n\t}\n\tListNode last = reverseN(head.next, n - 1);\n\thead.next.next = head;\n\thead.next = successor;    // instead of pointing to null, point to successor\n\treturn last;\n}\n```\n\n### Notes\n- recursively call `reverseBetween` with `head.next` and at l == 1, `return reverse (head, r)`\n- r will have reduced by `l` , so exit condition for `n==1`\n- set successor node, and the rest is like [[206. Reverse Linked List]] \n\n\n\n","lastmodified":"2024-07-04T20:24:17.037181919Z","tags":["dsadeck","arrays"]},"/dsa/920.-Meeting-Rooms":{"title":"920. Meeting Rooms","content":"\n## Problem Statement\n\n\nPattern: \n\n---\n\n## Solution\n``` java\npublic boolean canAttendMeetings(List\u003cInterval\u003e intervals) {\n\t// Write your code here\n\tintervals.sort(Comparator.comparingInt(i -\u003e i.end));\n\tInterval prev = new Interval(-1, -1);\n\tfor(Interval curr : intervals) {\n\t\tif(curr.start \u003c prev.end) return false;\n\t\tprev = curr;\n\t}\n\treturn true;\n}\n```\n\n### Notes\n- if there is any overlap return false\n- else return true\n\n\n\n","lastmodified":"2024-07-04T20:24:17.037181919Z","tags":["dsadeck","intervals"]},"/dsa/93.-Restore-IP-Addresses":{"title":"93. Restore IP Addresses","content":"\n## Problem Statement\n\n\nPattern: \n\n---\n\n## Solution\n``` java\nList\u003cString\u003e res;\n\npublic void dp (String s, int n, int slot, int slotSize, int[] restored) {\n\tif (slotSize \u003e 3 || n != -1 \u0026\u0026 slot \u003c 0 || n == -1 \u0026\u0026 slot \u003e-1) return;\n\tif (n == -1 \u0026\u0026 slot == -1) {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor(int ip : restored) sb.append(ip).append(\".\");\n\t\tsb.setLength(sb.length()-1);\n\t\tres.add(sb.toString());\n\t\treturn;        \n\t}\n\t\n\t// add slot\n\tString substr = s.substring(n, n+slotSize);\n\tint val = Integer.parseInt(substr);\n\tif(val \u003c= 255 \u0026\u0026 !(substr.length() \u003e 1 \u0026\u0026 substr.charAt(0)=='0')) {\n\t\trestored[slot] = val;\n\t\tdp(s, n-1, slot-1, 1, restored);\n\t}\n\t// continue slot\n\tdp(s, n-1, slot, slotSize+1, restored);\n\t\n}\n\npublic List\u003cString\u003e restoreIpAddresses(String s) {\n\tres = new ArrayList\u003c\u003e();\n\tdp(s, s.length()-1, 3, 1, new int[4]);\n\treturn res;\n}\n```\nTC : $O(n^2)$\nSC : $O(n^2)$\n\n### Notes\n- pretty self explanatory, once you look at the code\n\nCaching not working. ask @Gaurav to explain\n``` java\nList\u003cString\u003e res;\nboolean cache[][][];\n\npublic void dp (String s, int n, int slot, int slotSize, int[] restored) {\n\tif (slotSize \u003e 3 || n != -1 \u0026\u0026 slot \u003c 0 || n == -1 \u0026\u0026 slot \u003e-1) return;\n\tif (n == -1 \u0026\u0026 slot == -1) {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor(int ip : restored) sb.append(ip).append(\".\");\n\t\tsb.setLength(sb.length()-1);\n\t\tres.add(sb.toString());\n\t\treturn;        \n\t}\n\tif (cache[n][slot][slotSize]) return;\n\t\n\t// add slot\n\tString substr = s.substring(n, n+slotSize);\n\tint val = Integer.parseInt(substr);\n\tif(val \u003c= 255 \u0026\u0026 !(substr.length() \u003e 1 \u0026\u0026 substr.charAt(0)=='0')) {\n\t\trestored[slot] = val;\n\t\tdp(s, n-1, slot-1, 1, restored);\n\t}\n\t// continue slot\n\tdp(s, n-1, slot, slotSize+1, restored);\n\tcache[n][slot][slotSize] = true;\n}\n\npublic List\u003cString\u003e restoreIpAddresses(String s) {\n\tres = new ArrayList\u003c\u003e();\n\tcache = new boolean[s.length()][4][4];\n\tdp(s, s.length()-1, 3, 1, new int[4]);\n\treturn res;\n}\n```\n\n### Iterative Solution\n``` java\npublic List\u003cString\u003e restoreIpAddresses(String s) {\n\tList\u003cString\u003e res = new ArrayList\u003cString\u003e();\n\tint len = s.length();\n\tfor(int i = 1; i\u003c4 \u0026\u0026 i\u003clen-2; i++)\n\t\tfor(int j = i+1; j\u003ci+4 \u0026\u0026 j\u003clen-1; j++)\n\t\t\tfor(int k = j+1; k\u003cj+4 \u0026\u0026 k\u003clen; k++){\n\t\t\t\tString s1 = s.substring(0,i), s2 = s.substring(i,j), s3 = s.substring(j,k), s4 = s.substring(k,len);\n\t\t\t\tif(isValid(s1) \u0026\u0026 isValid(s2) \u0026\u0026 isValid(s3) \u0026\u0026 isValid(s4))\n\t\t\t\t\tres.add(s1+\".\"+s2+\".\"+s3+\".\"+s4);\n\t\t\t}\n\treturn res;\n}\npublic boolean isValid(String s){\n\tif(s.length()\u003e3 || s.length()==0 || (s.charAt(0)=='0' \u0026\u0026 s.length()\u003e1) || Integer.parseInt(s)\u003e255)\n\t\treturn false;\n\treturn true;\n}\n```\n\nTC : $O(n^2)$\nSC : $O(n^2)$\n","lastmodified":"2024-07-04T20:24:17.037181919Z","tags":["dsadeck","strings"]},"/dsa/98.-Validate-BST":{"title":"98. Validate BST","content":"\n## Problem Statement\n\n\nPattern: \n\n---\n\n## Iterative Inorder Stack Solution\n``` java\npublic boolean isValidBST (TreeNode node){\n\tDeque\u003cTreeNode\u003e stack = new LinkedList\u003c\u003e();\n\tTreeNode prev = null;\n\twhile(node!= null || !stack.isEmpty()) {\n\t\tif(node != null) {\n\t\t\tstack.push(node);\n\t\t\tnode = node.left;   // go left\n\t\t} else {\n\t\t\tnode = stack.pop(); // visit node\n\t\t\tif(prev != null \u0026\u0026 prev.val \u003e= node.val) return false;\n\t\t\tprev = node;\n\t\t\tnode = node.right;  // go right\n\t\t}\n\t}\n\treturn true;\n}\n```\n\n### Notes\n- [[Iterative Traversals of BT#Inorder]]\n\n## Range Solution\nleetcode solution\n\n\n","lastmodified":"2024-07-04T20:24:17.037181919Z","tags":["dsadeck","bst"]},"/dsa/986.-Interval-List-Intersections":{"title":"986. Interval List Intersections","content":"\n## Problem Statement\n\n\nPattern: \nRelated: [[919 Â· Meeting Rooms II]]\n\n---\n\n## Solution\n``` java\npublic int[][] intervalIntersection(int[][] A, int[][] B) {\n\tList\u003cint[]\u003e res = new ArrayList\u003c\u003e();\n\t\n\tfor (int i = 0, j = 0; i \u003c A.length \u0026\u0026 j \u003c B.length;) {\n\t\t// find the closest start and end points of both intervals\n\t\tint start = Math.max(A[i][0], B[j][0]);\n\t\tint end = Math.min(A[i][1], B[j][1]);\n\t\t\n\t\t// if overlap add to res\n\t\tif(start \u003c= end) res.add(new int[] {start, end});\n\t\t\n\t\t// increment arr w the laggin interval\n\t\tif(A[i][1] \u003c B[j][1]) i++;\n\t\telse j++;\n\t}\n\t\n\treturn res.toArray(new int[res.size()][2]);\n}\n```\n\n### Notes\n- [[Python] Two Pointer Approach + Thinking Process Diagrams - LeetCode Discuss](https://leetcode.com/problems/interval-list-intersections/discuss/647482/Python-Two-Pointer-Approach-%2B-Thinking-Process-Diagrams)\n- As clear as can be explained ð\n\nThis can also be solved using the pointer logic / [[Line Sweep Algorithm]] approaach from [[919 Â· Meeting Rooms II]]\n\n``` java\npublic int[][] intervalIntersection1(int[][] firstList, int[][] secondList) {\n\t// create start and end arrays\n\tint n1 = firstList.length, n2 = secondList.length;\n\tint[] start = new int[n1 + n2], end = new int[n1 + n2];\n\t\n\tfor (int i = 0; i \u003c n1; i++) {\n\t\tstart[i] = firstList[i][0];\n\t\tend[i] = firstList[i][1];\n\t}\n\tfor (int i = 0; i \u003c n2; i++) {\n\t\tstart[i + n1] = secondList[i][0];\n\t\tend[i + n1] = secondList[i][1];\n\t}\n\t\n\tArrays.sort(start);\n\tArrays.sort(end);\n\t\n\t// find start value and end value of overlapping intervals\n\tint s = 0, e = 0, sim = 0, sval = -1;\n\tArrayList\u003cint[]\u003e res = new ArrayList\u003c\u003e();\n\twhile (e \u003c end.length) {\n\t\t// start pointer\n\t\tif (s \u003c start.length \u0026\u0026 start[s] \u003c= end[e]) {\n\t\t\tif (++sim == 2) sval = start[s];\n\t\t\ts++;\n\t\t}\n\t\t// end pointer\n\t\telse {\n\t\t\tif (--sim == 1) res.add(new int[]{sval, end[e]});\n\t\t\te++;\n\t\t}\n\t}\n\treturn res.toArray(new int[0][]);\n}\n```\n like so ð. but this is unnecassary since 2 intervals within the each given array `A[]` or `B[]` will never overlap \n \u003e Each list of intervals is pairwiseÂ **disjoint**Â and inÂ **sorted order**.\n\nIf they were'nt however, the above approach would be necessary","lastmodified":"2024-07-04T20:24:17.037181919Z","tags":["dsadeck","intervals"]},"/dsa/989.-Add-to-Array-Form-of-Integer":{"title":"989. Add to Array-Form of Integer","content":"\n## Problem Statement\n\n\nPattern:  \n\n---\n\n## Solution\n``` java\npublic List\u003cInteger\u003e addToArrayForm(int[] num, int k) {\n\tList\u003cInteger\u003e result = new LinkedList\u003c\u003e();\n\tfor (int i = num.length - 1; i \u003e= 0; i--) {\n\t\t// add element to k\n\t\tk = k + num[i];\n\t\t// insert last digit to beginning of result\n\t\tresult.add(0, k % 10);\n\t\t// update k\n\t\tk /= 10;\n\t}\n\t// copy remaining k\n\twhile (k \u003e 0) {\n\t\tresult.add(0, k % 10);\n\t\tk /= 10;\n\t}\n\treturn result;\n}\n```\n\n### Notes\n- \n\n","lastmodified":"2024-07-04T20:24:17.037181919Z","tags":["dsadeck","arrays"]},"/dsa/BT-Sum-at-Kth-Level":{"title":"BT Sum at Kth Level","content":"\n## Problem Statement\n\n\nPattern: \n\n---\n\n## Solution\n``` java\npublic int KSum(Node root, int k) {\n\tint level = 0, sum = 0;\n\tQueue\u003cNode\u003e q = new LinkedList\u003c\u003e();\n\tq.add(root);\n\t\n\twhile (!q.isEmpty()) {\n\t\tint size = q.size();\n\t\tsum = 0;\n\t\tlevel++;\n\t\twhile (size-- \u003e 0) {\n\t\t\tNode node = q.poll();\n\t\t\tsum += node.val;\n\t\t\tif (node.left != null) \tq.add(node.left);\n\t\t\tif (node.right != null) q.add(node.right);\n\t\t}\n\t\tif (level == k) break;\n\t}\n\treturn sum;\n}\n```\n\n### Notes\n- we already know how to do a [[Binary Tree#Level Order Traversals|Level Order Traversal]]\n\t- instead of using nulls to differentiate the next line, there is a better way!\n\t- we can keep track of the number of elements added in each level = `q.size` after removing the root\n\t- first iter when only root is in queue, the number of elements at level 1 is `q.size()`. so we iterate `size` number of times\n\t- next outer loop iter, the number of elements in q  =  `q.size()` is 2 \n- so on and so forth. this way we can distinguish a level in a BT\n \n\n\n","lastmodified":"2024-07-04T20:24:17.037181919Z","tags":["dsadeck","binarytrees"]},"/dsa/Balance-Binary-Tree":{"title":"Balance Binary Tree","content":"\n## Problem Statement\n\n\nPattern: \n\n---\n\n## Solution\n``` java\npublic int checkHeight (TreeNode root) {\n\tif (root == null) return 0;\n\t\n\tint lh = checkHeight(root.left);\n\tint rh = checkHeight(root.right);\n\n\tif(lh == -1 || rh == -1 || Math.abs(lh-rh) \u003e 1) return -1;\n\t\t\n\t// return height of current node\n\treturn Math.max(lh, rh) + 1;\n}\n\npublic boolean isBalanced(TreeNode root) {\n\tif(checkHeight(root) != -1) return true;\n\treturn false;\n}\n```\n\n### Notes\n- use int, to return the height difference  at every step\n- if height diff \u003e 1 in current or left or right nodes, return -1\n- if final value is not -1 return true, else return false\n\n","lastmodified":"2024-07-04T20:24:17.037181919Z","tags":["dsadeck","binarytrees"]},"/dsa/Bank-Transactions":{"title":"Bank Transactions","content":"\n## Problem Statement\n\n\nPattern: \n\n---\n\n## Solution\n``` java\nstatic HashMap\u003cInteger, HashMap\u003cInteger, Integer\u003e\u003e cache;\npublic static int dp(int[] nums, int i, int sum) {\n\tif (i \u003e= nums.length) return 0;\n\tif(cache.containsKey(i) \u0026\u0026 cache.get(i).containsKey(sum))\n\t\treturn cache.get(i).get(sum);\n\t\n\t// GET RES\n\tint res;\n\tif(sum + nums[i] \u003e= 0) {\n\t\tres = Math.max(\n\t\t\tdp(nums, i + 1, sum + nums[i]) + 1,\n\t\t\tdp(nums, i + 1, sum)\n\t\t);\n\t}\n\telse res = dp(nums, i + 1, sum);\n\t\n\t// CACHE RES\n\tHashMap\u003cInteger, Integer\u003e sumMap = cache.getOrDefault(i, new HashMap\u003c\u003e());\n\tsumMap.put(sum, res); cache.put(i, sumMap);\n\t\n\t// RETURN RES\n\treturn res;\n}\n\npublic static int getTransactions(int[] nums) {\n\tcache = new HashMap\u003c\u003e();\n\treturn dp(nums,  0, 0);\n}\n```\nTC : $O()$\nSC : \n\n### Notes\n- \n\n\n\n","lastmodified":"2024-07-04T20:24:17.037181919Z","tags":["dsadeck","dp"]},"/dsa/Binary-Search-Tree":{"title":"Binary Search Tree","content":"\n- left child \u003c root \u003c right chilid\n- inorder traversal gives sorted array\n- search complexity is `O(h)` `h=height`\n\n\n## Fundamental Programs\n``` java\npublic static TreeNode insert(TreeNode root, int val) {\n\tif (root == null) return new TreeNode(val);\n\t\n\tif (val \u003c root.val)\n\t\troot.left = insert(root.left, val);\n\telse if(val \u003e root.val )\n\t\troot.right = insert(root.right, val);\n\t\n\treturn root;\n}\n\npublic static boolean search(TreeNode root, int val) {\n\tif (root == null) return false;\n\tif (root.val == val) return true;\n\t\n\tboolean found;\n\t\n\tif (val \u003c root.val) found = search(root.left, val);\n\telse found = search(root.right, val);\n\t\n\treturn found;\n}\n\npublic static TreeNode insert(int[] arr) {\n\tTreeNode root = new TreeNode(arr[0]);\n\tfor (int i = 1; i \u003c arr.length; i++)\n\t\tinsert(root, arr[i]);\n\t\n\treturn root;\n}\n\n// === DELETE === //\n// return left most node\nprivate static TreeNode inorderSuccessor(TreeNode root) {\n\troot = root.right;\n\twhile (root!= null \u0026\u0026 root.left != null) root = root.left;\n\treturn root;\n}\n\npublic static TreeNode delete(TreeNode root, int val) {\n\tif (root == null) return null;\n\t\n\tif (val \u003c root.val) root.left = delete(root.left, val);\n\telse if (val \u003e root.val) root.right = delete(root.right, val);\n\t\n\telse {  // root.val == val\n\t\t\n\t\t// case 1: 0 child\n\t\tif (BT.isLeaf(root)) return null;\n\t\t\n\t\t// case 2 : 1 child\n\t\tif (root.right == null) return root.left;\n\t\tif (root.left == null) return root.right;\n\t\t\n\t\t// case 3 : 2 child\n\t\t// get root's inorder successor -\u003e leftmost node in the right subtree\n\t\tTreeNode is = inorderSuccessor(root);\n\t\t// replace root w is\n\t\troot.val = is.val;\n\t\t// delete is from right subtree\n\t\troot.right = delete(root.right, is.val);\n\t}\n\t\n\treturn root;\n}\n\npublic static void inRange(TreeNode root, int X, int Y) {\n\tif (root == null) return;\n\t\n\tif (root.val \u003c X) inRange(root.right, X, Y);\n\telse if (root.val \u003e Y) inRange(root.left, X, Y);\n\t\n\telse {  // X \u003c= root.val \u003c= Y\n\t\t// inorder print inRange\n\t\tinRange(root.left, X, Y);\n\t\tSystem.out.print(root.val + \" \");\n\t\tinRange(root.right, X, Y);\n\t}\n}\n```\n","lastmodified":"2024-07-04T20:24:17.037181919Z","tags":[]},"/dsa/Binary-Tree":{"title":"Binary Tree","content":"\n# Build Tree Preorder\n``` java\n// Build Tree - Preorder\npublic Node buildTree(int[] nodes) {\n\tidx++;\n\t\n\tif (nodes[idx] == -1) return null;\n\t\n\tNode newNode = new Node(nodes[idx]);\n\tnewNode.left = buildTree(nodes);\n\tnewNode.right = buildTree(nodes);\n\t\n\treturn newNode;\n}\n```\n\n\n# Traversals\n``` java\n// Preorder Traversal - root first\npublic static void preorder(Node root) {\n\tif (root == null) return;\n\t\n\tSystem.out.print(root.val + \" \");\n\tpreorder(root.left);\n\tpreorder(root.right);\n}\n\n// Postorder Traversal - root second\npublic static void inorder(Node root) {\n\tif (root == null) return;\n\t\n\tinorder(root.left);\n\tSystem.out.print(root.val + \" \");\n\tinorder(root.right);\n}\n\n// Inorder Traversal - root last\npublic static void postorder(Node root) {\n\tif (root == null) return;\n\t\n\tpostorder(root.left);\n\tpostorder(root.right);\n\tSystem.out.print(root.val + \" \");\n}\n\n\n// LevelOrder Traversal - iterative using queue\npublic static void levelorder(Node root) {\n\t// Create \u0026 add root to q\n\tQueue\u003cNode\u003e q = new LinkedList\u003c\u003e();\n\tq.add(root);\n\tq.add(null);\n\t\n\t// edge case\n\tif (root == null) return;\n\t\n\twhile (!q.isEmpty()) {\n\t\tNode node = q.remove();\n\t\t// Data Node\n\t\tif (node != null) {\n\t\t\tSystem.out.print(node.val + \" \");\n\t\t\tif (node.left != null) q.add(node.left);\n\t\t\tif (node.right != null) q.add(node.right);\n\t\t}\n\t\t// Null Node \u0026\u0026 q Not Empty\n\t\telse if (!q.isEmpty()) {\n\t\t\tq.add(null);\n\t\t\tSystem.out.print(\"\\n\");\n\t\t}\n\t}\n}\n```\n\n# Level Order Traversals\n\n## Iterative Queue O(n)\n``` java\npublic ArrayList\u003cInteger\u003e levelOrder (Node root) {\n\tif(root == null) return new ArrayList\u003cInteger\u003e();\n\t// result list\n\tArrayList\u003cInteger\u003e res = new ArrayList\u003c\u003e();\n\t\n\t// queue to iterate over BT\n\tQueue\u003cNode\u003e q = new LinkedList\u003cNode\u003e();\n\tq.add(root);\n\twhile (!q.isEmpty()) {\n\t\tNode node = q.poll();\n\t\tres.add(node.val);\n\t\t\n\t\tif(node.left != null) q.add(node.left);\n\t\tif(node.right != null) q.add(node.right);\n\t}\n\treturn res;\n}\n```\n\n## Iterative Queue O(n) Print with next line\n``` java\npublic levelOrderBottom(TreeNode root) {\n\tif(root == null) return res;\n\tQueue\u003cTreeNode\u003e q = new LinkedList\u003cTreeNode\u003e();\n\tq.add(root);\n\twhile (!q.isEmpty()) {\n\t\tint size = q.size();\n\t\twhile(size-- \u003e 0) {\n\t\t\tTreeNode node = q.poll();\n\t\t\tSystem.out.println(node.val + \" \")\n\t\t\tif(node.left != null) q.add(node.left); \n\t\t\tif(node.right != null) q.add(node.right); \n\t\t}\n\t\tSystem.out.println(\"\\n\")\n\t}\n\treturn res;\n}\n```\n\n## Iterative return ArrayList\n``` java\npublic List\u003cList\u003cInteger\u003e\u003e levelOrderBottom(TreeNode root) {\n\t\n\tList\u003cList\u003cInteger\u003e\u003e res = new ArrayList\u003c\u003e();\n\tif(root == null) return res;\n\n\tQueue\u003cTreeNode\u003e q = new LinkedList\u003cTreeNode\u003e();\n\tq.add(root);\n\twhile (!q.isEmpty()) {\n\t\tint size = q.size();\n\t\tArrayList\u003cInteger\u003e level = new ArrayList\u003c\u003e();\n\t\twhile(size-- \u003e 0) {\n\t\t\tTreeNode node = q.poll();\n\t\t\tlevel.add(node.val);\n\t\t\tif(node.left != null) q.add(node.left); \n\t\t\tif(node.right != null) q.add(node.right); \n\t\t}\n\t\tres.add(level);\n\t}\n\treturn res;\n}\n```\n\n\n## Recrusive O(n^2)\n``` java\nArrayList\u003cInteger\u003e res;\n\npublic ArrayList\u003cInteger\u003e levelOrder (Node root){\n\tres = new ArrayList\u003c\u003e();\n\tint height = BinaryTree.height(root);\n\tfor (int i = 1; i \u003c= height; i++) {\n\t\tprintLevel(root, i);\n\t\tres.add(null);    // null for next line\n\t}\n\treturn res;\n}\n\nprivate void printLevel(Node root, int level) {\n\t// Base Cases\n\tif (root == null) return;\n\tif(level == 1) {\n\t\tres.add(root.val);\n\t\treturn;\n\t}\n\t// recurse for left and right\n\tprintLevel(root.left, level-1);\n\tprintLevel(root.right, level-1);\n}\n```\n","lastmodified":"2024-07-04T20:24:17.037181919Z","tags":[]},"/dsa/Binary-Tree-to-DLL":{"title":"Binary Tree to DLL","content":"\n## Problem Statement\n\n\nPattern: \n\n---\n\n## Solution\n\n``` java\nNode last;\nNode inorder (Node root) {\n\tif(root == null) return root;\n\t\n\tinorder(root.left);\n\t\t// link last to root\n\t\tif (last != null) last.right = root;\n\t\t// link root to last\n\t\troot.left = last;\n\t\t// set new last\n\t\tlast = root;\n\tinorder(root.right);\n\t\n\treturn root;\n}\n\n//Function to convert binary tree to doubly linked list and return it.\nNode bToDLL(Node root)\n{\n\tif(root == null) return root;\n\t\n\t// inorder convert BT to DLL\n\tNode tail = inorder(root);\n \n\t// get DLL head\n\twhile(tail.left != null) tail = tail.left;\n\t\n\t// return dll head\n\treturn tail;\n}\n```\n\n- \n\n","lastmodified":"2024-07-04T20:24:17.037181919Z","tags":["dsadeck","binarytrees"]},"/dsa/Check-if-Tree-is-Isomorphic":{"title":"Check if Tree is Isomorphic","content":"\n## Problem Statement\n\n\nPattern: \n\n---\n\n## Solution\n``` java\nboolean isIsomorphic(Node root1, Node root2)  \n{ \n\t// code here.\n\tif(root1 == null \u0026\u0026 root2 == null) return true;\n\tif(root1 == null || root2 == null) return false;\n\t\n\tif(root1.data != root2.data) return false;\n\t\n\treturn (isIsomorphic(root1.left,root2.left) \u0026\u0026 isIsomorphic(root1.right,root2.right)) ||\n   (isIsomorphic(root1.left,root2.right) \u0026\u0026 isIsomorphic(root1.right,root2.left));\n}\n```\n\n### Notes\n- either corresponding left and right nodes of a node have to be the same\n- or opposite corresponding left and right nodes of a node have to be the same\n\n\n","lastmodified":"2024-07-04T20:24:17.037181919Z","tags":["dsadeck","binarytrees"]},"/dsa/Check-whether-BST-contains-Dead-End":{"title":"Check whether BST contains Dead End","content":"\n## Problem Statement\n\n\nPattern: \nRelated: [[1008. Construct Binary Search Tree from Preorder Traversal]]\n\n---\n\n## Solution\n``` java\npublic static boolean isDeadEnd(Node n){return check(n, 0, Integer.MAX_VALUE);}\n\n// (min, max)\npublic static boolean check (Node root, int min, int max) {\n\tif(root == null) return false;\n\tif(root.data == min + 1  \u0026\u0026 root.data == max-1) return true;\n\t\n\treturn check(root.left, min, root.data) || check(root.right, root.data, max);\n}\n```\nTC : ` n `\nSC : ` h - stack `\n\n","lastmodified":"2024-07-04T20:24:17.037181919Z","tags":["dsadeck","bst"]},"/dsa/Clone-LL-with-Random-Pointer":{"title":"Clone LL with Random Pointer","content":"\n## Problem Statement\n[Clone a linked list with next and random pointer | Practice | GeeksforGeeks](https://practice.geeksforgeeks.org/problems/clone-a-linked-list-with-next-and-random-pointer/1)\n\nPattern: \n\n---\n\n## Solution\n``` java\nNode copyList(Node head) {\n\tNode curr = head;\n\t// insert node\n\twhile(curr!=null) {\n\t\tNode newNode = new Node(curr.data);\n\t\tnewNode.next = curr.next;\n\t\tcurr.next = newNode;\n\t\tcurr = newNode.next;\n\t}\n\t// point arb\n\tcurr = head;\n\twhile(curr!=null) \n\t{\n\t\tif(curr.arb!=null)\n\t\t\tcurr.next.arb = curr.arb.next;\n\t\tcurr = curr.next.next;\n\t}\n\t\n\t// separate both LL\n\tNode clonedHead = head.next, cloned = clonedHead;\n\tcurr = head;\n\twhile (curr != null) {\n\t\tcurr.next = curr.next.next;\n\t\tcurr = curr.next;\n\t\tif(cloned.next != null) {\n\t\t\tcloned.next = cloned.next.next;\n\t\t\tcloned = cloned.next;\n\t\t}\n\t} \n\t\n\treturn clonedHead;\n}\n```\n\n### Notes\n- \n\n","lastmodified":"2024-07-04T20:24:17.037181919Z","tags":["dsadeck","linkedlist"]},"/dsa/Convert-Sorted-List-to-BST":{"title":"Convert Sorted List to BST","content":"\n## Problem Statement\n\n\nPattern: \nRelated:  [[Balance Binary Tree]]\n\n---\n\n## Solution\n``` java\npublic Node sortedListToBST(ListNode head) { return bstify(head, null);}\n\n// [head, tail)\npublic Node bstify(ListNode head, ListNode tail) {\n\tif (head == tail) return null;\n\t\n\t// get mid\n\tListNode mid = head, fast = mid.next;\n\twhile (fast != tail \u0026\u0026 fast.next != tail) {\n\t\tmid = mid.next;\n\t\tfast = fast.next.next;\n\t}\n\t// get left and right\n\tNode node = new Node(mid.val);\n\tnode.left = bstify(head, mid);\n\tnode.right = bstify(mid.next, tail);\n\t\n\treturn node;\n}\n```\nTC : ` O(nlogn) `\nSC : ` O(1), O(log n) - stack `\n\n- `nlogn` complexity, because we have to traverse sub-lists to find `mid` of max size `n`,  and we have to do this `logn` times\n- basically like merge sort, we have to perform merge operation on 2 arrays of max size n lognÂ times\n\n\n## Inorder O(n) Solution\n``` java\nListNode list;\n\npublic TreeNode sortedListToBST(ListNode head) {\n\tlist = head;\n\tint size = 0;\n\tfor (; head != null; size++) head = head.next;\n\treturn inorderBstify(0, size-1);\n}\n\n// [start, end]\npublic TreeNode inorderBstify(int start, int end) {\n\tif (start \u003e end) return null;\n\tint mid = start + (end - start) / 2;\n\t\n\tTreeNode left = inorderBstify(start, mid - 1);\n\tTreeNode curr = new TreeNode(list.val); list = list.next;\n\tTreeNode right = inorderBstify(mid + 1, end);\n\t\n\tcurr.left = left;\n\tcurr.right = right;\n\n\treturn curr;\n}\n```\nTC : ` O(n) `\nSC : ` O(1), O(log n) - stack \n\n## Notes\n- Better Solution : O(n)\n- we go left till the we reach the first node of the list, and then inorder traverse, the bst, and linear traverse the Linked List `list = list.next` ð¤·ââï¸. simple!\n\n## Iterative Inorder Solution\n#todoleetcode \njust like \n[[1008. Construct Binary Search Tree from Preorder Traversal]]","lastmodified":"2024-07-04T20:24:17.037181919Z","tags":["dsadeck","bst"]},"/dsa/Count-Customers-Who-Did-Not-Get-A-Computer":{"title":"Count Customers Who Did Not Get A Computer","content":"\n## Problem Statement\n[Count Customers Who Did Not Get A Computer - Coding Ninjas Codestudio](https://www.codingninjas.com/codestudio/problems/count-customers-who-did-not-get-a-computer_1115775?leftPanelTab=0)\n\nStrings version : [Function to find Number of customers who could not get a computer - GeeksforGeeks](https://www.geeksforgeeks.org/function-to-find-number-of-customers-who-could-not-get-a-computer/)\n\nPattern: \n\n---\n\n## Solution\n``` java\npublic static int countCustomers(ArrayList\u003cInteger\u003e arr, int k) \n{\n\t// Write your code here\n\tint occupied = 0, result = 0 ;\n\tHashMap\u003cInteger, Integer\u003e map = new HashMap\u003cInteger, Integer\u003e();\n\t\n\tfor (int cus : arr) {\n\t\t// first time\n\t\tif(!map.containsKey(cus)) {\n\t\t\tmap.put(cus, 0); \n\t\t\t// if vacancy - mark vacancy\n\t\t\tif (occupied \u003c k) {\n\t\t\t\tmap.put(cus, 1);\n\t\t\t\toccupied++;\n\t\t\t}\n\t\t}\n\t\t// second time\n\t\telse {\n\t\t\t// if holding - mark vacant\n\t\t\tif (map.get(cus) == 1) {\n\t\t\t\tmap.remove(cus);\n\t\t\t\toccupied--;\n\t\t\t}\n\t\t\t// else increment result\n\t\t\telse result++;\n\t\t}\n\t}\n\treturn result;\n}\n```\nTC : $O(n)$\nSC : $O(n)$\n\n\n","lastmodified":"2024-07-04T20:24:17.037181919Z","tags":["dsadeck","strings"]},"/dsa/Count-Palindromic-Subsequences":{"title":"Count Palindromic Subsequences","content":"\n## Problem Statement\n\n\nPattern: \n\n---\n\n## Solution\n``` java\nlong MOD = (long) Math.pow(10,9) + 7;\nLong[][] cache;\n\n\nlong dp (char[] str, int l, int r) {\n\tif (l \u003e r) return 0;\n\tif (l == r) return 1;\n\tif (cache[l][r] != null) return cache[l][r];\n\t\n\tif(str[l] == str[r]) \n\t\treturn cache[l][r] = (dp(str, l+1, r) % MOD + dp(str, l, r-1) % MOD + 1) % MOD;\n\treturn cache[l][r] = (dp(str, l+1, r) % MOD + dp(str, l, r-1) % MOD - dp(str, l+1, r-1) % MOD) % MOD;\n}\n\nlong countPS(String str)\n{\n\tcache = new Long[str.length()+1][str.length()+1];\n\tlong ans = dp(str.toCharArray(), 0, str.length()-1);\n\treturn ans \u003c 0 ? ans + MOD : ans;\n}\n```\nTC :  $n^2$\nSC : $n^2$\n\n### Notes\n- [DP C++ Clear solution explained - LeetCode Discuss](https://leetcode.com/problems/count-different-palindromic-subsequences/discuss/272297/DP-C%2B%2B-Clear-solution-explained)\n\n\n## Distinct Palindromic Subsequences (HARD)\n[Count Different Palindromic Subsequences - LeetCode](https://leetcode.com/problems/count-different-palindromic-subsequences/)\n[Working of the solution](https://leetcode.com/problems/count-different-palindromic-subsequences/discuss/272297/DP-C++-Clear-solution-explained/952331)\n\n\n","lastmodified":"2024-07-04T20:24:17.037181919Z","tags":["dsadeck","strings"]},"/dsa/Count-and-Sum-of-Nodes":{"title":"Count and Sum of Nodes","content":"\n## Problem Statement\n\n\nPattern: \n\n---\n\n## Solution\n``` java\n// Count Nodes O(n)\npublic static int countNodes (Node root) {\n\tif(root == null) return 0;\n\t\n\tint left = countNodes(root.left);\n\tint right = countNodes(root.right);\n\t\n\treturn right + left + 1;\n}\n\n// Sum Nodes O(n)\npublic static int sumNodes (Node root) {\n\tif(root == null) return 0;\n\t\n\tint leftSum = sumNodes(root.left);\n\tint rightSum = sumNodes(root.right);\n\t\n\treturn leftSum + rightSum + root.val;\n}\n```\n\n### Notes\n- ","lastmodified":"2024-07-04T20:24:17.037181919Z","tags":["dsadeck","binarytrees"]},"/dsa/Count-of-Subsets-witth-given-Sum":{"title":"Count of Subsets witth given Sum","content":"\n\n## Problem Statement\n[Count of subsets with sum equal to X - GeeksforGeeks](https://www.geeksforgeeks.org/count-of-subsets-with-sum-equal-to-x/)\n\nPattern: \n\n---\n\n## Brute Force Solution\n``` java\npublic int count (int[] nums, int n, int target){\n\tif(n \u003c 0) return target == 0 ? 1 : 0;\n\tif(target == 0) return 1;\n\t\n\tif(nums[n] \u003c= target)\n\t\treturn count(nums, n-1, target-nums[n]) +\n\t\t\t   count(nums, n-1, target);\n\treturn count(nums, n-1, target);\n}\n```\nTC : $2^n$\nSC : $2^n$\n\n## Memoised\n``` java\npublic static Integer[][] dp;\npublic int count(int[] nums, int n, int target) {\n\tif (n \u003c 0) return target == 0 ? 1 : 0;\n\tif (target == 0) return 1;\n\tif (dp[n][target] != null) return dp[n][target];\n\tif (nums[n] \u003c= target)\n\t\treturn dp[n][target] = count(nums, n - 1, target - nums[n]) +\n\t\t\t\t\t\t\t   count(nums, n - 1, target);\n\treturn dp[n][target] = count(nums, n - 1, target);\n}\n```\n\n## Iterative\n``` java\npublic int count(int[] nums, int n, int k) {\n\t// init dp\n\tfor (int i = 0, j=0; i \u003c n + 1; i++) dp[i][j] = 1;\n\tfor (int j = 1, i = 0; j \u003c k + 1; j++) dp[i][j] = 0;\n\t\n\tfor (int i = 1; i \u003c n + 1; i++) \n\t\tfor (int j = 1; j \u003c k + 1; j++) \n\t\t\tif (nums[i-1] \u003c= j) \n\t\t\t\tdp[i][j] = dp[i - 1] [j - nums[i-1]] + dp[i - 1][j];\n\t\t\telse dp[i][j] = dp[i - 1][j];\n\t\t\n\treturn dp[n][k];\n}\n```\n\nunderstand iterative.. maybe\n```\ncount of subsets considering curr (ith) element of value upto j = \n\tcount of subset upto i-th element having value complement to curr value\n\t (because u can add curr element to all of them to reach j) \n\t+\n\tcount of subsets upto ith element having value upto j\n```\n","lastmodified":"2024-07-04T20:24:17.037181919Z","tags":["dsadeck","dp"]},"/dsa/Count-the-Reversals":{"title":"Count the Reversals","content":"\n## Problem Statement\n\n\nPattern: \nRelated:  [[1963. Minimum Number of Swaps to Make the String Balanced]]\n\n---\n\n## Solution\n``` java\nint countRev (String s)\n{\n\t// your code here     \n\tDeque\u003cCharacter\u003e stack = new LinkedList\u003c\u003e();\n\tint rev = 0;\n\t\n\tfor(char ch : s.toCharArray()) \n\t\tif(ch == '{') stack.push(ch);\n\t\telse {\n\t\t\tif(stack.isEmpty()) {\n\t\t\t\tstack.push('{');\n\t\t\t\trev++;\n\t\t\t}\n\t\t\telse stack.pop();\n\t\t}\n\t\n\t\n\tif(!stack.isEmpty()) \n\t\tif(stack.size() % 2 == 0) rev = rev + stack.size() / 2;\n\t\telse return -1;\n\t\n\treturn rev;\n}\n```\nTC : $O(n)$\nSC : $O(n)$\n\n### Notes\n\n## Optimal Solution\nWe don't really need to store the brackets in the stack, we could instead simply maintain a counter like so.\n``` java\nint countRev(String s) {\n\t// your code here     \n\tint stackSize = 0, rev = 0;        // reversal count\n\n\tfor (int i = 0 ; i \u003c s.length() ; i++)\n\t\tif(s.charAt(i) == '[') stackSize++;\n\t\telse {\n\t\t\tif(stackSize == 0) {\n\t\t\t\tstackSize++;\n\t\t\t\trev++;\n\t\t\t}\n\t\t\telse stackSize--;\n\t\t}\n\n\t// if unbalanced brackets left\n\tif(stackSize != 0) \n\t\tif(stackSize % 2 == 0) rev = rev + stackSize / 2;\n\t\telse return -1;\n\t\n\treturn rev;\n}\n```\n\nRelated  : [[1963.Â Minimum Number of Swaps to Make the String Balanced]]\n\n\n\n","lastmodified":"2024-07-04T20:24:17.037181919Z","tags":["dsadeck","strings"]},"/dsa/Delete-Nodes-With-Greater-Value-on-Right":{"title":"Delete Nodes With Greater Value on Right","content":"\n## Problem Statement\n\n\nPattern: \n\n---\n\n## Solution\n``` java\nNode compute(Node head)\n{\n\t// your code here\n\tif(head == null || head.next == null) return head;\n\tNode nextValid = compute(head.next);\n\t\n\tif(nextValid.data \u003e head.data) return nextValid;\n\t\n\thead.next = nextValid;\n\treturn head;\n}\n```\n\n## Notes\nBasically going from end to start\nmake sure the next element is greater than the current element, else drop it.\n\nAnother way to do this could be to reverse the LL\nand only add the next element if it is greater than the current element\n\n``` java\nNode compute (Node head) {\n\tNode revHead = reverse(head), rev = revHead, rh = revHead;\n\twhile(rev.next!=null) {\n\t\tif(rev.next.data \u003e= rh.data) {\n\t\t\trh.next = rev.next;\n\t\t\trh = rh.next;\n\t\t}\n\t\trev = rev.next;\n\t}\n\trh.next = null;\n\t\n\treturn reverse(revHead);\n}\n```\n\n`rh` is basically the leading pointer of sorted ascending list\n\n\n","lastmodified":"2024-07-04T20:24:17.037181919Z","tags":["dsadeck","linkedlist"]},"/dsa/Diagonal-Traversal-of-BT":{"title":"Diagonal Traversal of BT","content":"\n## Problem Statement\n[Diagonal Traversal | Interviewbit](https://www.interviewbit.com/problems/diagonal-traversal/)\n\n\nPattern: [[Pattern Binary Tree Axis]]\n\n---\n\n## Solution\n``` java\nclass AxisNode {\n\tint axis;\n\tTreeNode node;\n\t\n\tAxisNode(int axis, TreeNode node) {\n\t\tthis.axis = axis;\n\t\tthis.node = node;\n\t}\n}\n\npublic void diagonalTraversal (TreeNode root, int axis, TreeMap\u003cInteger, LinkedList\u003cInteger\u003e\u003e axesMap) {\n\tif(root == null) return;\n\t\n\tif (!axesMap.containsKey(axis)) \n\t\taxesMap.put(axis, new LinkedList\u003c\u003e());\n\taxesMap.get(axis).add(root.val);\n\t\n\tif(root.left != null) diagonalTraversal(root.left, axis +1, axesMap);\n\tif(root.right != null) diagonalTraversal(root.right, axis, axesMap);\n}\n\npublic int[] traverse(TreeNode root) {\n\tif (root == null) return new int[0];  // return empty arr\n\t\n\tTreeMap\u003cInteger, LinkedList\u003cInteger\u003e\u003e axesMap = new TreeMap\u003c\u003e();\n\tdiagonalTraversal(root, 0, axesMap);\n\t\n\t// convert map to arraylist\n\tArrayList\u003cInteger\u003e res = new ArrayList\u003c\u003e();\n\tfor(LinkedList\u003cInteger\u003e list : axesMap.values())\n\t\tfor(Integer val : list)\n\t\t\tres.add(val);        \n\t\n\t// convert arraylist to arr and return\n\treturn res.stream().mapToInt(i -\u003e i).toArray();\n}\n\npublic int[] solve(TreeNode A) {\n\treturn traverse(A);\n}\n```\n\n### Notes\n- Fundamental Idea : builds on [[Vertical Traversal of BT]] \n\t- except in this case, axis is along the right diagonal\n\t- so everytime you go right, you are travelling along the same axis\n\t- everytime you go left, your axis gets incremented by 1\n- Better Solution could have been an iterative one\n\n","lastmodified":"2024-07-04T20:24:17.037181919Z","tags":["dsadeck","binarytrees"]},"/dsa/Diameter-of-a-Tree":{"title":"Diameter of a Tree","content":"\n## Problem Statement\n\n\nPattern: \nRelated: [[Balance Binary Tree]]\n\n---\n\n## Solution O(N^2)\n``` java\npublic static int diameter (Node root) {\n\tif(root == null) return 0;\n\t\n\t// recurse for left and right\n\tint diaLeft = diameter(root.left);\n\tint diaRight = diameter(root.right);\n\t\n\t// calculate diameter for current node\n\tint diaRoot = height(root.left) + height (root.right) + 1;\n\t\n\t// return max dia in current subtree\n\treturn Math.max(diaRoot, Math.max(diaLeft, diaRight));\n}\n```\n\n### Notes\n- Diamter at a certain `root` is given by  `diaRoot = height(root.left) + height (root.right) + 1`.\n\t- Recruse all the way down\n\t- Calculate that for all nodes, and keep returning max.\n\n## Solution O(N)\n``` java\nstatic class HD {\n\tpublic int height;\n\tpublic int maxDia;\n\t\n\tHD(int height, int dia) {\n\t\tthis.height = height;\n\t\tthis.maxDia = dia;\n\t}\n}\n\nprivate static HD heightDiameter(Node root) {\n\tif(root == null) return new HD (0, 0);\n\t\n\t// find left and right height \u0026 diameter\n\tHD leftHD = heightDiameter(root.left);\n\tHD rightHD = heightDiameter(root.right);\n\t\n\t// calculate curr height and maxDia\n\tint height = Math.max(leftHD.height, rightHD.height) + 1;                   // calc height\n\tint rootDia = leftHD.height + rightHD.height + 1;                           // calc rootDia\n\tint maxDia = Math.max(rootDia, Math.max(leftHD.maxDia, rightHD.maxDia));    // calc maxDia\n\t\n\treturn new HD(height, maxDia);\n}\npublic static int diameter (Node root) {return heightDiameter(root).maxDia;}\n```\n\nThe solution above this is O(N^2) only because we calculate `height` which is a O(n) operation, if we instead, tracked height as we updated diameter, the complexity would be reduced to linear time complexity.\n\nSo in short we need to return both max `height` and max `dia`. as we recurse our way back up the binary tree\n\n","lastmodified":"2024-07-04T20:24:17.037181919Z","tags":["dsadeck","binarytrees"]},"/dsa/Dynamic-Programming":{"title":"Dynamic Programming","content":"\n## Knapsack\n- ~~Fractional~~ \n-  Unbouned\n- [[01 Knapsack]]\n\n","lastmodified":"2024-07-04T20:24:17.037181919Z","tags":[]},"/dsa/Edit-Distance":{"title":"Edit Distance","content":"\n## Problem Statement\n\n\nPattern: \nRelated: [[1143. Longest Common Subsequence]]\n\n---\n\n## Solution\n``` java\nInteger[][] cache;\n\nint dp(char[] edit, char[] target, int n1, int n2) {\n\t// base condition\n\tif (n1 \u003c 0 || n2 \u003c 0) return (n1 \u003e= n2) ? n1 + 1 : n2 + 1;\n\tif(cache[n1][n2] != null) return cache[n1][n2];\n\n\t// same character\n\tif (edit[n1] == target[n2]) return cache[n1][n2] = dp(edit, target, n1 - 1, n2 - 1);\n\n\n\tint replace = dp(edit, target, n1 - 1, n2 - 1) + 1;\n\tint insert = dp(edit, target, n1, n2 - 1) + 1;\n\tint delete = dp(edit, target, n1 - 1, n2) + 1;\n\n\treturn cache[n1][n2] = Math.min(replace, Math.min(insert, delete));\n}\n\n\npublic int minDistance(String word1, String word2) {\n\tchar[] edit = word1.toCharArray();\n\tchar[] target = word2.toCharArray();\n\tcache = new Integer[edit.length + 1][target.length + 1];\n\treturn dp(edit, target, edit.length - 1, target.length - 1);\n}\n```\nTC : $n1 * n2$\nSC : $n1 * n2$\n\n### Notes\nWe have 2 strings, `edit`, we pick anyone that we will transform, and `target`, the other one we transfer into. If we, \n- Shift pointers of both fwd\n\t- add 1 to the solution -\u003e character has been replace\n\n### Relevant\nDifferent types of edit distance allow different sets of string operations. For instance:\n-   TheÂ [Levenshtein distance](https://en.wikipedia.org/wiki/Levenshtein_distance \"Levenshtein distance\")Â allows deletion, insertion and substitution.\n-   TheÂ [longest common subsequence](https://en.wikipedia.org/wiki/Longest_common_subsequence \"Longest common subsequence\")Â (LCS) distance allows only insertion and deletion, not substitution.\n-   TheÂ [Hamming distance](https://en.wikipedia.org/wiki/Hamming_distance \"Hamming distance\")Â allows only substitution, hence, it only applies to strings of the same length.\n-   TheÂ [DamerauâLevenshtein distance](https://en.wikipedia.org/wiki/Damerau%E2%80%93Levenshtein_distance \"DamerauâLevenshtein distance\")Â allows insertion, deletion, substitution, and theÂ [transposition](https://en.wikipedia.org/wiki/Transposition_(mathematics) \"Transposition (mathematics)\")Â of two adjacent characters.\n-   TheÂ [Jaro distance](https://en.wikipedia.org/wiki/Jaro_distance \"Jaro distance\")Â allows onlyÂ [transposition](https://en.wikipedia.org/wiki/Transposition_(mathematics) \"Transposition (mathematics)\").\n\nTheÂ [Levenshtein distance](https://en.wikipedia.org/wiki/Levenshtein_distance \"Levenshtein distance\")Â between \"kitten\" and \"sitting\" is 3. A minimal edit script that transforms the former into the latter is:\n1.  **k**itten âÂ **s**itten (substitute \"s\" for \"k\")\n2.  sitt**e**n â sitt**i**n (substitute \"i\" for \"e\")\n3.  sittin â sittin**g**Â (insert \"g\" at the end)\n\nLCS distance (insertions and deletions only) gives a different distance and minimal edit script:\n1.  **k**itten â itten (delete \"k\" at 0)\n2.  itten âÂ **s**itten (insert \"s\" at 0)\n3.  sitt**e**n â sittn (delete \"e\" at 4)\n4.  sittn â sitt**i**n (insert \"i\" at 4)\n5.  sittin â sittin**g**Â (insert \"g\" at 6)\n\nfor a total cost/distance of 5 operations.","lastmodified":"2024-07-04T20:24:17.037181919Z","tags":["dsadeck","strings"]},"/dsa/FInd-String-in-Grid":{"title":"FInd String in Grid","content":"\n## Problem Statement\n\n\nPattern: \n\n---\n\n## Solution\n``` java\npublic int[][] searchWord(char[][] grid, String word)\n{\n\t// Code here\n\tint [] x = new int[] {0, 1, 1, 1, 0, -1, -1, -1};\n\tint [] y = new int[] {1, 1, 0, -1, -1, -1, 0, 1};\n\t\n\tint n = grid.length, m = grid[0].length, len = word.length();\n\tArrayList\u003cInteger[]\u003e res = new ArrayList\u003c\u003e();\n\t\n\tfor (int i = 0 ; i \u003c n ; i++ ) {\n\t\tfor(int j = 0 ; j \u003c m ; j++) {\n\t\t\t// for each cell, traverse 8 directions\n\t\t\tfor(int dir = 0 ; dir \u003c 8 ; dir++) {\n\t\t\t\tint r = i, c = j, idx = 0;\n\t\t\t\twhile (idx \u003c len \u0026\u0026 r \u003e -1 \u0026\u0026 r \u003c n \u0026\u0026 c \u003e -1 \u0026\u0026 c \u003c m) {\n\t\t\t\t\tif(word.charAt(idx) != grid[r][c]) break;\n\t\t\t\t\tr += x[dir]; c += y[dir]; idx++;\n\t\t\t\t}\n\t\t\t\tif(idx == len) res.add(new Integer[] {i, j});\n\t\t\t}\n\t\t}\n\t}\n\t// convert to int[][]\n\tint [][] result = new int[res.size()][2];\n\tint i = 0;\n\tfor(Integer[] pair : res) {\n\t\tresult[i][0] = pair[0];\n\t\tresult[i][1] = pair[1];\n\t\ti++;\n\t}\n\treturn result;\n}\n```\nTC : $O(n*m*len)$\nSC : $O(1)$\n\n### Notes\n- for every cell, traverse all 8 directions and if theres a match add it to result\n\n\n\n\n","lastmodified":"2024-07-04T20:24:17.037181919Z","tags":["dsadeck","strings"]},"/dsa/First-Non-Repeating-Character-in-Stream":{"title":"First Non Repeating Character in Stream","content":"\n## Problem Statement\n\n\nPattern:\n\n---\n\n## Solution\n``` java\npublic String FirstNonRepeating (String str){\n\tint[] vis = new int[26];\n\tLinkedList\u003cCharacter\u003e q = new LinkedList\u003c\u003e();\n\tStringBuilder res = new StringBuilder();\n\t\n\tfor(int i = 0; i \u003c str.length() ; i++) {\n\t\tchar ch = str.charAt(i);\n\t\t\n\t\t// update first-non-repeating q \u0026 visited arr\n\t\tif(vis[ch-'a'] \u003c 1) q.addLast(ch);\n\t\tvis[ch - 'a']++;\n\t\t\n\t\t// remove q head if it has been repeated\n\t\twhile(!q.isEmpty() \u0026\u0026 vis[q.peekFirst() - 'a'] \u003e 1) q.remove();\n\t\t\n\t\t// append answer\n\t\tres.append(q.isEmpty() ? '#' : q.peekFirst());\n\t}\n\t\n\treturn res.toString();\n}\n```\n\n### Notes\n- \n\n","lastmodified":"2024-07-04T20:24:17.037181919Z","tags":["dsadeck","linkedlist","strings"]},"/dsa/First-Repeating-Element":{"title":"First Repeating Element","content":"\n## Problem Statement\n\n\nPattern: [[Frequency]]\n\n---\n\n## Solution\n``` java\nclass Solution {\n    // freqArr approach\n    public static int firstRepeated (int[] arr, int n){\n        int[] freqArr = new int[1_000_000];\n        Arrays.fill(freqArr, -1);\n        int minIdx = Integer.MAX_VALUE;\n        \n        for (int i = 0; i \u003c n; i++) {\n            int val = arr[i];\n            // val is being repeated\n            if(freqArr[val] != -1)\n                minIdx = Math.min(minIdx, freqArr[val]); // update minIdx\n            freqArr[val] = i;\n        }\n        // if minIdx unchanged\n        if(minIdx == Integer.MAX_VALUE) return -1;\n        \n        return minIdx+1; // 1-based indexing\n    }\n    \n    // hashMap\n    public static int firstRepeated2 (int[] arr, int n){\n        HashMap\u003cInteger, Integer\u003e hm = new HashMap\u003c\u003e();\n        int minIdx = Integer.MAX_VALUE;\n        for (int i = 0; i \u003c n; i++) {\n            int val = arr[i];\n            if(hm.containsKey(val))\n                minIdx = Math.min(hm.get(val), minIdx);\n            hm.put(val, i);\n        }\n        if(minIdx == Integer.MAX_VALUE) return -1;\n        return minIdx+1;\n    }\n}\n```\n\n### Notes\n- \n\n","lastmodified":"2024-07-04T20:24:17.037181919Z","tags":["easy","arrays","completed","hashmap","dsadeck"]},"/dsa/Flatten-Binary-Tree-to-LL":{"title":"Flatten Binary Tree to LL","content":"\n## Problem Statement\n\n\nPattern: [[Pattern Binary Tree Traversal]]\n\n---\n\n## Solution\n``` java\nTreeNode prev = null;\n\n// right-first postorder\npublic void postorder (TreeNode root) {\n\tif(root == null) return;\n\t\n\tpostorder(root.right);\n\tpostorder(root.left);\n\t\n\troot.right = prev;\n\troot.left = null;\n\tprev = root;\n\t\n}\n\npublic void flatten(TreeNode root) { postorder(root); }\n```\n\n### Notes\n![](https://i.imgur.com/CgC09iL.png)\n\nTo make it easier, jus think of a single node and its left and right, so for  the binary tree `1, 2, 5` LL would be `1 -\u003e 2 -\u003e 5`\n- we have to get a linked list in the order `node -\u003e left -\u003e right`\n- we could preorder traverse, and point prev node `prev.right` to the curr node, but then we would lose original `prev.right` that was yet to be traversed\n\t- if `1 -\u003e 2` then 5 would get lost\n- so we traverse preorder-reverse `right -\u003e left -\u003e node` and for each node `node.right = prev` and `prev = node`, where initially `prev = null`\n- this way we can form a LL in reverse\n","lastmodified":"2024-07-04T20:24:17.037181919Z","tags":["dsadeck","binarytrees"]},"/dsa/Flatten-a-BST":{"title":"Flatten a BST","content":"\n## Problem Statement\n[Flatten BST To A Sorted List (codingninjas.com)](https://www.codingninjas.com/codestudio/problems/flatten-bst-to-a-sorted-list_1169459?)\n\nPattern: \n\n---\n\n## Trivial Solution #1\nCreate an Inorder `Queue\u003cNode\u003e`, then iterate over it and reorder the BST, something like [[1382. Balance a Binary Search Tree]]\n\n\n## Trivial Solution #2 \nCreate a `second` linkedlist while taversing inorder\n``` java\nstatic TreeNode\u003cInteger\u003e inorder(TreeNode\u003cInteger\u003e root, TreeNode\u003cInteger\u003e second) {\n\tif(root == null) return second;\n\t\n\tsecond = inorder(root.left, second);\n\tsecond.right = new TreeNode\u003cInteger\u003e(root.data); second = second.right;\n\tsecond = inorder(root.right, second);\n\t\n\treturn second;\n}\n\npublic static TreeNode\u003cInteger\u003e flatten(TreeNode\u003cInteger\u003e root)\n{\n\tTreeNode second = new TreeNode\u003cInteger\u003e(-1);\n\tinorder(root, second);\n\treturn second.right;\n}\n```\nTC : ` O(n) `\nSC : ` O(n) + O(h) - stack \n\n## Optimal Solution\nSimilar to  [[Flatten Binary Tree to LL]]\n``` java\nTreeNode prev = null;\n\n// reverse inorder traverse\nprivate TreeNode flatten(TreeNode root) {\n\tif (root == null) return prev;\n\t\n\tflatten(root.right);\n\troot.right = prev; prev = root;\n\tflatten(root.left);\n\troot.left = null;\n\t\n\treturn prev;\n}\n```\n\nTC : ` O(n) `\nSC : ` O(h) - stack \n\n### Notes\n- We essnetially traverse reverse inorder, and track the `prev` node visited, and keep returning, it. point `node.right = prev` and `node.left = null` after `flatten(root.left)`\n\n","lastmodified":"2024-07-04T20:24:17.037181919Z","tags":["dsadeck","bst"]},"/dsa/Flatten-a-Linked-List":{"title":"Flatten a Linked List","content":"\n## Problem Statement\n\n\nPattern: \nRelated: [[23. Merge k Sorted Lists]] \n\n---\n\n## Solution PriorityQueue\nThis is technically a O(1) space solution, since we take the contraint `(N*M) \u003c=100`\n\n``` java\nNode flatten(Node root)\n{\n// Your code here\n\tNode x = root, y = x;\n\tPriorityQueue\u003cNode\u003e pq = new PriorityQueue\u003c\u003e(101, (n1, n2) -\u003e n1.data-n2.data);\n\twhile(x!=null){\n\t\ty = x;\n\t\twhile(y!=null) {\n\t\t\tpq.add(y);\n\t\t\ty = y.bottom;\n\t\t}\n\t\tx = x.next;\n\t}\n\tNode newRoot = new Node(-1), curr = newRoot;\n\twhile(!pq.isEmpty()) {\n\t\tcurr.bottom = pq.remove();\n\t\tcurr.bottom.next = null;\n\t\tcurr.bottom.bottom = null;\n\t\tcurr = curr.bottom;\n\t}\n\t\n\treturn newRoot.bottom;\n  }  \n```\n\n### Notes\n\n\n## Merge Sort Solution\n``` java\nNode merge(Node a, Node b) {\n\tif(a == null) return b;\n\tif(b == null) return a;\n\t\n\tNode smaller, larger;\n\t\n\tsmaller = (a.data \u003c= b.data) ? a : b;\n\tlarger = (b.data \u003e= a.data) ? b : a;\n\t\n\tsmaller.bottom = merge(smaller.bottom, larger);\n\t\n\tsmaller.next = null;\n\treturn smaller;\n}\n\nNode flatten(Node root)\n{\n\t// Your code here\n\tif(root == null || root.next == null) return root;\n\t\n\troot.next = flatten(root.next);\n\t\n\troot = merge(root, root.next);\n\t\n\treturn root;\n}  \n```\n\u003c% tp.file.cursor(2) %\u003e\n\n","lastmodified":"2024-07-04T20:24:17.037181919Z","tags":["dsadeck","linkedlist"]},"/dsa/GFG-Add-1-to-Linked-List":{"title":"GFG Add 1 to Linked List","content":"\n## Problem Statement\n[Add 1 to a number represented as linked list | Practice | GeeksforGeeks](https://practice.geeksforgeeks.org/problems/add-1-to-a-number-represented-as-linked-list/1#)\n\nPattern: \n\n---\n\n## Recursive Solution\n``` java\npublic ListNode addOne (ListNode head)\n{\n\t// exit condition - last element\n\tif(head.next == null) {\n\t\thead.val++;             // if 9 it will become 10\n\t\treturn head;\n\t}\n\t\n\t// recursive call\n\taddOne(head.next);\n\t\n\t// WAY UP\n\tif(head.next.val == 10) {   // if next is 10\n\t\thead.next.val = 0;      // set next to 0\n\t\thead.val++;             // increment current\n\t}\n\treturn head;\n}\n```\n\n### Notes\n- go down to the last element, increment by 1 and return it\n- for every element on the way up\n\t- check if the next element is 10\n\t\t- if it is set it to 0, and increment current element by 1\n- **Disadvantage**: if all `9`s in array the first element becomes `10` and not an extra `1` followed by a `0`\n\n## Iterative Reverse Approach\n``` java\npublic ListNode reverse(ListNode head) {\n\tif(head == null || head.next == null) return head;  // returns last node\n\t\n\tListNode last = reverse(head.next);\n\thead.next.next = head;\n\thead.next = null;\n\t\n\treturn last;\n}\n\npublic ListNode addOneReverse(ListNode head){\n\tListNode revHead = reverse(head) , node = revHead;\n\twhile(node != null) {\n\t\tif(node.val \u003c 9) { // node not 9\n\t\t\tnode.val++;\n\t\t\tbreak;\n\t\t}\n\t\telse {              // node is 9\n\t\t\tnode.val = 0;\n\t\t\tif(node.next == null) { // last node\n\t\t\t\tnode.next = new ListNode(1);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tnode = node.next;\n\t}\n\treturn reverse(revHead);\n}\n```\n\nInspired the array problem to [Plus One](https://leetcode.com/problems/plus-one/discuss/24082/My-Simple-Java-Solution)\n**Disadvantage:**\n-  2 extra traversals, to reverse and unreverse array\n**Advantage**\n- If all 9's in array, the first element is `1` and not `10`","lastmodified":"2024-07-04T20:24:17.037181919Z","tags":["dsadeck","linkedlist"]},"/dsa/GFG-Boundary-Traversal-of-BT":{"title":"GFG Boundary Traversal of BT","content":"\n## Problem Statement\n[Boundary Traversal of binary tree | Practice | GeeksforGeeks](https://practice.geeksforgeeks.org/problems/boundary-traversal-of-binary-tree/1)\nPattern: \n\n---\n\n## Solution\n``` java\nArrayList\u003cInteger\u003e res;\nprivate boolean isLeaf (Node node) {return node.left == null \u0026\u0026 node.right == null;}\n\nprivate void traverseLeft(Node root) {\n\tif (root == null || isLeaf(root)) return;\n\t\n\tres.add(root.data);  // add on way down\n\t\n\t// go left. cant? go right\n\tif (root.left != null) traverseLeft(root.left);\n\telse traverseLeft(root.right);\n}\n\nprivate void traverseRight(Node root) {\n\tif (root == null || isLeaf(root)) return;\n\t// go right. cant? go left\n\tif (root.right != null) traverseRight(root.right);\n\telse traverseRight(root.left);\n\t\n\tres.add(root.data);  // add on way up\n}\n\nprivate void traverseLeaf(Node root) {\n\tif(root == null) return;\n\t\n\t// leaf -\u003e add value\n\tif (isLeaf(root)) {\n\t\tres.add(root.data);\n\t\treturn;\n\t}\n\t\n\ttraverseLeaf(root.left);\n\ttraverseLeaf(root.right);\n}\n\npublic ArrayList\u003cInteger\u003e boundary(Node root) {\n\tres = new ArrayList\u003c\u003e();\n\tif(root == null) return res;\n\t\n\tres.add(root.data);\n\t\n\ttraverseLeft(root.left);        // traverse left boundary\n\tif(!isLeaf(root))               // check not leaf\n\t\ttraverseLeaf(root);         // traverse leaf nodes\n\ttraverseRight(root.right);      // traverse right boundary\n\t\n\treturn res;\n}\n\n```\n\n### Notes\n- traverse the right boundary on the way back up\n- when traverseLeaf check if root isnt a leaf, or else it will be duplicated\n\n\n","lastmodified":"2024-07-04T20:24:17.037181919Z","tags":["dsadeck","binarytrees"]},"/dsa/GFG-Check-if-Linked-List-is-Palindrome":{"title":"GFG Check if Linked List is Palindrome","content":"\n## Problem Statement\n\n\nPattern: \n\n---\n\n## Solution\n``` java\npublic boolean isPalindrome (Node head){\n\tif(head.next == null) return true;\n\t\n\tNode mid = getMid(head);        // get floor of mid\n\tNode head2 = mid.next;      \t// get second head\n\t\n\tmid.next = null;                    // disconnect first LL\n\thead2 = reverse(head2);             // reverse second LL\n\t\n\t// Compare LLs\n\twhile(head != null \u0026\u0026 head2 != null) {\n\t\tif (head.data != head2.data) return false;\n\t\thead = head.next;\n\t\thead2 = head2.next;\n\t}\n\treturn true;\n}\n```\n\n**Helper Functions**\n``` java\npublic static Node getMid (Node head) {\n\tNode slow = head, fast = head;\n\tfast = fast.next; // increment fast to get floor of mid\n\t\n\twhile (fast!= null \u0026\u0026 fast.next!=null) {\n\t\tslow = slow.next;\n\t\tfast = fast.next.next;\n\t}\n\t// when fast / fast.next becomes null, slow would have reached floor of mid\n\treturn slow;\n}\n\npublic static Node reverse(Node head) {\n\tif(head == null || head.next == null) return head;  // returns last node\n\t\n\tNode last = reverse(head.next);\n\thead.next.next = head;\n\thead.next = null;\n\t\n\treturn last;\n}\n```\n\n### Notes\n- compare the first half of the array with the reverse of the second half\n\t- split list at mid\n\t- if list has odd number of elements, the left list will be one greater than the right list, but that shouldnt bother us, since we will only check , while both lists are not null. as soon as one list is null we stop checking.\n\n \n\n","lastmodified":"2024-07-04T20:24:17.037181919Z","tags":["dsadeck","linkedlist"]},"/dsa/GFG-Choclate-Distribution-Problem":{"title":"GFG Choclate Distribution Problem","content":"\n## Problem Statement\n\n\nPattern: [[Pattern Sliding Window]]\n\n---\n\n## Solution\n``` java\npublic long findMinDiff (ArrayList\u003cInteger\u003e nums, int n, int m)\n{\n\tCollections.sort(nums);\n\tint start = 0, end = start + m - 1;\n\tlong minDiff = Long.MAX_VALUE;\n\t\n\twhile(end \u003c n) {\n\t\tminDiff = Math.min(minDiff, (long) (nums.get(end) - nums.get(start)));\n\t\tend++; start++;\n\t}\n\t\n\treturn minDiff;\n}\n```\n\n### Notes\n- sort, sliding window.\n\n\n","lastmodified":"2024-07-04T20:24:17.037181919Z","tags":["dsadeck","arrays"]},"/dsa/GFG-Common-Elements":{"title":"GFG Common Elements","content":"\n## Problem Statement\n[Common elements | Practice | GeeksforGeeks](https://practice.geeksforgeeks.org/problems/common-elements1132/1#)\n![](https://i.imgur.com/KbqaL3l.png)\n\n\nPattern: \n\n---\n\n## Solution\n``` java\npublic ArrayList\u003cInteger\u003e commonElements(int[] A, int[] B, int[] C, int n1, int n2, int n3) {\n\tint i1 = 0, i2 = 0, i3 = 0;\n\tArrayList\u003cInteger\u003e res = new ArrayList\u003c\u003e();\n\twhile (i1 \u003c n1 \u0026\u0026 i2 \u003c n2 \u0026\u0026 i3 \u003c n3) {\n\t\tif (A[i1] \u003c B[i2]) i1++;\n\t\telse if (B[i2] \u003c C[i3]) i2++;\n\t\telse if (C[i3] \u003c A[i1]) i3++;\n\t\telse if (A[i1] == B[i2] \u0026\u0026 B[i2] == C[i3]) {\n\t\t\tif(res.size() == 0 || res.get(res.size()-1) != A[i1])   // if not duplicate\n\t\t\t\tres.add(A[i1]);\n\t\t\ti1++;i2++;i3++;\n\t\t}\n\t}\n\treturn res;\n}\n```\n\n### Notes\n- \n\n","lastmodified":"2024-07-04T20:24:17.037181919Z","tags":["dsadeck","arrays"]},"/dsa/GFG-Count-Inversions":{"title":"GFG Count Inversions","content":"\n## Problem Statement\n\n\nPattern: \n\n---\n\n## Solution\n``` java\npublic long merge(long[] nums, int start, int mid, int end) {\n\tlong[] t1 = Arrays.copyOfRange(nums, start, mid + 1);\n\tlong[] t2 = Arrays.copyOfRange(nums, mid + 1, end + 1);\n\t\n\tint i1 = 0, i2 = 0, i = start;\n\tlong invCount = 0;\n\twhile (i1 \u003c t1.length \u0026\u0026 i2 \u003c t2.length) {\n\t\tif (t2[i2] \u003c t1[i1]) {  // right subarr el is smaller\n\t\t\tnums[i++] = t2[i2++];\n\t\t\tinvCount += (t1.length - i1); // add no. of greater than elements in the left subarr\n\t\t} else {\n\t\t\tnums[i++] = t1[i1++];\n\t\t}\n\t}\n\t\n\t// copy leftover\n\twhile (i2 \u003c t2.length) nums[i++] = t2[i2++];\n\twhile (i1 \u003c t1.length) nums[i++] = t1[i1++];\n\t\n\treturn invCount;\n}\n\npublic long mergeSort(long[] nums, int start, int end) {\n\tif (start \u003e= end) return 0;\n\t\n\tint mid = start + (end - start) / 2;\n\tlong invCount = 0;\n\t\n\tinvCount += mergeSort(nums, start, mid);\n\tinvCount += mergeSort(nums, mid + 1, end);\n\t\n\tinvCount += merge(nums, start, mid, end);\n\t\n\treturn invCount;\n}\n\npublic long inversionCount(long[] arr, long N) {\n\treturn mergeSort(arr, 0, (int) N - 1);\n}\n```\n\n### Notes\n- Merge Sort with a twist\n- when `if (t2[i2] \u003c t1[i1])` is true, meaning the right subarrays element is smaller than the left subarrays element, it is also smaller than the remaining elements in the left subarray `t1.length-i1` , since both the subarrays are sorted\n\u003e [!Concept]\n\u003e For each smaller element in the right subarray we update how many is it smaller than (how many inversions can it form with the left subarray elements)\n\n","lastmodified":"2024-07-04T20:24:17.037181919Z","tags":["dsadeck","arrays"]},"/dsa/GFG-Detect-Loop":{"title":"GFG Detect Loop","content":"\n## Problem Statement\n\n\nPattern: \n\n---\n\n## Solution\n``` java\npublic static boolean detectLoop(Node head){\n\tNode slow = head, fast = head;\n\twhile(slow != null \u0026\u0026 fast != null \u0026\u0026 fast.next != null) {\n\t\tslow = slow.next;\n\t\tfast = fast.next.next;\n\t\tif(slow == fast) return true;\n\t}\n\treturn false;\n}\n```\n\n## How do we know fast and slow pointer meet\n**Floyds Algorithm**\n- When slow pointer enters the loop, the fast pointer must be inside the loop. Let fast pointer be distance k from slow.\n- Now if consider movements of slow and fast pointers, we can notice that distance between them (from slow to fast) increase by one after every iteration. After one iteration (of slow = next of slow and fast = next of next of fast), distance between slow and fast becomes k+1, after two iterations, k+2, and so on. **At some point, the distance will become k + n, and since the list is circular, they will coincide!!** \n\ncontinue on [[142.Â Linked List Cycle II]]\n","lastmodified":"2024-07-04T20:24:17.037181919Z","tags":["dsadeck","linkedlist"]},"/dsa/GFG-Factorials-of-large-numbers":{"title":"GFG Factorials of large numbers","content":"\n## Problem Statement\n\n\nPattern: \n\n---\n\n## Solution\n``` java\npublic ArrayList\u003cInteger\u003e factorial(int n) {\n\tArrayList\u003cInteger\u003e res = new ArrayList\u003c\u003e();\n\tres.add(1);\n\tfor (int fact = 2; fact \u003c= n; fact++) {\n\t\tint carry = 0;\n\t\tfor (int i = 0; i \u003c res.size(); i++) {\n\t\t\tint val = res.get(i) * fact + carry;    // calculate product\n\t\t\tres.set(i, val % 10);                   // set product's last digit at current index\n\t\t\tcarry = val/10;                         // remove last digit from carry\n\t\t}\n\t\twhile(carry \u003e 0) {                          // empty remaining carry into the array\n\t\t\tres.add(carry%10);\n\t\t\tcarry /= 10;\n\t\t}\n\t}\n\t// reverse n return\n\tCollections.reverse(res);\n\treturn res;\n}\n```\n\n### Notes\n- bascially how how we do mulitplication by hand, we start with the 1s place element , then make our way towards the biggest place element\n- here we do the same, by storing the result in reverse, that way as we iterate, we go from the 1s place element to the greater greater place elemen\n- we store carry in a `carry` variable, and use it to calculate the product, and only store the last element in the `res` array, remove that from the `carry`\n- finally if the result has reached the end, but theres still something left in `carry` we empty carry into the `res` array\n- rinse and repeat to multiply with the next number / `fact`\n\n","lastmodified":"2024-07-04T20:24:17.037181919Z","tags":["dsadeck","arrays","arithmetic"]},"/dsa/GFG-Intersection-of-Two-Sorted-LLs":{"title":"GFG Intersection of Two Sorted LLs","content":"\n## Problem Statement\n\n\nPattern: \n\n---\n\n## Solution\n``` java\npublic static Node findIntersection(Node head1, Node head2)\n{\n\tNode ans = new Node(-1), ansHead = ans;\n\t\n\twhile(head1 != null \u0026\u0026 head2 != null) {\n\t\tif(head1.data \u003c head2.data) head1 = head1.next;\n\t\telse if(head2.data \u003c head1.data) head2 = head2.next;\n\t\t\n\t\telse {  // head1 = head2\t\n\t\t\tif(head1.data \u003e ans.data) {\n\t\t\t\tans.next = new Node(head1.data);\n\t\t\t\tans = ans.next;\n\t\t\t}\n\t\t\thead1 = head1.next;\n\t\t\thead2 = head2.next;\n\t\t}\n\t}\n\treturn ansHead.next;\n}\n```\n\nMove the smaller pointer fwds, till one of them reaches null\nif both pointers are same, compare with last element in ans, if grgeater, insert\nmove both pointers fwds\n\n## Messier Set Solution\n\n``` java\npublic static Node findIntersection(Node head1, Node head2)\n{\n\t// code here.\n\tSet\u003cInteger\u003e set = new HashSet\u003cInteger\u003e();\n\twhile(head1 != null){\n\t\tset.add(head1.data);\n\t\thead1 = head1.next;\n\t}\n\t\n\tNode p2 = head2;\n\tSet\u003cInteger\u003e intersect = new HashSet\u003cInteger\u003e();\n\twhile(head2 != null) {\n\t\tif(set.contains(head2.data))\n\t\t\tintersect.add(head2.data);\n\t\thead2 = head2.next;\n\t}\n\t\n\tNode node = new Node(-1), nodeHead = node;\n\twhile(p2!=null) {\n\t\tif(intersect.contains(p2.data)) {\n\t\t\tnode.next = new Node(p2.data);\n\t\t\tintersect.remove(p2.data);\n\t\t\tnode = node.next;\n\t\t}\n\t\tp2 = p2.next;\n\t}\n\t\n\treturn nodeHead.next;\n}\n```\n","lastmodified":"2024-07-04T20:24:17.037181919Z","tags":["dsadeck","linkedlist"]},"/dsa/GFG-Kth-Largest-Subarray":{"title":"GFG Kth Largest Subarray","content":"\n\n## Problem Statement\n[K-th Largest Sum Contiguous Subarray | Practice | GeeksforGeeks](https://practice.geeksforgeeks.org/problems/k-th-largest-sum-contiguous-subarray/1/)\n\n\nPattern:[[Pattern Sliding Window]]\n\n---\n\n## Solution\n``` java\nstatic class Solution {\n\tpublic static int kthLargest(int N, int K, int[] Arr) {\n\t\tPriorityQueue\u003cInteger\u003e pq = new PriorityQueue\u003c\u003e(K);\n\t\tfor (int start = 0; start \u003c N; start++) {\n\t\t\tint currSum = 0;\n\t\t\tfor (int end = start; end \u003c N; end++) {\n\t\t\t\tcurrSum += Arr[end];\n\t\t\t\tif(pq.size() \u003c K) pq.add(currSum);\n\t\t\t\telse if (currSum \u003e= pq.element()) {\n\t\t\t\t\tpq.poll();\n\t\t\t\t\tpq.add(currSum);\n\t\t}   }   }\n\t\treturn pq.element();\n\t}\n}\n```\n\n### Notes\n- find all the subarray sums using `currSum`, and push them into a k-sized priorityQueue\n- Time: O(n^2logk) Extra Space: O(1)\n\n\n\n","lastmodified":"2024-07-04T20:24:17.037181919Z","tags":["dsadeck","arrays","completed","subarrays"]},"/dsa/GFG-Length-of-smallest-subarray-removed":{"title":"GFG Length of smallest subarray removed","content":"## Problem Statement\n[Length of smallest subarray to be removed to make sum of remaining elements divisible by K - GeeksforGeeks](https://www.geeksforgeeks.org/length-of-smallest-subarray-to-be-removed-to-make-sum-of-remaining-elements-divisible-by-k/)\n\n\nPattern: \n\n---\n\n## Solution\n``` java\n\n```\n\n### Notes\n- \n\n\n","lastmodified":"2024-07-04T20:24:17.037181919Z","tags":["hard","arrays","subarrays","incomplete"]},"/dsa/GFG-Longest-Subarray-having-Sum-K":{"title":"GFG Longest Subarray having Sum K","content":"\n## Problem Statement\n[Longest sub-array having sum k - GeeksforGeeks](https://www.geeksforgeeks.org/longest-sub-array-sum-k/)\n\nPattern: [[Pattern Prefix Array]]\n\n---\n\n## Solution\n``` java\nstatic int lenOfLongSubarr(int[] arr, int n, int k)\n{\n\t // HashMap to store (sum, index) tuples\n\t HashMap\u003cInteger, Integer\u003e map = new HashMap\u003c\u003e();\n\t int sum = 0, maxLen = 0;\n\n\t // traverse the given array\n\t for (int i = 0; i \u003c n; i++) {\n\t\t \n\t\t  // accumulate sum\n\t\t  sum += arr[i];\n\t\t \n\t\t  // when subarray starts from index '0'\n\t\t  if (sum == k)\n\t\t\t  maxLen = i + 1;\n\n\t\t  // make an entry for 'sum' if it is\n\t\t  // not present in 'map'\n\t\t  if (!map.containsKey(sum)) {\n\t\t\t  map.put(sum, i);\n\t\t  }\n\n\t\t  // check if 'sum-k' is present in 'map'\n\t\t  // or not\n\t\t  if (map.containsKey(sum - k)) {\n\t\t\t   \n\t\t\t  // update maxLength\n\t\t\t  if (maxLen \u003c (i - map.get(sum - k)))\n\t\t\t\t  maxLen = i - map.get(sum - k);\n\t\t  }\n\t }\n\t return maxLen;            \n}\n```\n\n### Notes\n- \n\nSimilar to : [[560. Subarray Sum Equals K]]\n","lastmodified":"2024-07-04T20:24:17.037181919Z","tags":["dsadeck","arrays"]},"/dsa/GFG-Maximum-Product-Subarray":{"title":"GFG Maximum Product Subarray","content":"\n## Problem Statement\n\n\nPattern: \n\n---\n\n## Solution\n``` java\npublic long maxProduct (int[] nums, int n){\n\tlong prefixProduct = 1, suffixProduct=1,  maxProduct = Long.MIN_VALUE;\n\t// prefixProduct fwds\n\tfor (int i = 0; i \u003c n; i++) {\n\t\tprefixProduct *= nums[i];\n\t\tif(prefixProduct == 0) prefixProduct =1;\n\t\tmaxProduct = Math.max(maxProduct, prefixProduct);\n\t}\n\n\t// suffixProduct reverse\n\tfor (int i = n-1; i \u003e= 0 ; i--) {\n\t\tsuffixProduct *= nums[i];\n\t\tif(suffixProduct == 0) suffixProduct = 1;\n\t\tmaxProduct = Math.max(maxProduct, suffixProduct);\n\t}\n\treturn maxProduct;\n}\n```\n\n### Notes\n- let's assume that there can only be a even number of negative integers.\n- then its simple kadane's algorithm, where we find the `runningProduct`,  update `maxProduct` as we do it, and reset `runningProduct` to `1` if it becomes `0`\n- the complication here is that there can be **odd number of negative integers** in the array, or any subarray between 2 zeroes\n\t- so the `maxProduct` could be discovered by removing the first negative integer or the last one\n\t- this is the only edge case that isnt being covered, but its present for every subarray, after a zero since the maxProduct uptill then gets reset\n\t- so the simple solution is to find the `maxProduct` once forwards using running `prefixProduct`, and once backwards using running `suffixProduct`.\n\t- and compare those 2\n\nthis can also be done in a single for loop\n\n``` java\n public long maxProduct (int[] nums, int n){\n\tlong prefixProduct = 1, suffixProduct=1,  maxProduct = Long.MIN_VALUE;\n\n\tfor (int i = 0; i \u003c n; i++) {\n\t\tprefixProduct *= nums[i];\n\t\tsuffixProduct *= nums[n - (i+1)];\n\t\t\n\t\t// update maxProduct first, in case all elements are zeroes\n\t\tmaxProduct = Math.max(maxProduct, Math.max(prefixProduct, suffixProduct));\n\t\t\n\t\tif(prefixProduct == 0) prefixProduct =1;\n\t\tif(suffixProduct == 0) suffixProduct =1;\n\t}\n\t\n\treturn maxProduct;\n}\n```\n\nonly twist here is that to find the corresponding **reverse pointer** we use `n - (i+1)`\n\n\n\n","lastmodified":"2024-07-04T20:24:17.037181919Z","tags":["dsadeck","arrays","subarrays"]},"/dsa/GFG-Median-of-2-Sorted-Arrays-of-Same-Size":{"title":"GFG Median of 2 Sorted Arrays of Same Size","content":"\n## Problem Statement\n\n\nPattern: \nRelated: [[4. Median of Two Sorted Arrays]]\n\n---\n\n## Solution\n``` java\npublic int getMedian (int[] nums1, int[] nums2){\n\tint i1 = 0, i2 = 0, n = nums1.length;\n\tint p1 = 0, p2 = 0; // prev state of i1 and i2, before termination condition is reached\n\twhile(i1 \u003c n \u0026\u0026 i2 \u003c n \u0026\u0026 i1 + i2 \u003c n) {\n\t\tp1 = i1 ; p2 = i2;\n\t\tif(nums1[i1] \u003c nums2[i2]) i1++;\n\t\telse if(nums2[i2] \u003c nums1[i1]) i2++;\n\t\telse i1++;\n\t}\n\treturn (nums1[p1] + nums2[p2]) / 2;\n}\n```\n\n### Notes\n- O(n) solution\n- For an O(log(min(n, m))) solution for all sizes of arrays. checkout: [[4. Median of Two Sorted Arrays]] \n- ","lastmodified":"2024-07-04T20:24:17.037181919Z","tags":["dsadeck","arrays","mergesort"]},"/dsa/GFG-Merge-Without-Extra-Space":{"title":"GFG Merge Without Extra Space","content":"## Problem Statement\nGiven two sorted arrays arr1[]Â of size N and arr2[]Â of size M. Each array is sorted in non-decreasing order. Merge the twoÂ arrays into one sorted array in non-decreasing order without using any extra space.\n\nPattern: [[Pattern 2 values in 1 variable]]\n\n---\n\n## Gap Solution\nAlso the Shell Sort intuition \n- [Maximum Subarray Sum | Leetcode | Kadane's Algorithm | Brute-Better-Optimal | CPP/Java - YouTube](https://www.youtube.com/watch?v=w_KEocd__20)\n- [Efficiently merging two sorted arrays with O(1) extra space - GeeksforGeeks](https://www.geeksforgeeks.org/efficiently-merging-two-sorted-arrays-with-o1-extra-space/)\n`O(mlogm + nlogn)`\n\n``` java\n\n```\n\n### Notes\n- \n\n\n","lastmodified":"2024-07-04T20:24:17.037181919Z","tags":["dsadeck","arrays"]},"/dsa/GFG-Merge-k-Sorted-Arrays":{"title":"GFG Merge k Sorted Arrays","content":"\n## Problem Statement\n\n\nPattern: \n\n---\n\n## Solution\n``` java\npublic class Node {  \n   int index;  \n   int[] arr;  \n   Node (int index, int[] arr) {  \n      this.index = index;  \n      this.arr =  arr;  \n   }  \n}  \n  \npublic ArrayList\u003cInteger\u003e mergeKArrays (int[][] arr, int K){\n\t// priority that compares the element at current index of arr\n\tPriorityQueue\u003cNode\u003e pq = \n\t\tnew PriorityQueue\u003cNode\u003e(Comparator.comparingInt((Node n) -\u003e n.arr[n.index]));\n\tint len=0;\n\t// traverse arr to and add to priority queue nodes\n\tfor (int[] subArr : arr) {\n\t\t// update length\n\t\tlen+=subArr.length;\n\t\t// create node for subarray\n\t\tNode node = new Node(0, subArr);\n\t\t// add node to PQ\n\t\tpq.add(node);\n\t}\n\t\n\tArrayList\u003cInteger\u003e result = new ArrayList\u003c\u003e(len);\n\t// while pq not empty\n\twhile(!pq.isEmpty()){\n\t\t// remove min el\n\t\tNode minEl = pq.poll();\n\t\t// add min el to arr\n\t\tresult.add(minEl.arr[minEl.index]);\n\t\t// reinsert minEl if index\u003clength\n\t\tif(++minEl.index \u003c minEl.arr.length) pq.add(minEl);\n\t}\n\treturn result;\n}\n\n```\n\n### Notes\n- Use a Node Wrapper over each subarraay to track index\n- Solve just like [[23. Merge k Sorted Lists]]\n\n","lastmodified":"2024-07-04T20:24:17.037181919Z","tags":["dsadeck","arrays","heap"]},"/dsa/GFG-Minimise-the-Heights":{"title":"GFG Minimise the Heights","content":"\n## Problem Statement\n\n\nPattern: \n\n---\n\n## Solution\n\n[Minimize the maximum difference between heights || Love Babbar DSA sheet - YouTube](https://www.youtube.com/watch?v=Av7vSnPSCtw)\n\n- [ ] #questiontodo [https://www.youtube.com/watch?v=o9WG7t6EKZo\u0026t=797s](https://www.youtube.com/watch?v=o9WG7t6EKZo\u0026t=797s \"https://www.youtube.com/watch?v=o9WG7t6EKZo\u0026t=797s\")\n\n\n``` java\nint getMinDiff(int[] arr, int n, int k) {\n\t// code here\n\tArrays.sort(arr);\n\t\n\tint smallest = arr[0]+k;\n\tint largest = arr[n-1]-k;\n\t\n\tint min, max, ans = arr[n-1] - arr[0];\n\t\n\tfor (int i = 0; i \u003c n-1; i++) {\n\t\tmin = Math.min(smallest, arr[i+1]-k);   // smallest larger el\n\t\tmax = Math.max(largest, arr[i]+k);      // largest smaller el\n\t \n\t\tif(min \u003c 0) continue;\n\t\t\n\t\tans = Math.min(ans, max-min);\n\t}\n\treturn ans;\n}\n```\n\n### Notes\n[Stack Overflow Explanation](https://stackoverflow.com/questions/32233916/minimum-difference-between-heights-of-towers/63220955#63220955)\n\t\n- So the approach is we already know one kind of trivial solution:\n\t- increase first el by k `smallest = arr[0]+k` and decrease last (biggest) by k. `largest = arr[n-1]-k` there difference is one possible `ans`.\n\t- now we have to start looking at `i+1` (second element after the first) and subtract k, maybe we get a smaller value than `arr[0]+k` which when subtracted from a different `largest` element gives a smaller difference.\n\t- similiarly we search for a largest uptil `(n-2)` `arr[i]+k` might give a larger element which when subtracted by `k` might give a new `largest`\n\n[Minimize the Heights I | Practice | GeeksforGeeks](https://practice.geeksforgeeks.org/problems/minimize-the-heights-i/1/)\nsame q but no check for `min \u003c 0`\n\n[Smallest Range II - LeetCode](https://leetcode.com/problems/smallest-range-ii/)","lastmodified":"2024-07-04T20:24:17.037181919Z","tags":["dsadeck","arrays","incomplete"]},"/dsa/GFG-Minimum-Number-of-Jumps":{"title":"GFG Minimum Number of Jumps","content":"\n## Problem Statement\n\n![](https://i.imgur.com/vSQWN9I.png)\n\nPattern: \n\n---\n\n## Solution\n``` java\npublic int jump(int[] nums){\n\tint limit = nums[0], jumps = 1, i = 0, n = nums.length;\n\tif(n == 1) return 0;\n\twhile (i \u003c n \u0026\u0026 i \u003c= limit ) {\n\t\t// if end reached return jumps\n\t\tif (limit \u003e= n - 1) return jumps;\n\t\t// find max limit in current limit\n\t\tint currLimit = limit;\n\t\twhile (i \u003c= currLimit) {\n\t\t\tlimit = Math.max(limit, i+nums[i]);\n\t\t\ti++;\n\t\t}\n\t\t// if limit changed update jump\n\t\tif(limit \u003e currLimit) jumps++;\n\t}\n\treturn -1;\n}\n```\n\n### Notes\n- element at current index decides the `limit` / how far you can jump\n\t- check if the `limit \u003e= num.length`. if so return `jumps` counted. else continue \n\t- within the `currLimit` find the new max `limit`\n\t- if `limit` is found then it must be greater `limit \u003e currLimit`. then a jump has been made, and `limit` has been updated\n\n[Alternative Greedy Solution](https://leetcode.com/problems/jump-game-ii/discuss/18014/Concise-O(n)-one-loop-JAVA-solution-based-on-Greedy)\n","lastmodified":"2024-07-04T20:24:17.037181919Z","tags":["dsadeck","arrays"]},"/dsa/GFG-Minimum-swaps-and-K-together":{"title":"GFG Minimum swaps and K together","content":"\n## Problem Statement\n\n\nPattern: [[Pattern Sliding Window]]\n\n---\n\n## Solution\n``` java\npublic int minSwap(int[] nums, int n, int k) {\n\tint good = 0;\n\tfor (int num : nums) if (num \u003c= k) good++;\n\tif(good == 0) return 0;\n\t\n\t// sliding window of size 'good'\n\tint bad = 0, start = 0, end = good - 1;\n\t// find how many bad\n\tfor (int i = start; i \u003c= end; i++) if(nums[i] \u003e k) bad++;\n\t\n\t// init minBad\n\tint minBad = bad;\n\tstart++;end++;\n\t\n\twhile(end \u003c n) {\n\t\tif(nums[start-1] \u003e k) bad--;    // check dropped element\n\t\tif(nums[end] \u003e k) bad++;        // check picked element\n\t\tminBad = Math.min(minBad, bad); // update minBad\n\t\tstart++; end++;                 // sliding window fwd\n\t}\n\treturn minBad;\n}\n```\n\n### Notes\n- the no. of 'good' elements in the array (elements less than eq to k), will be the size of our sliding window\n- we need to move this window through the array and find the windows with least number of 'bad' elements (elements greater than k)\n\n\n","lastmodified":"2024-07-04T20:24:17.037181919Z","tags":["dsadeck","arrays"]},"/dsa/GFG-Palindromic-Array":{"title":"GFG Palindromic Array","content":"\n## Problem Statement\n[Palindromic Array | Practice | GeeksforGeeks](https://practice.geeksforgeeks.org/problems/palindromic-array-1587115620/1#)\n\nPattern: \n\n---\n\n\n## Solution\n``` java\nfor (int num : nums) {\n\tint temp = num, revNum = 0;\n\twhile(temp != 0) {\n\t\trevNum = revNum*10 + temp%10;\n\t\ttemp /= 10;\n\t}\n\tif(revNum != num) return 0; \n}\n\nreturn 1;\n```\n\n### Notes\n- \n\n","lastmodified":"2024-07-04T20:24:17.037181919Z","tags":["dsadeck","arrays"]},"/dsa/GFG-Rearrange-array-in-alternating-positive-negative-items-with-O1-extra-space":{"title":"GFG Rearrange array in alternating positive \u0026 negative items with O(1) extra space","content":"\n\n## Problem Statement #2 - Unordereed\n\n![](https://i.imgur.com/iZ07yoW.png)\nInPlace O(1) space\n\nPattern: \n\n---\n\n## Solution\n``` java\npublic int[] rearrangeUnordered(int[] nums) {\n\tint ni = 0; // negative index\n\tfor (int i = 0; i \u003c nums.length \u0026\u0026 ni \u003c nums.length; i++) {\n\t\tif (nums[i] \u003c 0) {\n\t\t\tswap(nums, i, ni);\n\t\t\tni +=2;\n\t\t}\n\t}\n\treturn nums;\n}\n```\n\nTime Complexity: `O(n)`\n\n### Notes\n- Will not maintain relative order of elements: not stable\n\n\n## Problem Statement #1 - Ordered\n[Rearrange array in alternating positive \u0026 negative items with O(1) extra space | Set 1 - GeeksforGeeks](https://www.geeksforgeeks.org/rearrange-array-alternating-positive-negative-items-o1-extra-space/)\n![](https://i.imgur.com/dbhQfm9.png)\n\nWith `O(n)` space its easy :[Alternate positive and negative numbers | Practice | GeeksforGeeks](https://practice.geeksforgeeks.org/problems/array-of-alternate-ve-and-ve-nos1401/1)\n``` java\nvoid rearrange(int nums[], int n) {\n\tLinkedList\u003cInteger\u003e neg = new LinkedList\u003c\u003e(), pos = new LinkedList\u003c\u003e();\n\t\n\t// create pos and negative linked lists\n\tfor(int num : nums)\n\t\tif(num \u003c 0) neg.add(num);\n\t\telse pos.add(num);\n\t\n\t// merge both\n\tint index = 0;\n\twhile(!pos.isEmpty() \u0026\u0026 !neg.isEmpty()) {\n\t\tnums[index++] = pos.remove();\n\t\tnums[index++] = neg.remove();\n\t}\n\t\n\t// copy leftover\n\twhile(!pos.isEmpty())nums[index++] = pos.remove();\n\twhile(!neg.isEmpty())nums[index++] = neg.remove() ;\n\t\n\treturn;\n}\n```\n\n\nThe only way this can be solved in O(1) space is if time complexity is `O(n^2)`, which is the [solution given at gfg](https://www.geeksforgeeks.org/rearrange-array-alternating-positive-negative-items-o1-extra-space/)\n","lastmodified":"2024-07-04T20:24:17.037181919Z","tags":["dsadeck","arrays"]},"/dsa/GFG-Remove-Duplicates":{"title":"GFG Remove Duplicates","content":"\n## Problem Statement\n\n\nPattern: \n\n---\n\n## Solution\n``` java\n// O(1) space\npublic ListNode removeDuplicates (ListNode head){\n\tListNode next = head, node = head;\n\tnext = next.next;\n\twhile(next != null) {\n\t\twhile(next != null \u0026\u0026 next.val == node.val) next = next.next ;  // increment next till diff from node\n\t\tnode.next = next;   // add next to node\n\t\tnode = node.next;   // increment node\n\t}\n\treturn head;\n}\n\n// O(n) space\npublic ListNode removeDuplicatesUnsorted (ListNode head){\n\tListNode next = head, node = head;\n\tSet\u003cInteger\u003e set = new HashSet\u003c\u003e();\n\t\n\t// add first val and increment\n\tset.add(next.val);\n\tnext = next.next;\n\t\n\twhile(next != null) {\n\t\t// if next is unique\n\t\tif(!set.contains(next.val)) {   \n\t\t\tset.add(next.val);\n\t\t\tnode.next = next;   // add to node\n\t\t\tnode = node.next;   // increment node\n\t\t}\n\t\tnext = next.next;       // increment next\n\t}\n\tnode.next = next;           // set last node to null\n\treturn head;\n}\n```\n\n### Notes\n- Sorted\n\t- run next pointer fwd, if it is not same as head, add to head\n- Unsorted\n\t- run next pointer fwd, if it is not in set add to head\n\t\n\n","lastmodified":"2024-07-04T20:24:17.037181919Z","tags":["dsadeck","arrays"]},"/dsa/GFG-Remove-Loop":{"title":"GFG Remove Loop","content":"\n## Problem Statement\n\n\nPattern: \n\n---\n\n## Solution\n[[142. Linked List Cycle II]] but with a lagging pointer\n``` java\npublic void removeCycle (ListNode head) {\n\tListNode fast = head, slow = head;\n\tListNode prev = new ListNode(); // lagging pointer\n\t\n\twhile(fast!= null \u0026\u0026 fast.next !=null){\n\t\tprev = slow;                \n\t\tslow = slow.next;\n\t\tfast = fast.next.next;\n\t\tif(slow == fast) break;\n\t}\n\tif(fast == null || fast.next == null) return;   // LL is not cyclic, or has single el\n\n\twhile(head != slow) {\n\t\tprev = slow;\n\t\thead = head.next;\n\t\tslow = slow.next;\n\t}\n\t\n\tprev.next = null;   // set lagging_pointer_to_cycle_start to null\n}\n```\n\n### Notes\n- The idea is to having a lagging pointer inside of the cycle when `slow` and `head` meet at `cycle_start`\n- Then why do we need the laggin pointer in the first loop?\n\t- that is in case `cycle_start == head` of the linked list. in that case, the second loop will never run, and we will never know, what the prev element was!\n\n\n","lastmodified":"2024-07-04T20:24:17.037181919Z","tags":["dsadeck","linkedlist"]},"/dsa/GFG-Reverse-Doubly-Linked-List":{"title":"GFG Reverse Doubly Linked List","content":"\n## Problem Statement\n\n\nPattern: \n\n---\n\n## Solution\n``` java\npublic static Node reverseDLL(Node  head)\n{\n    //Your code here\n    Node prev = null;\n    \n    while (head != null) {\n        // store next\n        Node next = head.next;\n        \n        // swap prev \u0026 next\n        head.next = prev;\n        head.prev = next;\n                    \n        // increment prev \u0026 head                        \n        prev = head;\n        head = next;\n    }\n    return prev;\n    // return last node\n}\n```\n\n### Notes\n- \n\n","lastmodified":"2024-07-04T20:24:17.037181919Z","tags":["dsadeck","linkedlist"]},"/dsa/GFG-Smallest-Subarray-Sum-Smaller-Than-K":{"title":"GFG Smallest Subarray Sum Smaller Than K","content":"\n## Problem Statement\n\n\nPattern: [[Pattern Two Pointer]]\n\n---\n\n## Solution\n``` java\npublic static int smallestSubWithSum(int nums[], int n, int x) {\n\tint start = 0, end = start, minLen = Integer.MAX_VALUE, sum = 0;\n\twhile(end \u003c n) {\n\t\tsum += nums[end];\n\t\twhile(start \u003c= end \u0026\u0026 sum \u003e x) {\n\t\t\tminLen = Math.min(end-start+1, minLen);\n\t\t\tsum -= nums[start++];\n\t\t}\n\t\tend++;\n\t}\n\treturn minLen;\n}\n```\n\n### Notes\n- quite simple\n\n","lastmodified":"2024-07-04T20:24:17.037181919Z","tags":["dsadeck","arrays"]},"/dsa/GFG-Split-Circular-Linked-List-into-Two-Halves":{"title":"GFG Split Circular Linked List into Two Halves","content":"\n## Problem Statement\n[Split a Circular Linked List into two halves | Practice | GeeksforGeeks](https://practice.geeksforgeeks.org/problems/split-a-circular-linked-list-into-two-halves/1#)\n\nPattern: \n\n---\n\n## Solution\n``` java\npublic void splitList (ListNode head){\n\tListNode fast = head, slow = head;\n\t\n\twhile(fast.next!= head \u0026\u0026 fast.next.next != head) {\n\t\tfast = fast.next.next;\n\t\tslow = slow.next;\n\t}\n\t// slow now points to mid\n\t\n\t// in case there's even no. of els in list\n\twhile(fast.next != head) fast = fast.next;\n\t// fast now points to tail\n\t\n\tListNode mid = slow, tail = fast, head2 = mid.next;\n\t\n\t// make both circular\n\tmid.next = head;\n\ttail.next = head2;\n}\n```\n\n### Notes\n- Circular linked list are in a way not circular at all, since you know then end, when `curr.next == head`\n- Now just find [[876. Middle of the Linked List]] and slow will point to floor of mid, and `fast` will point to `tail` if LL is Odd, if its even, `while(fast.next != head) fast = fast.next` should give u the tail\n- connect both tails, to heads\n\n\n","lastmodified":"2024-07-04T20:24:17.037181919Z","tags":["dsadeck","linkedlist"]},"/dsa/GFG-Sum-of-Longest-Bloodline":{"title":"GFG Sum of Longest Bloodline","content":"\n## Problem Statement\n\n\nPattern: \n\n---\n\n## Solution\n``` java\nclass hs implements Comparable\u003chs\u003e{\n\tint height;\n\tint sum;\n\t\n\ths (int height, int sum) {\n\t\tthis.height = height;\n\t\tthis.sum = sum;\n\t}\n\t\n\t@Override\n\tpublic int compareTo(hs other) {\n\t\tint hDelta = Integer.compare(height, other.height);\n\t\tint sDelta = Integer.compare(sum, other.sum);\n\t\t\n\t\tif(hDelta == 0) return sDelta;  // height is same, return sum difference\n\t\treturn hDelta;                  // return height difference\n\t}\n}\n\nhs sum (Node root, int depth) {\n\tif(root == null) return new hs(depth-1, 0);\n\t\n\ths lhs = sum(root.left, depth + 1);\n\ths rhs = sum(root.right, depth + 1);\n\t\n\ths greater = lhs.compareTo(rhs) \u003e= 0 ? lhs : rhs;   // get greater\n\tgreater.sum += root.val;                            // update sum\n\t\n\treturn greater;\n}\n\npublic int sumOfLongRootToLeafPath (Node root){\n\treturn sum(root, 1).sum;\n}\n```\n\n### Notes\n- hs is a wrapper class to store `height` and `sum` together\n- `compareTo`, first compares the height, and if same, then compares the sum\n\t-  ![](https://i.imgur.com/WfIqo4q.png)\n\n\n","lastmodified":"2024-07-04T20:24:17.037181919Z","tags":["dsadeck","binarytrees"]},"/dsa/GFG-Three-Way-Paritioning":{"title":"GFG Three Way Paritioning","content":"\n## Problem Statement\n\n[Three way partitioning | Practice | GeeksforGeeks](https://practice.geeksforgeeks.org/problems/three-way-partitioning/1)\nPattern: [[Pattern Array Partitioning]] \n\n---\n\n## Solution\n``` java\n//Function to partition the array around the range such \n//that array is divided into three parts.\n\npublic void swap(int[] x, int a, int b) {\n\tint t = x[a];\n\tx[a] = x[b];\n\tx[b] = t;\n}\n\npublic void threeWayPartition(int nums[], int A, int B)\n{\n\tint i = 0, start = 0, end = nums.length-1;\n\twhile(i \u003c= end) {\n\t\tif(nums[i] \u003c A ){\n\t\t\t// swap to start\n\t\t\tswap(nums, i, start);\n\t\t\t// increment start and i\n\t\t\tstart++;\n\t\t\ti++;\n\t\t}\n\t\telse if (nums[i] \u003e B) {\n\t\t\t// swap to end\n\t\t\tswap(nums, i, end);\n\t\t\t// decrement end\n\t\t\tend--;\n\t\t}\n\t\t// if num in b/w A and B\n\t\telse i++;\n\t}\n}\n```\n\n### Notes\n- place start and end pointers, and start iterating from the first pointer\n\t- if num \u003c A swap with start, increment `start` and `i`\n\t- if num \u003e B swap with `end`, and only decrement `end`\n\t- else if  `A \u003c num \u003c B` then increment `i`\n- Whats going on\n\t- start marks the end of the first partition of the array\n\t\t- so whenever we find a number less than A, we swap with start and increment `start` and `i`\n\t\t-   this works even if start and i are pointing to the same number\n\t- similiarly end marks the beginning of the third parition, whenever `i` finds that `num \u003e B` it will swap `nums[i], nums[end--]`. \n\t\t- notice we dont increment i, since the swapped number in `i`th postion now might be `\u003c A` so we let teh check run again. \n\t\t- therefore we only decrement num\n\t- finally if neither of those conditions are true, then we move i forward, till it finds an element that goes in the first or last partition. plain and simple.\n\t- **example**\n#### how's that\n\n\n \n\n","lastmodified":"2024-07-04T20:24:17.037181919Z","tags":["dsadeck","arrays","twopointer"]},"/dsa/GFG-Triplet-Sum-in-Array":{"title":"GFG Triplet Sum in Array","content":"\n## Problem Statement\n\n\nPattern: [[Pattern Two Pointer]]\nRelated: [[15. 3Sum]]\n\n---\n\n## Solution\n``` java\npublic boolean find3Numbers(int[] nums, int n, int k) {\n\tArrays.sort(nums);\n\tfor (int start = 0; start \u003c n-2; start++) {\n\t\tint mid = start+1, end = n-1;\n\t\twhile(mid \u003c end) {\n\t\t\tint sum = nums[start] + nums[mid] + nums[end];\n\t\t\tif(sum \u003c k) mid++;\n\t\t\telse if(sum \u003e k) end--;\n\t\t\telse return true;\n\t\t}\n\t}\n\treturn false;\n}\n```\n\n### Notes\n- for start -\u003e n -2\n\t- mid = start +1 end = n-1\n\t- if `sum \u003e k` end--\n\t- if `sum \u003c k` start++\n\n\n","lastmodified":"2024-07-04T20:24:17.037181919Z","tags":["dsadeck","arrays","arithmetic"]},"/dsa/Given-n-appointments-find-all-conflicting-appointments":{"title":"Given n appointments, find all conflicting appointments","content":"\n## Problem Statement\n[Given n appointments, find all conflicting appointments - GeeksforGeeks](https://www.geeksforgeeks.org/given-n-appointments-find-conflicting-appointments/)\n\nPattern: \n\n---\n## Approach 1\nCreate `Points` Datastructure, and sort all the points, and the other point they belong to\nIterate add overlapping interval to a `Set\u003cInterval\u003cPoint, Point\u003e`\n```java\nclass Point { \n\tint val;\n\tboolean isStart;\n\tPoint other;\n}\n```\n\n## Approach 2\n[Interval Tree - GeeksforGeeks](https://www.geeksforgeeks.org/interval-tree/)\n\n## Solution\n\n``` java\n\u003c% tp.file.cursor(2) %\u003e\n```\nTC : ` \u003c% tp.file.cursor(3) %\u003e `\nSC : ` \u003c% tp.file.cursor(4) %\u003e `\n\n### Notes\n- \n\n\n","lastmodified":"2024-07-04T20:24:17.037181919Z","tags":["dsadeck","bst"]},"/dsa/Height-of-a-Tree":{"title":"Height of a Tree","content":"## Problem Statement\n\n\nPattern: \n\n---\n\n\n``` java\npublic static int height(Node root) {\n\tif (root == null) return 0;\n\t\n\tint leftHeight = height(root.left);\n\tint rightHeight = height(root.right);\n\t\n\treturn Math.max(leftHeight, rightHeight) + 1;\n}\n```\n\n","lastmodified":"2024-07-04T20:24:17.037181919Z","tags":["dsadeck","binarytrees"]},"/dsa/Inorder-Predecessor-and-Successor-in-BST":{"title":"Inorder Predecessor and Successor in BST","content":"\n## Problem Statement\n\n\nPattern: \n\n---\n\n## Solution\n``` java\nNode inorderPredecessor(Node node, int key) {\n\tNode pre = null;\n\t\n\twhile(node != null) {\n\t\tif(key \u003c= node.data) node = node.left;\n\t\telse {\n\t\t\tpre = node;\n\t\t\tnode = node.right;\n\t}   }\n\t\n\treturn pre;\n}\n\nNode inorderSuccessor(Node node, int key) {\n\tNode succ = null;\n\t\n\twhile(node != null) {\n\t\tif(key \u003e= node.data) node = node.right;\n\t\telse {\n\t\t\tsucc = node;\n\t\t\tnode = node.left;\n\t}   }\n\t\n\treturn succ;\n}\n```\n\n### Notes\n- \n\n","lastmodified":"2024-07-04T20:24:17.037181919Z","tags":["dsadeck","bst"]},"/dsa/Iterative-Traversals-of-BT":{"title":"Iterative Traversals of BT","content":"Pattern: \n\n---\nFor recrusive checkout:  [[Binary Tree#Traversals]]\n\n## Preorder\n[Binary Tree Preorder Traversal - LeetCode](https://leetcode.com/problems/binary-tree-preorder-traversal/submissions/)\n\n`node -\u003e left -\u003e right`\n``` java\npublic static List\u003cInteger\u003e preorderIterative (Node root) {\n\tList\u003cInteger\u003e res = new LinkedList\u003c\u003e();\n\tStack\u003cNode\u003e stack = new Stack\u003c\u003e();\n\t\n\tif(root == null) return res;\n\tNode node = root;\n\t\n\twhile(!stack.isEmpty() || node != null) {\n\t\tif(node!=null) {        // go left first\n\t\t\tstack.push(node);\n\t\t\tres.add(node.val);  // visit node\n\t\t\tnode = node.left;\n\t\t}\n\t\telse {                  // then go right\n\t\t\tnode = stack.pop();\n\t\t\tnode = node.right;\n\t\t}\n\t}\n\treturn res;\n}\n```\n\n- while `node !=null` \n\t- **keep adding to result and going left**\n- `node == null` \n\t- get prev root `node = stack.pop`  \n\t- **go right** `node = node.right` \n\n\n---\n\n## Inorder\n[Binary Tree Inorder Traversal - LeetCode](https://leetcode.com/problems/binary-tree-inorder-traversal/)\n\n`left -\u003e node -\u003e right`\n``` java\npublic static List\u003cInteger\u003e inorderIterative (Node root) {\n\tList\u003cInteger\u003e res = new LinkedList\u003c\u003e();\n\tStack\u003cNode\u003e stack = new Stack\u003c\u003e();\n\t\n\tif(root == null) return res;\n\tNode node = root;\n\t\n\twhile (!stack.isEmpty() || node != null) {\n\t\tif(node != null) {          // go left first\n\t\t\tstack.push(node);\n\t\t\tnode = node.left;\n\t\t} else {                    // then go right\n\t\t\tnode = stack.pop();\n\t\t\tres.add(node.val);      // add after all left children\n\t\t\tnode = node.right;\n\t\t}\n\t}\n\treturn res;\n}\n```\n- Keep pushing to stack till node is not null \n\t- go left `node = node.left`\n- When node becomes null,  (left most node is reached)\n\t- pop from stack, add to result **(adding after all left children are traversed)**\n\t- go right `node = node.right`  \n\n\n---\n\n\n## Post Order\n[Binary Tree Postorder Traversal - LeetCode](https://leetcode.com/problems/binary-tree-postorder-traversal/)\n\t\n`left -\u003e right -\u003e node`\n``` java\npublic static List\u003cInteger\u003e postorderIterative (Node root) {\n\tLinkedList\u003cInteger\u003e res = new LinkedList\u003c\u003e(); // (second stack)\n\tStack\u003cNode\u003e stack = new Stack\u003c\u003e();\n\t\n\tif(root == null) return res;\n\tNode node = root;\n\t\n\twhile(!stack.isEmpty() || node != null) {\n\t\tif(node != null) {      // go right first\n\t\t\tstack.push(node);\n\t\t\tres.push(node.val); // push before going to children\n\t\t\tnode = node.right;\n\t\t} else {                // then go left\n\t\t\tnode = stack.pop();\n\t\t\tnode = node.left;\n\t\t}\n\t}\n\treturn res;\n}\n```\n\n","lastmodified":"2024-07-04T20:24:17.037181919Z","tags":["dsadeck","binarytrees"]},"/dsa/Job-Sequencing-Problem":{"title":"Job Sequencing Problem","content":"\n## Problem Statement\n[Job Sequencing Problem | Practice | GeeksforGeeks](https://practice.geeksforgeeks.org/problems/job-sequencing-problem-1587115620/1#)\n``` java\nclass Job {\n\tint profit;\n\tint deadline;\n\t\n\tJob(int p, int d) {\n\t\tprofit = p;\n\t\tdeadline = d;\n\t}\n}\n```\n\nPattern: \n\n---\n## Approach 1\n[3.2 Job Sequencing with Deadlines - Greedy Method - YouTube](https://www.youtube.com/watch?v=zPtI8q9gvX8)\n\n``` cpp\npublic:\nstatic bool comp (Job a, Job b){\n\t return a.profit \u003e b.profit;\n}\nvector\u003cint\u003e JobScheduling(Job arr[], int n) \n{ \n\tsort (arr, arr+n,comp);\n\tvector\u003cbool\u003e vis(n,false); \n\tint jobcnt=0,maxprofit=0;\n\tfor (int i=0; i\u003c n; i++){\n\t\tfor (int j=arr[i].dead-1; j\u003e= 0; j--){\n\t\t\t if (vis[j]) continue;\n\t\t\t else \n\t\t\t {\t \t\n\t\t\t \tvis[j]= true;\n\t\t\t\tmaxprofit+= arr[i].profit;\n\t\t\t\tjobcnt++;\n\t\t\t\tbreak;\n\t\t \t}\n\t \t}\t\t\t\n \t}\n \treturn {jobcnt,maxprofit};\n}\n```\n\n\n## Priority Queue Approach\n\n``` java\npublic int[] JobScheduling(Job arr[], int n) {\n\t// min deadline array\n\tArrays.sort(arr, Comparator.comparingInt(job -\u003e job.deadline));\n\t// profit min-heap\n\tPriorityQueue\u003cJob\u003e pq = new PriorityQueue\u003c\u003e(Comparator.comparingInt(job -\u003e job.profit));\n\t// accumulate 'n' max profit jobs for deadline of 'n'\n\tfor (Job job : arr) {\n\t\tpq.add(job);\n\t\twhile (pq.size() \u003e job.deadline) pq.remove();\n\t}\n\t// calculate and return time and profit\n\tint time = 0, profit = 0;\n\twhile(!pq.isEmpty()){\n\t\tprofit +=pq.remove().profit;\n\t\ttime++;\n\t}\n\treturn new int[]{time, profit};\n}\n```\n\n### Notes\n- \n\n","lastmodified":"2024-07-04T20:24:17.037181919Z","tags":["dsadeck","greedy","heap"]},"/dsa/KMP-Algo":{"title":"KMP Algo","content":"\n## Problem Statement\nLPS\n\nPattern: \n\n---\n\n## Solution\n``` java\n// O(2n)\npublic void getLps(String needle, int[] lps) {\n\tint currLps = 0, i = 1;\n\twhile (i \u003c needle.length())\n\t\tif (needle.charAt(i) == needle.charAt(currLps))\n\t\t\tlps[i++] = ++currLps;               // match        -\u003e   increment lps\n\t\telse if (currLps == 0) lps[i++] = 0;    // currLps = 0  -\u003e   lps not possible\n\t\telse currLps = lps[currLps - 1];        // currLps != 0 -\u003e   match against prev currLps\n}\n\npublic int kmp(String needle, String haystack) {\n\t// base condition\n\tif(needle.length() == 0) return 0;\n\n\t// get lps\n\tint[] lps = new int[needle.length()];\n\tgetLps(needle, lps);\n\n\t// matching\n\tint i = 0, j = 0;\n\twhile (i \u003c haystack.length() \u0026\u0026 j \u003c needle.length())\n\t\tif(haystack.charAt(i) == needle.charAt(j)) { i++; j++;}\n\t\telse if (j == 0) i++;\n\t\telse j = lps[j-1];\n\n\tif (j == needle.length()) return i - needle.length();\n\treturn -1;\n}\n```\nTC : $O(n + m)$\nSC : $O(n)$ where n is the size of the needle\n\n### Notes\n- KMP algo essentially keeps track of how much of a pattern has already been matched, and how much more needs to be matched.\n- LPS array - Longest Prefix (common) Suffix (where neither is the whole string) \n\n**Matching**\n- During matching if mismatch is found, the needle pointer resumes to the **earliest unmatched location in the needle**. HOW?\n- Dry Run :\n\t- ` needle = \"sosos\" ` ` haystack = \"sosoososos\" `\n\t- LPS array made would be `[0, 0, 1, 2, 3]`\n\t- when needle ptr `i` is at index `4` and haystack ptr `j` is at index `4` and theres a mismatch\n\t\t- needle ptr gets sent to and resumes after the earliest match `j = lps[j-1]` \n\t\t- when there is a mismatch at `j = 4`,  `lps [3] -\u003e 2` says : *Resume checking from index 2, since the longest prefix suffix of the string of size is of length 2, it has already occurred once before, now resume checking from the 3rd character*. \n\t- didnt explain it too well, you get the idea.\n\n\n\n\n","lastmodified":"2024-07-04T20:24:17.037181919Z","tags":["dsadeck","strings"]},"/dsa/Kth-Ancestor":{"title":"Kth Ancestor","content":"\n## Problem Statement\n[Kth Ancestor in a Tree | Practice | GeeksforGeeks](https://practice.geeksforgeeks.org/problems/kth-ancestor-in-a-tree/1/#)\n\n\nPattern: \n\n---\n\n## Solution\n``` java\nstatic class Ancestor {\n\tint distance = -10;\n\tAncestor(int distance){\n\t\tthis.distance = distance;\n\t}\n}\n\nNode findAncestor(Node root, Ancestor anc, int node) {\n\tif(root == null) return null;\n\tif(root.data == node) {\n\t\tanc.distance--;\n\t\treturn root;\n\t}\n\t\n\tNode left = findAncestor(root.left, anc, node);\n\tNode right = findAncestor(root.right, anc, node);\n\t\n\t// get non-null ancestor value\n\tNode ans = (left!=null)? left : right;\n\t\n\t// node found, ancestor not already found\n\tif(ans != null \u0026\u0026 anc.distance \u003e -1) {\n\t\tif (anc.distance == 0) ans = root;\n\t\tanc.distance--;\n\t}\n\treturn ans;\n}\n\npublic int kthAncestor (Node root, int k , int node){\n\tAncestor anc = new Ancestor(k);\n\tNode res = findAncestor(root,anc, node);\n\tif(anc.distance == -1) return res.data;\n\treturn -1;\n}\n```\n\n### Notes\n- \n\n","lastmodified":"2024-07-04T20:24:17.037181919Z","tags":["dsadeck","binarytrees"]},"/dsa/LCA-in-BST":{"title":"LCA in BST","content":"\n## Problem Statement\n\n\nPattern: \n\n---\n\n## Solution\n``` java\nNode LCA(Node root, int n1, int n2)\n{\n\tif(n1 \u003e n2) return LCA(root, n2, n1);\n\tif(root == null) return null;\n\t\n\tif(root.data \u003c n1 \u0026\u0026 root.data \u003c n2) return LCA(root.right, n1, n2);\n\tif(root.data \u003e n1 \u0026\u0026 root.data \u003e n2) return LCA(root.left, n1, n2);\n\treturn root;\n}\n```\n\n`Ologn`\n\n ","lastmodified":"2024-07-04T20:24:17.037181919Z","tags":["dsadeck","bst"]},"/dsa/Largest-BST":{"title":"Largest BST","content":"\n## Problem Statement\n\n\nPattern: \n\n---\n\n## Approach:\njust iterative inorder traversal, with a max and a count of sorted elments.\n``` java\n\u003c% tp.file.cursor(2) %\u003e\n```\nTC : ` \u003c% tp.file.cursor(3) %\u003e `\nSC : ` \u003c% tp.file.cursor(4) %\u003e `\n\n### Notes\n- \n\n\nOther approaches: https://youtu.be/fqx8z3VepMA\n\n","lastmodified":"2024-07-04T20:24:17.037181919Z","tags":["dsadeck","bst"]},"/dsa/Leaf-at-same-level":{"title":"Leaf at same level","content":"\n## Problem Statement\n\n\nPattern: \nRelated: [[Balance Binary Tree]]\n\n---\n\n## Solution\n``` java\nclass Solution\n{\n\t// perfect node has both left and right children \n    boolean isPerfectNode (Node node) {return node.left!=null \u0026\u0026node.right!=null;}\n    \n    int height (Node root) {\n        if(root == null) return 0;\n        \n        int left = height(root.left);\n        int right = height(root.right);\n        \n        if (left == -1 || right == -1) return -1;\n        if (isPerfectNode(root) \u0026\u0026 left != right) return -1; \n        \n        return Math.max(left, right) + 1;\n    }\n\n    boolean check(Node root) {return height(root) != -1;}\n}\n```\n\n\n\n","lastmodified":"2024-07-04T20:24:17.037181919Z","tags":["dsadeck","binarytrees"]},"/dsa/Left-and-Right-View":{"title":"Left and Right View","content":"\n## Problem Statement\n[Left View of Binary Tree | Practice | GeeksforGeeks](https://practice.geeksforgeeks.org/problems/left-view-of-binary-tree/1)\n\nPattern: \n\n---\n\n## Left Solution\n``` java\nHashMap\u003cInteger, Integer\u003e map = new HashMap\u003c\u003e();\n\npublic void preorder (Node root, int depth) {\n\tif(root == null) return;\n\t// if depth not reached before, put value\n\tif(!map.containsKey(depth)) map.put(depth, root.data);\n\tpreorder(root.left, depth+1);    // go left first\n\tpreorder(root.right, depth+1);\n}\n\n\n public ArrayList\u003cInteger\u003e leftView (Node root) {\n\t\n\tArrayList\u003cInteger\u003e res = new ArrayList\u003c\u003e();\n\n\tpreorder(root, 1);\n\t\n\tfor (int i = 1; map.containsKey(i); i++) res.add(map.get(i));\n\t\n\treturn res;\n}\n```\n\n### Notes\n- preorder traversal, always goes left from node first then right.\n\t- during the traversal, foreach unique depth, add to a map the node value found\n\t- this way, all the left nodes get input first\n\t- and right nodes, only when there are no left nodes at the depth!\n\nFor the Right Solution, simply reversePreorder -\u003e traverse right first then left\n\n```java\npublic void preorder (Node root, int depth) {\n\tif(root == null) return;\n\t// if depth not reached before, put value\n\tif(!map.containsKey(depth)) map.put(depth, root.data);\n\tpreorder(root.right, depth+1);    // go right first\n\tpreorder(root.left, depth+1);\n}\n```\n","lastmodified":"2024-07-04T20:24:17.037181919Z","tags":["dsadeck","binarytrees"]},"/dsa/Longest-Palindrome-in-String":{"title":"Longest Palindrome in String","content":"\n## Problem Statement\n\n\nPattern: \n\n---\n\n## Return Length Solution\n``` java\npublic int longestPalin (String str){\n\t// code here\n\tchar[] chars = str.toCharArray();\n\tint n = chars.length, max =1;\n\tfor (int mid = 0 ; mid \u003c n ; mid++) {\n\t\t// odd substring\n\t\tint start = mid -1, end = mid+1, count = 1;\n\t\twhile(start \u003e= 0 \u0026\u0026 end \u003c n)\n\t\t\tif(chars[start--] ==  chars[end++]) count+=2;\n\t\tmax = Math.max(count, max);\n\t\t// even substring\n\t\tstart = mid ; end = mid+1; count = 0;\n\t\twhile(start \u003e=0 \u0026\u0026 end \u003c n)\n\t\t\tif(chars[start--] == chars[end++]) count+=2;\n\t\tmax = Math.max(count, max);\n\t}\n\treturn max;\n}\n\n```\nTC : $n^2$\nSC : $1$\n\n### Notes\n- take each element as the center of a palindrome and start checking outwards\n- for even numbers you will need to take 2 adjacent elements\n- make sure to reset the `start` `end` and `count` before each\n\n\n## Return String Solution\n``` java\npublic String longestPalin(String str) {\n\t// code here\n\tchar[] chars = str.toCharArray();\n\tint n = chars.length, max = 1, pstart = 0, pend = 0;\n\tfor (int mid = 0; mid \u003c n; mid++) {\n\t\t// odd substring\n\t\tint start = mid - 1, end = mid + 1, count = 1;\n\t\twhile (start \u003e= 0 \u0026\u0026 end \u003c n \u0026\u0026 chars[start] == chars[end]) {\n\t\t\tcount += 2; start--; end++;\n\t\t}\n\t\tif (count \u003e max) {\n\t\t\tmax = count; pstart = start + 1; pend = end - 1;\n\t\t}\n\t\t\n\t\t// even substring\n\t\tstart = mid; end = mid + 1; count = 0;\n\t\twhile (start \u003e= 0 \u0026\u0026 end \u003c n \u0026\u0026 chars[start] == chars[end]) {\n\t\t\tcount += 2; start--;end++;\n\t\t}\n\t\tif (count \u003e max) {\n\t\t\tmax = count; pstart = start + 1; pend = end - 1;\n\t\t}\n\t}\n\treturn str.substring(pstart, pend+1);\n}\n```\n\nTC : $n^2$\nSC : $1$\n\n- here `pstart` and `pend` are updated when a larger palindrome is found\n- `str.susbtring()` is end exclusive\n ","lastmodified":"2024-07-04T20:24:17.037181919Z","tags":["dsadeck","strings"]},"/dsa/Longest-Repeating-Subsequence":{"title":"Longest Repeating Subsequence","content":"\n## Problem Statement\n\n\nPattern: \nRelated: [[1143. Longest Common Subsequence]]\n\n---\n\n## DP Solution\n``` java\nInteger[][] cache;\npublic int LongestRepeatingSubsequence(String str) {\n\tcache =  new Integer[str.length()+1][str.length()];\n\treturn dp(str.toCharArray(), str.length()-1, str.length()-2);\n}\n\npublic int dp (char[] chars, int l1, int l2) {\n\tif(l1 \u003c 0 || l2 \u003c 0 || l2 \u003e= l1) return 0;\n\tif(cache[l1][l2] != null) return cache[l1][l2];\n\t\n\tif(chars[l1] == chars[l2])\n\t\treturn cache[l1][l2] = dp(chars, l1-1, l2-1) + 1;\n\treturn cache[l1][l2] =  Math.max(\n\t\tdp(chars, l1-1, l2), dp(chars, l1, l2-1)\n\t);\n}\n```\nTC : $n^2$\nSC : $n^2$\n\n- simple lcs problem with a twist `\tif(l1 \u003c 0 || l2 \u003c 0 || l2 \u003e= l1) return 0;`\n\n\n\n\n","lastmodified":"2024-07-04T20:24:17.037181919Z","tags":["dsadeck","strings","dp"]},"/dsa/MOC-DSA-Questions":{"title":"MOC DSA Questions","content":"\n## Resources\n[â­â­ Most Important 145 LeetCode Interview Questions â­â­](https://leetcode.com/problem-list/top-interview-questions/)\n[â­â­141 aggregated by engg FANG Leetcode PATTERNED Interview Questions organised by pattern, difficulty and company](https://seanprashad.com/leetcode-patterns/)\n[List of questions sorted by common patterns. - LeetCode Discuss](https://leetcode.com/discuss/career/448285/List-of-questions-sorted-by-common-patterns)\n[[Technical Interview Topics]]\n\n### Reading\n[Map Problems to known Problem Pattern Strategy for coding interviews](https://dev.to/arslan_ah/the-ultimate-strategy-to-preparing-for-the-coding-interview-3ace)[Important and Useful links from all over the LeetCode - LeetCode Discuss](https://leetcode.com/discuss/general-discussion/665604/Important-and-Useful-links-from-all-over-the-Leetcode)[Java Syntax for DSA.pdf - Google Drive](https://drive.google.com/file/d/1ao4ZA28zzBttDkuS6MLQI52gDs_CJZEm/view)\n\n\n      \n## ðContests\n[[6122. Minimum Deletions to Make Array Divisible]]\n[[6121. Query Kth Smallest Trimmed Number]]\n\n## â Arithmetic\n- [x] [[50. Pow(x, n)]]\n- [ ] [[372.Â Super Pow]]\n- [ ] [[1509.Â Minimum Difference Between Largest and Smallest Value in Three Moves]]\n- [ ] [[1295.Â Find Numbers with Even Number of Digits]]\n- [x] [[Numbers divisible by a or b in range n]]\n\n\n## ð¤ï¸ Arrays\n- [x] [[1. Two Sum]]\n- [x] [[26. Remove Duplicates from Sorted Array]]\n- [x] [[80.Â Remove Duplicates from Sorted Array II]]\n- [x] [[27. Remove Element]]\n- [x] [[35. Search Insert Position]]\n- [x] [[41. First Missing Positive]]\n- [x] [[448. Find All Numbers Disappeared in an Array]]\n- [x] [[287.Â Find the Duplicate Number]]\n- [x] [[442.Â Find All Duplicates in an Array]]\n- [x] [[268. Missing Number]]\n- [x] [[765. Couples Holding Hands]]\n- [x] [[645.Â Set Mismatch]]\n- [x] [[1980.Â Find Unique Binary String]]\n- [x] [[215.Â Kth Largest Element in an Array]]\n- [x] [[378.Â Kth Smallest Element in a Sorted Matrix]]\n- [x] [[First Repeating Element]]\n- [x] [[Smallest sum contiguous subarray]]\n- [x] [[53.Â Maximum Subarray]]\n- [x] [[1749.Â Maximum Absolute Sum of Any Subarray]]\n- [x] [[1574. Shortest Subarray  Removed to Make Array Sorted]]\n- [x] [[GFG Length of smallest subarray removed]]\n- [x] [[278.Â First Bad Version]]\n- [x] [[2053. Kth Distinct String in an Array]]\n- [x] [[523.Â Continuous Subarray Sum]]\n- [x] [[560.Â Subarray Sum Equals K]]\n- [x] [[713.Â Subarray Product Less Than K]]\n- [x] [[209.Â Minimum Size Subarray Sum]]\n- [x] [[23.Â Merge k Sorted Lists]]\n- [x] [[GFG Kth Largest Subarray]]\n- [x] [[GFG Merge k Sorted Arrays]]\n- [x] [[2294. Partition Array Such That Maximum Difference Is K]]\n- [x] [[632.Â Smallest Range Covering Elements from K Lists]]\n- [x] [[295.Â Find Median from Data Stream]]\n- [x] [[744.Â Find Smallest Letter Greater Than Target]]\n- [x] [[1920.Â Build Array from Permutation]]\n- [x] [[1470.Â Shuffle the Array]]\n- [x] [[1365.Â How Many Numbers Are Smaller Than the Current Number]]\n- [x] [[1512.Â Number of Good Pairs]]\n- [x] [[1389.Â Create Target Array in the Given Order]]\n- [x] [[1832.Â Check if the Sentence Is Pangram]]\n- [x] [[1773.Â Count Items Matching a Rule]]\n- [ ] [[42 Trapping Rain Water]]\n- [x] [[989.Â Add to Array-Form of Integer]]\n- [x] [[1854.Â Maximum Population Year]]\n- [x] [[1304.Â Find N Unique Integers Sum up to Zero]]\n- [x] [[1380. Lucky Numbers in a Matrix]]\n- [x] [[566. Reshape the Matrix]]\n- [x] [[66. Plus One]]\n- [x] [[GFG Longest Subarray having Sum K]]\n- [x] [[1217.Â Minimum Cost to Move Chips to The Same Position]]\n- [ ] [[73.Â Set Matrix Zeroes]]\n- [ ] [[238. Product of Array Except Self]]\n- [ ] [[6096. Successful Pairs of Spells and Potions]]\n- [ ] [[55.Â Jump Game]]\n- [ ] [[GFG Three Way Paritioning]]\n- [ ] [[75.Â Sort Colors]]\n- [ ] [[86. Partition List]]\n- [ ] [[198.Â House Robber]]\n- [ ] [[GFG Merge Without Extra Space]]\n- [ ] [[GFG Minimum Number of Jumps]]\n- [ ] [[Union and Intersection of Arrays]]\n- [ ] [[GFG Minimise the Heights]]\n- [ ] [[31.Â Next Permutation]]\n- [ ] [[315.Â Count of Smaller Numbers After Self]]\n- [ ] [[GFG Count Inversions]]\n- [ ] [[GFG Common Elements]]\n- [ ] [[GFG Rearrange array in alternating positive \u0026 negative items with O(1) extra space]]\n- [ ] [[GFG Factorials of large numbers]]\n- [ ] [[GFG Maximum Product Subarray]]\n- [ ] [[128. Longest Consecutive Sequence]]\n- [ ] [[169.Â Majority Element]]\n- [ ] [[229. Majority Element II]]\n- [ ] [[Given an array of size n and a number k, find all elements that appear more than n/k times]]\n- [ ] [[121.Â Best Time to Buy and Sell Stock]]\n- [ ] [[GFG Triplet Sum in Array]]\n- [ ] [[15. 3Sum]]\n- [ ] [[GFG Smallest Subarray Sum Smaller Than K]]\n- [ ] [[GFG Choclate Distribution Problem]]\n- [ ] [[GFG Minimum swaps and K together]]\n- [ ] [[GFG Palindromic Array]]\n- [ ] [[Minimum Number of Merges to make Palindrome]]\n- [ ] [[GFG Median of 2 Sorted Arrays of Same Size]]\n- [ ] [[4.Â Median of Two Sorted Arrays]]\n- [ ] [[46.Â Permutations]]\n- [ ] [[Kth Something]]\n- [ ] [[Two Sum in BST]]\n\n\n\n## ð Linked List\n- [x] [[206.Â Reverse Linked List]]\n- [x] [[92.Â Reverse Linked List II]]\n- [x] [[Reverse LinkedList in Groups of K]]\n- [x] [[61.Â Rotate List]]\n- [x] [[Merge 2 Sorted Linked Lists]]\n- [x] [[GFG Detect Loop]]\n- [x] [[142.Â Linked List Cycle II]]\n- [x] [[GFG Remove Loop]]\n- [x] [[GFG Remove Duplicates]]\n- [x] [[GFG Add 1 to Linked List]]\n- [x] [[2. Add Two Numbers]]\n- [x] [[GFG Intersection of Two Sorted LLs]]\n- [x] [[160.Â Intersection of Two Linked Lists]]\n- [x] [[876.Â Middle of the Linked List]]\n- [x] [[148.Â Sort List]]\n- [x] [[GFG Split Circular Linked List into Two Halves]]\n- [x] [[GFG Check if Linked List is Palindrome]]\n- [x] [[GFG Reverse Doubly Linked List]]\n- [x] [[Reverse Doubly Linked List in Groups of K]]\n- [x] [[25.Â Reverse Nodes in k-Group]]\n- [x] [[Flatten a Linked List]]\n- [x] [[Sort Linked List if 0s, 1s and 2s]]\n- [x] [[Clone LL with Random Pointer]]\n- [x] [[Delete Nodes With Greater Value on Right]]\n- [x] [[First Non Repeating Character in Stream]]\n- [x] [[Swap Kth nodes from ends]]\n- [x] [[1721.Â Swapping Nodes in a Linked List]]\n- [x] [[23. Merge k Sorted Lists]]\n\n\n\n## ð² Binary Tree \n- [ ] [[Binary Tree]]\n- [x] [[Count and Sum of Nodes]]\n- [x] [[Height of a Tree]]\n- [x] [[Diameter of a Tree]]\n- [x] [[Subtree of Another Tree]]\n- [x] [[Reverse Level Order Traversal]]\n- [x] [[BT Sum at Kth Level]]\n- [x] [[1161.Â Maximum Level Sum of a Binary Tree]]\n- [x] [[863.Â All Nodes Distance K in Binary Tree]]\n- [x] [[226. Invert Binary Tree]]\n- [x] [[101.Â Symmetric Tree]]\n- [x] [[Iterative Traversals of BT]]\n- [x] [[Left and Right View]]\n- [x] [[GFG Boundary Traversal of BT]]\n- [x] [[Vertical Traversal of BT]]\n- [x] [[Top - Bottom View of a Tree]]\n- [x] [[Zig Zag Traversal]]\n- [x] [[Diagonal Traversal of BT]] \n- [x] [[Binary Tree to DLL]]\n- [x] [[Flatten Binary Tree to LL]]\n- [x] [[Balance Binary Tree]]\n- [x] [[105.Â Construct Binary Tree from Preorder and Inorder Traversal]]\n- [x] [[Sum Tree]]\n- [x] [[Leaf at same level]]\n- [x] [[652. Find Duplicate Subtrees]]\n- [x] [[297.Â Serialize and Deserialize Binary Tree]]\n- [x] [[GFG Sum of Longest Bloodline]]\n- [x] [[236.Â Lowest Common Ancestor of a Binary Tree]]\n- [x] [[437.Â Path Sum III]]\n- [ ] [[Maxiumum Sum of Non-Adjacent Nodes]]\n- [x] [[Kth Ancestor]]\n- [ ] [[106.Â Construct Binary Tree from Inorder and Postorder Traversal]]\n- [ ] [[Morris Traversals of Binary Tree]]\n- [ ] [[114. Flatten Binary Tree]] \n- [ ] [[Check if Tree is Isomorphic]]\n- [ ] [[1483.Â Kth Ancestor of a Tree Node]]\n- [ ] [[1530.Â Number of Good Leaf Nodes Pairs]]\n- [ ] [[222.Â Count Complete Tree Nodes]]\n- [ ] [[1448.Â Count Good Nodes in Binary Tree]]\n\n\n## ðBinary Search Tree\n- [ ] [[Binary Search Tree]]\n- [ ] [[98. Validate BST]]\n- [ ] [[230. Kth Smallest Element in a BST]]\n- [ ] [[Inorder Predecessor and Successor in BST]] \n- [ ] [[LCA in BST]]\n- [ ] [[Two Sum in BST]]\n- [ ] [[Flatten a BST]]\n- [ ] [[1382. Balance a Binary Search Tree]]\n- [ ] [[1008. Construct Binary Search Tree from Preorder Traversal]]\n- [ ] [[Populate Inorder Successor for all Nodes]]\n- [ ] [[Convert Sorted List to BST]]\n- [ ] [[Merge 2 BSTs]]\n- [ ] [[1932.Â Merge BSTs to Create Single BST]]\n- [ ] [[Two Sum with 2 BSTs]]\n- [ ] [[Replace every element with the least greater element on its right]]\n- [ ] [[Given n appointments, find all conflicting appointments]]\n- [ ] [[Check whether BST contains Dead End]]\n- [ ] [[Largest BST]]\n\n\n## ð DP\n- [ ] [[Dynamic Programming]]\n### 01 Knapsack\n- [x] [[494. Target Sum]]\n- [x] [[416. Partition Equal Subset Sum]]\n- [x] [[Count of Subsets witth given Sum ]]\n- [x] [[1049.Â Last Stone Weight II]]\n- [ ] [[956.Â Tallest Billboard]]\n- [ ] [[1.Â Two Sum2]]\n- [x] [[Bank Transactions]]\n\n### General\n- [ ] [[198.Â House Robber]]\n- [ ] [[Shortest Impossible Sequence of Rolls]]\n\n\n## ð¤Greedy\n- [ ] [[122.Â Best Time to Buy and Sell Stock II]]\n- [x] [[N meetings in one room]]\n- [x] [[920. Meeting Rooms]]\n- [x] [[919 Â· Meeting Rooms II]]\n- [x] [[56. Merge Intervals]]\n- [x] [[452.Â Minimum Number of Arrows to Burst Balloons]]\n- [x] [[435. Non-Overlapping Intervals]]\n- [x] [[986.Â Interval List Intersections]]\n- [x] [[Job Sequencing Problem]]\n- [x] [[Police and Thieves]]\n- [ ] [[322.Â Coin Change]]\n- [ ] [[518.Â Coin Change 2]]\n\n\n\n## ð§µStrings\n- [x] [[6095. Strong Password Checker II]]\n- [x] [[38.Â Count and Say]]\n- [ ] [[Remove Consecutive Characters]]\n- [ ] [[796.Â Rotate String]]\n- [x] [[Longest Palindrome in String]]\n- [x] [[316.Â Remove Duplicate Letters]]\n- [x] [[1143.Â Longest Common Subsequence]]\n- [x] [[Longest Repeating Subsequence]]\n- [x] [[Print all Subsequences of a String]]\n- [x] [[Permutations of a Given String]]\n- [ ] [[Word Wrap Problem]]\n- [x] [[Edit Distance]]\n- [x] [[Next Permutation]]\n- [x] [[Parenthesis Checker]]\n- [x] [[139.Â Word Break]]\n- [x] [[140.Â Word Break II]]\n- [x] [[Rabin Karp]]\n- [x] [[Count the Reversals]]\n- [x] [[686.Â Repeated String Match]]\n- [ ] [[Count Palindromic Subsequences]]\n- [x] [[FInd String in Grid]]\n- [x] [[13. Roman to Integer]]\n- [x] [[14. Longest Common Prefix]]\n- [x] [[Minimum Number of Flips]]\n- [x] [[1963. Minimum Number of Swaps to Make the String Balanced]]\n- [x] [[93. Restore IP Addresses]]\n- [x] [[Smallest Distinct Window]]\n- [x] [[76.Â Minimum Window Substring]]\n- [x] [[767. Reorganise Substring]]\n- [x] [[KMP Algo]]\n- [x] [[Minimum Characters to be added to front to make string Palindrome ]]\n- [x] [[1312.Â Minimum Insertion Steps to Make a String Palindrome]]\n- [x] [[44.Â Wildcard Matching]]\n- [x] [[Count Customers Who Did Not Get A Computer]]\n- [x] [[Transform String]]\n- [ ] [[2027.Â Minimum Moves to Convert String]]\n\n## Matrices\n- [x] [[867.Â Transpose Matrix]]\n\n## Heap\n- [x] [[215.Â Kth Largest Element in an Array]]\n- [ ] \n\n## Binary Search\n- [ ] [[34. Find First and Last Position of Element in Sorted Array]]\n- [ ] [[852. Peak Index in a Mountain Array]]\n- [x] [[2293. Min Max Game]]\n\n## Bit Manipulation\n- [ ] [[832.Â Flipping an Image]]\n- [ ] [[1252.Â Cells with Odd Values in a Matrix]]\n\n\n\n","lastmodified":"2024-07-04T20:24:17.037181919Z","tags":["Untagged"]},"/dsa/Maxiumum-Sum-of-Non-Adjacent-Nodes":{"title":"Maxiumum Sum of Non-Adjacent Nodes","content":"\n## Problem Statement\n\n\nPattern: [[Pattern Non-Adjacent Sum]]\nRelated: [[198. House Robber]]\n\n---\n\n## Solution\n``` java\nclass Pair {\n\tint inSum;\n\tint exSum;\n\tPair (int inSum, int exSum) {\n\t\tthis.inSum = inSum;\n\t\tthis.exSum = exSum;\n\t}\n}\n\n// post order traverse\nPair post(Node root) {\n\tif (root == null) return new Pair(0, 0);\n\t\n\tPair left = post(root.left);\n\tPair right = post(root.right);\n\t\n\tint inSum = root.val + left.exSum + right.exSum;\n\tint exSum = Math.max(left.inSum, left.exSum) + Math.max(right.inSum, right.exSum);\n\t\n\treturn new Pair(inSum, exSum);\n}\n\npublic int getMaxSum (Node root){\n\tPair pair = post(root);\n\treturn Math.max(pair.inSum, pair.exSum);\n}\n```\n\n### Notes\n- if include current node (`root` node)\n\t- add current value, to the excluded value of child nodes\n\t- add `root.val + left.exSum + right.exSum`\n- if excluding the `root` node\n\t- simply find the maximum possible sum from children nodes\n\t- `Math.max(left.inSum, left.exSum) + Math.max(right.inSum, right.exSum)`\n\nsimple as that\nno dp\n\n","lastmodified":"2024-07-04T20:24:17.037181919Z","tags":["dsadeck","binarytrees"]},"/dsa/Merge-2-BSTs":{"title":"Merge 2 BSTs","content":"\n## Problem Statement\n[Merge Two BSTs (codingninjas.com)](https://www.codingninjas.com/codestudio/problems/h_920474)\n\n\nPattern: \n\n---\n\n## List Sort Solution\n``` java\npublic ArrayList\u003cNode\u003e mergeLists(List\u003cNode\u003e l1, List\u003cNode\u003e l2) {  \n   ArrayList\u003cNode\u003e nodes = new ArrayList\u003c\u003e();  \n   int i = 0, j = 0;  \n   while (i \u003c l1.size() \u0026\u0026 j \u003c l2.size()) {  \n      if (l1.get(i).val \u003c= l2.get(j).val) nodes.add(l1.get(i++));  \n      else nodes.add(l2.get(j++));  \n   }  \n   while (i \u003c l1.size()) nodes.add(l1.get(i++));  \n   while (j \u003c l2.size()) nodes.add(l2.get(j++));  \n   return nodes;  \n}  \n  \npublic void dfs(Node root, ArrayList\u003cNode\u003e nodes) {  \n   if (root == null) return;  \n   nodes.add(root);  \n   dfs(root.left, nodes);  \n   dfs(root.right, nodes);  \n}  \n  \npublic Node inorderToBST(ArrayList\u003cNode\u003e nodes, int start, int end) {  \n   if (start \u003c end) return null;  \n   int mid = (end - start) / 2 + start;  \n   Node root = nodes.get(mid);  \n   root.left = inorderToBST(nodes, start, mid - 1);  \n   root.right = inorderToBST(nodes, mid + 1, end);  \n   return root;  \n}  \n  \npublic Node merge(Node root1, Node root2) {  \n   ArrayList\u003cNode\u003e nodes1 = new ArrayList\u003c\u003e();  \n   ArrayList\u003cNode\u003e nodes2 = new ArrayList\u003c\u003e();  \n   dfs(root1, nodes1);  \n   dfs(root2, nodes2);  \n   ArrayList\u003cNode\u003e nodes = mergeLists(nodes1, nodes2);  \n   return inorderToBST(nodes, 0, nodes.size() - 1);  \n}\n```\nTC : `O(m+n)`\nSC : `O(m+n)`\n\n## Optimal Solution\nConvert both BST into Linked\n``` java\nNode list;\n\nNode flatten(Node node, Node prev) {\n\tif (node == null) return prev;\n\t\n\tprev = flatten(node.right, prev);\n\tnode.right = prev;\n\tprev = node;\n\tprev = flatten(node.left, prev);\n\t\n\tnode.left = null;\n\t\n\treturn prev;\n}\n\nNode merge(Node a, Node b) {\n\tNode dh = new Node(-1), dummy = dh;\n\t\n\twhile (a != null \u0026\u0026 b != null) {\n\t\tif (a.val \u003c b.val) {\n\t\t\tdummy.right = a;\n\t\t\ta = a.right;\n\t\t} else {\n\t\t\tdummy.right = b;\n\t\t\tb = b.right;\n\t\t}\n\t\tdummy = dummy.right;\n\t}\n\t\n\tif (a == null) dummy.right = b;\n\telse dummy.right = a;\n\t\n\treturn dh.right;\n}\n\nint getSize(Node root) {\n\tint size = 0;\n\twhile (root != null) {\n\t\troot = root.right;\n\t\tsize++;\n\t}\n\treturn size;\n}\n\nNode bstify(int start, int end) {\n\tif(start \u003e end) return null;\n\t\n\tint mid = start + (end - start) / 2;\n\t\n\tNode left = bstify(start, mid - 1);\n\tNode curr = list; list = list.right;\n\tNode right = bstify(mid + 1, end);\n\t\n\tcurr.left = left; curr.right = right;\n\t\n\treturn curr;\n}\n\npublic Node mergeBST(Node a, Node b) {\n\t// flatten to linked lists\n\ta = flatten(a, null);\n\tb = flatten(b, null);\n\t// Merge Lists\n\tlist = merge(a, b);\n\t// Bstify LinkedList\n\treturn bstify(0, getSize(list) - 1);\n}\n```\nTC : `O(m+n)`\nSC : `O(h1 + h2)`","lastmodified":"2024-07-04T20:24:17.037181919Z","tags":["dsadeck","bst"]},"/dsa/Merge-2-Sorted-Linked-Lists":{"title":"Merge 2 Sorted Linked Lists","content":"\n## Problem Statement\n\n\nPattern: \n\n---\n\n## Solution\n``` java\nListNode merge(ListNode a, ListNode b) {\n\tif(a == null) return b;\n\tif(b == null) return a;\n\n\tListNode smaller, larger;\n\n\tsmaller = (a.val \u003c= b.val) ? a : b;\n\tlarger = (b.val \u003e= a.val) ? b : a;\n\n\tsmaller.next = merge(smaller.next, larger);\n\treturn smaller;\n}\n```\nTC : ` O(n+m) `\nSC : ` O(n+m) - stack`  \n\n### Notes\n- \n\n\n","lastmodified":"2024-07-04T20:24:17.037181919Z","tags":["dsadeck","linkedlist"]},"/dsa/Minimum-Characters-to-be-added-to-front-to-make-string-Palindrome":{"title":"Minimum Characters to be added to front to make string Palindrome","content":"\n## Problem Statement\n[Minimum characters to be added at front to make string palindrome - GeeksforGeeks](https://www.geeksforgeeks.org/minimum-characters-added-front-make-string-palindrome/)\n\nPattern: \n\n---\n\n## Naive Solution\n``` java\n// function for checking string is palindrome or not\nstatic boolean ispalindrome(String s) {\n\tint l = s.length();\n\tfor (int i = 0, j = l - 1; i \u003c= j; i++, j--) \n\t\tif (s.charAt(i) != s.charAt(j)) return false;\n\treturn true;\n}\n\n// Driver code\npublic static void main(String[] args) {\n\tString s = \"BABABAA\";\n\tint cnt = 0, flag = 0;\n\n\twhile (s.length() \u003e 0) {\n\t\t// if string becomes palindrome then break\n\t\tif (ispalindrome(s)) {\n\t\t\tflag = 1;\n\t\t\tbreak;\n\t\t} else {\n\t\t\tcnt++;\n\t\t\ts = s.substring(0, s.length() - 1);\n\t\t}\n\t}\n\t\n\tif (flag == 1) System.out.println(cnt);\n}\n```\nTC : $O(n^2)$\nSC : \n\n\u003e [! Concept]\n\u003e **Find the greatest palindrome starting from index 0**, remaining elements will have to be added reversed to the front of the string\n- Simply increase window size till string stops being a palindrome\n\t- `return str.length() - windowSize`\n- BottleNeck : Verifying palindrome takes O(n) time\n\n\n---\n\n## Optimal Solution\nWe could use the concept of a LPS Array from [[KMP Algo]]\n``` java\npublic static void getLps(String needle, int[] lps) {\n\tint currLps = 0, i = 1;\n\twhile (i \u003c needle.length())\n\t\tif (needle.charAt(i) == needle.charAt(currLps))\n\t\t\tlps[i++] = ++currLps;               // match        -\u003e   increment lps\n\t\telse if (currLps == 0) lps[i++] = 0;    // currLps = 0  -\u003e   lps not possible\n\t\telse currLps = lps[currLps - 1];        // currLps != 0 -\u003e   match against prev currLps\n}\n\npublic static int minChar(String str) {\n   //Write your code here\n   int len = str.length();\n   if(len \u003c 2) return 0;\n   \n   StringBuilder sb = new StringBuilder(str), rev =  new StringBuilder(str);\n   sb.append(\"$\").append(rev.reverse());\n   \n   int[] lps = new int[sb.length()];\n   getLps(sb.toString(), lps);\n   \n   return len - lps[sb.length()-1];\n}\n```\nTC : $O(n)$\n\n- LPS of the `sb` string will give is the longest plaindrome starting at 0 in `O(n)`\n\n\n\n\n\n","lastmodified":"2024-07-04T20:24:17.037181919Z","tags":["dsadeck","strings"]},"/dsa/Minimum-Number-of-Flips":{"title":"Minimum Number of Flips","content":"\n## Problem Statement\n[Min Number of Flips | Practice | GeeksforGeeks](https://practice.geeksforgeeks.org/problems/min-number-of-flips3210/1)\n\nPattern: \n\n---\n\n## Solution\n``` java\npublic int minFlips(String S) {\n\t// Code here\n\tint countZero = 0, countOne = 0;\n\t// zero-start\n\tboolean flag = false;\n\tfor(char ch : S.toCharArray()) {\n\t\tif(!flag \u0026\u0026 ch != '0') countZero++;\n\t\telse if(flag \u0026\u0026 ch != '1') countZero++; \n\t\tflag = !flag;\n\t} \n\t// one-start\n\tflag = true;\n\tfor(char ch : S.toCharArray()) {\n\t\tif(flag \u0026\u0026 ch != '1') countOne++; \n\t\telse if(!flag \u0026\u0026 ch != '0') countOne++;\n\t\tflag = !flag;\n\t} \n\t\n\treturn Math.min(countZero, countOne);\n}\n```\nTC : $O(n)$\nSC : $O(1)$\n\n### Notes\n- There are only 2 arrangements of alternating bits possible for any given string One starting with zero and other starting with one. Simply find the one that requires the least number of flips\n\n\n\n","lastmodified":"2024-07-04T20:24:17.037181919Z","tags":["dsadeck","strings"]},"/dsa/Minimum-Number-of-Merges-to-make-Palindrome":{"title":"Minimum Number of Merges to make Palindrome","content":"\n## Problem Statement\n[Find minimum number of merge operations to make an array palindrome - GeeksforGeeks](https://www.geeksforgeeks.org/find-minimum-number-of-merge-operations-to-make-an-array-palindrome/)\n\nPattern: \n\n---\n\n## Solution\n``` java\npublic int minMerges(int[] nums) {  \n   int merges = 0;  \n   int start = 0, end = nums.length - 1;  \n   while (start \u003c= end) {  \n      if (nums[start] \u003c nums[end]) {  \n         start++;  \n         nums[start] += nums[start - 1];  \n         merges++;  \n      } else if (nums[end] \u003c nums[start]) {  \n         end--;  \n         nums[end] += nums[end + 1];  \n         merges++;  \n      } else {  \n         start++;  \n         end--;  \n      }  \n   }   return merges;  \n}\n```\n\n### Notes\n- \n","lastmodified":"2024-07-04T20:24:17.037181919Z","tags":["dsadeck","arrays"]},"/dsa/Morris-Traversals-of-Binary-Tree":{"title":"Morris Traversals of Binary Tree","content":"[[Binary Tree#Traversals]]\n## Problem Statement\nTraverse a binary tree (inorder/postorder/preorder), using O(1) space, return root of tree\n\n## Definition Threaded Tree\n![[Pasted image 20220713173904.png]]\nA binary tree is threaded by making all right child pointers that would normally be null point to the inorder successor of the node (if it exists), and all left child pointers that would normally be null point to the inorder predecessor of the node.\n\nPattern: \nRelated: [Find median of BST in O(n) time and O(1) space - GeeksforGeeks](https://www.geeksforgeeks.org/find-median-bst-time-o1-space/)\n\n---\n\n## Inorder Traversal\n[Binary Tree Inorder Traversal - LeetCode](https://leetcode.com/problems/binary-tree-inorder-traversal/)\n\n### Pseudo Code\n``` txt\n1. Initialize current as root \n2. While current is not NULL\n   If current hs a left child\n      ifa) Make current as right child of the 'rightmost \n         node in current's left subtree' or its 'inorder predecessor'\n      ifb) Go to left child, i.e., current = current-\u003eleft\n   Else\n      ea) Print currentâs data\n      eb) Go to the right, i.e., current = current-\u003eright\n\n```\n\n### Java Code\n``` java\npublic ArrayList\u003cInteger\u003e inorder (TreeNode root){\n\tTreeNode curr = root;\n\tArrayList\u003cInteger\u003e res = new ArrayList\u003c\u003e();\n\t\n\twhile(curr != null) {\n\t\tif(curr.left != null) {\n\t\t\t// get inorder predecessor 'pred'\n\t\t\tTreeNode pred = curr.left;\n\t\t\twhile(pred.right != null \u0026\u0026 pred.right != curr) pred = pred.right;\n\t\t\t\n\t\t\tif(pred.right == null) {    // pred not connected to root/curr\n\t\t\t\tpred.right = curr;      // connect pred to root/curr\n\t\t\t\tcurr = curr.left;\n\t\t\t} else {                    // pred.right == curr (pred already connected to root/curr)\n\t\t\t\tpred.right = null;      // disconnect\n\t\t\t\tres.add(curr.data);     // print\n\t\t\t\tcurr = curr.right;      // traverse right subtree - inorder successor\n\t\t\t}\n\t\t} else { // curr.left -\u003e null\n\t\t\tres.add(curr.data);         // print\n\t\t\tcurr = curr.right;          // traverse right subtree\n\t\t}\n\t}\n\treturn res;\n}\n```\n- print \n\t- the second time you arrive at root `pred.right != null` because of `LNR`\n\t- when `curr.left == null`\n\n## Preorder Traversal\n[Binary Tree Preorder Traversal - LeetCode](https://leetcode.com/problems/binary-tree-preorder-traversal/)\n### Java Code\n``` java\npublic List\u003cInteger\u003e preorderTraversal (TreeNode root){\n\tTreeNode curr = root;\n\tArrayList\u003cInteger\u003e res = new ArrayList\u003c\u003e();\n\n\twhile(curr != null) {\n\t\tif(curr.left != null) {\n\t\t\t// get inorder predecessor 'pred'\n\t\t\tTreeNode pred = curr.left;\n\t\t\twhile(pred.right != null \u0026\u0026 pred.right != curr) pred = pred.right;\n\n\t\t\tif(pred.right == null) {    // pred not connected to root/curr\n\t\t\t\tpred.right = curr;      // connect pred to root/curr\n\t\t\t\tres.add(curr.val);     // print\n\t\t\t\tcurr = curr.left;\n\t\t\t} else {                    // pred.right == curr (pred already connected to root/curr)\n\t\t\t\tpred.right = null;      // disconnect\n\t\t\t\tcurr = curr.right;      // traverse right subtree - inorder successor\n\t\t\t}\n\t\t} else { // curr.left -\u003e null\n\t\t\tres.add(curr.val);         // print\n\t\t\tcurr = curr.right;          // traverse right subtree\n\t\t}\n\t}\n\treturn res;\n}\n```\n\n- print \n\t- the first time curr  is at the root node, not the second (i.e. when `pred.right == curr`, that means `curr` has been visited before)\n\t- and when `curr.left == null` \n\n## PostOrder Traversal\n``` java\n// right first preorder, in reverse = postorder\npublic List\u003cInteger\u003e postorder (TreeNode root){\n\tTreeNode curr = root;\n\tArrayList\u003cInteger\u003e res = new ArrayList\u003c\u003e();\n\t\n\twhile(curr != null) {\n\t\tif(curr.right != null) {\n\t\t\t// get inorder successor 'pred'\n\t\t\tTreeNode pred = curr.right;\n\t\t\twhile(pred.left != null \u0026\u0026 pred.left != curr) pred = pred.left;\n\t\t\t\n\t\t\tif(pred.left == null) {    // pred not connected to root/curr\n\t\t\t\tpred.left = curr;      // connect pred to root/curr\n\t\t\t\tres.add(curr.val);     // print\n\t\t\t\tcurr = curr.right;\n\t\t\t} else {                    // pred.left == curr (pred already connected to root/curr)\n\t\t\t\tpred.left = null;      // disconnect\n\t\t\t\tcurr = curr.left;      // traverse left subtree - inorder predecessor\n\t\t\t}\n\t\t} else { // curr.right -\u003e null\n\t\t\tres.add(curr.val);         // print\n\t\t\tcurr = curr.left;          // traverse left subtree\n\t\t}\n\t}\n\tCollections.reverse(res);\n\treturn res;\n}\n```\n- right first preorder, in reverse = postorder\n- traverse right subtree first\n- print root/curr on first traversal like you do in preorder\n- connect root's inorder successor `succ` to root on firs traversal\n- disconnect it on second traversal, and traverse `curr's` left subtree\n\n","lastmodified":"2024-07-04T20:24:17.037181919Z","tags":["dsadeck","binarytrees"]},"/dsa/N-meetings-in-one-room":{"title":"N meetings in one room","content":"\n## Problem Statement\n\n\nPattern: \nRelated: [[919 Â· Meeting Rooms II]]\n\n---\n\n## Solution\n``` java\nstatic class Interval{  \n   public int start;  \n   public int end;  \n   Interval(int s, int e) {  \n      this.start = s;  \n      this.end = e;  \n   }  \n}\n\npublic int maxMeetings(int[] start, int[] end, int n) {\n\tArrayList\u003cInterval\u003e intervals = new ArrayList\u003c\u003e();\n\tint count = 1;\n\t\n\tfor (int i = 0; i \u003c n; i++)\n\t\tintervals.add(new Interval(start[i], end[i]));\n\tintervals.sort((Comparator.comparingInt(o -\u003e o.end)));\n\t\n\tInterval prev = intervals.get(0);\n\tfor(Interval curr : intervals)\n\t\tif(curr.start \u003e prev.end) {\n\t\t\tcount++;\n\t\t\tprev = curr;\n\t\t}\n\t\n\treturn count;\n}\n```\n\n### Notes\n- Sort intervals by their `end`.\n- increase count, everytime you come across a valid interval i.e. `curr.start \u003e prev.end\n- `if(curr.start \u003e prev.end)` will be false for the first element, so count is initialised to  `count = 1`\n\n\n","lastmodified":"2024-07-04T20:24:17.037181919Z","tags":["dsadeck","intervals"]},"/dsa/Next-Permutation":{"title":"Next Permutation","content":"\n## Problem Statement\n\n\nPattern: \nRelated: [[31. Next Permutation]]\n\n---\n\n## Solution\n``` java\npublic static void swap(int[] x, int a, int b) {\n\tint t = x[a];\n\tx[a] = x[b];\n\tx[b] = t;\n}\n\nprivate static int getSuccessor(int[] nums, int pre) {\n\tint i = nums.length - 1, minIdx = i, minVal = Integer.MAX_VALUE;\n\twhile (i \u003e pre) {\n\t\tif (nums[i] \u003c minVal \u0026\u0026 nums[pre] \u003c nums[i]) {\n\t\t\tminIdx = i;\n\t\t\tminVal = nums[i];\n\t\t}\n\t\ti--;\n\t}\n\treturn minIdx;\n}\n\nprivate static int getPredecessor(int[] nums) {\n\tint pre = nums[nums.length - 1];\n\tfor (int i = nums.length - 2; i \u003e= 0; i--) {\n\t\tif (nums[i] \u003c pre) return i;\n\t\tpre = nums[i];\n\t}\n\treturn -1;\n}\n\n\nstatic List\u003cInteger\u003e nextPermutation(int N, int[] nums) {\n\tArrayList\u003cInteger\u003e res = new ArrayList\u003c\u003e();\n\tfor (int num : nums) res.add(num);\n\tif (N \u003c 2) return res;\n\t\n\t// find predecessor\n\tint pre = getPredecessor(nums);\n\t// if no predecessor return sorted array\n\tif (pre == -1) {\n\t\tCollections.sort(res);\n\t\treturn res;\n\t}\n\t// find successor to predecessor\n\tint succ = getSuccessor(nums, pre);\n\t\n\tswap(nums, pre, succ);                      // swap\n\tArrays.sort(nums, pre + 1, N);  // sort\n\t\n\tfor (int i = 0; i \u003c N; i++) res.set(i, nums[i]);\n\treturn res;\n}\n```\nTC : $nlogn$\nSC : \n\n### Notes\n- \n\n\n\n","lastmodified":"2024-07-04T20:24:17.037181919Z","tags":["dsadeck","arrays"]},"/dsa/Numbers-divisible-by-a-or-b-in-range-n":{"title":"Numbers divisible by a or b in range n","content":"\n## Problem Statement\n\n\nPattern: [[Pattern Inclusion Exclusion Principle]]\n\n---\n\n## Solution\nKeyword OR\n``` java\nint divisible (int n, int a, int b) {\n\tint countA = n/a;\n\tint countB = n/b;\n\tint countAB = n/(a*b);\n\treturn countA + countB - countAB;\n\t\n}\n```\nTC : \nSC : \n\n### Notes\n- \n\n\n\n","lastmodified":"2024-07-04T20:24:17.037181919Z","tags":["dsadeck","arithmetic"]},"/dsa/Parenthesis-Checker":{"title":"Parenthesis Checker","content":"\n## Problem Statement\n\n\nPattern: \n\n---\n\n## Solution\n``` java\nstatic boolean ispar(String str) {\n\t// add your code here\n\tDeque\u003cCharacter\u003e stack = new LinkedList\u003c\u003e();\n\tfor (char ch : str.toCharArray()) {\n\t\tif (ch == '{' || ch == '(' || ch == '[') stack.push(ch);\n\t\telse {\n\t\t\tif (stack.isEmpty()) return false;\n\t\t\tchar pop = stack.pop();\n\t\t\tif (ch == '}' \u0026\u0026 pop != '{') return false;\n\t\t\tif (ch == ')' \u0026\u0026 pop != '(') return false;\n\t\t\tif (ch == ']' \u0026\u0026 pop != '[') return false;\n\t\t}\n\t}\n\treturn stack.isEmpty();\n}\n```\nTC : $O(n)$\nSC : $O(n)$\n\n### Notes\n- \n\n\n\n","lastmodified":"2024-07-04T20:24:17.037181919Z","tags":["dsadeck","strings","stacks"]},"/dsa/Permutations-of-a-Given-String":{"title":"Permutations of a Given String","content":"\n## Problem Statement\n\n\nPattern: \n\n---\n\n## Solution\n``` java\nArrayList\u003cString\u003e res;\n\npublic void swap (char[] chars, int a, int b ) {\n\tchar temp = chars[a];\n\tchars[a] = chars[b];\n\tchars[b] = temp;\n}\n\npublic void p (char[] chars, int start) {\n\tif(start == chars.length-1) {\n\t\tres.add(new String(chars));\n\t\treturn;\n\t}\n\t\t\n\tfor(int i = start; i \u003c chars.length; i++) {\n\t\tswap(chars, i, start);\n\t\tp(chars, start + 1);\n\t\tswap(chars, i, start);\n\t}\n}\n\npublic List\u003cString\u003e find_permutation(String S) {\n\t// Code here\n\tres = new ArrayList\u003cString\u003e();\n\tp(S.toCharArray(), 0);\n\treturn res;\n}\n```\nTC : $n * n!$\nSC : \n\n### Notes\n- \n\n\n\n","lastmodified":"2024-07-04T20:24:17.037181919Z","tags":["dsadeck","strings"]},"/dsa/Police-and-Thieves":{"title":"Police and Thieves","content":"\n## Problem Statement\n\n\nPattern: \n\n---\n\n## Solution\n``` java\npublic int catchThieves(char[] arr, int n, int k) {\n\tint t = 0, p = 0, caught = 0;\n\t// set p and t\n\twhile (p \u003c n \u0026\u0026 arr[p] != 'P') p++;\n\twhile (t \u003c n \u0026\u0026 arr[t] != 'T') t++;\n\t\n\twhile (t \u003c n \u0026\u0026 p \u003c n) {\n\t\t// out of range\n\t\tif (Math.abs(t - p) \u003e k) {\n\t\t\tif (t \u003e p) do p++; while (p \u003c n \u0026\u0026 arr[p] != 'P');\n\t\t\telse do t++; while (t \u003c n \u0026\u0026 arr[t] != 'T');\n\t\t}\n\t\t\n\t\t// in range\n\t\telse {\n\t\t\tcaught++;\n\t\t\tdo p++; while (p \u003c n \u0026\u0026 arr[p] != 'P');\n\t\t\tdo t++; while (t \u003c n \u0026\u0026 arr[t] != 'T');\n\t\t}\n\t}\n\treturn caught;\n}\n```\n\n### Notes\n- we alott policement to theives in the order that they appear.\n- #tboptimised \n\t- [x] understand why other approaches dont work, and why this works\n\t- [ ] \n\t- [Mock Coding Interview with incoming SDE at Microsoft - @Nishant Chahar, YouTuber with 50K+ subs - YouTube](https://www.youtube.com/watch?v=MFkqnGiCCiU)\n\nsomething about something lik\n\n","lastmodified":"2024-07-04T20:24:17.037181919Z","tags":["dsadeck","greedy"]},"/dsa/Populate-Inorder-Successor-for-all-Nodes":{"title":"Populate Inorder Successor for all Nodes","content":"\n## Problem Statement\n[Populate Inorder Successor for all nodes | Practice | GeeksforGeeks](https://practice.geeksforgeeks.org/problems/populate-inorder-successor-for-all-nodes/1)\n\n\nPattern: \n\n---\n\n## Solution\n``` java\npublic void populateNext(Node root){\n\tDeque\u003cNode\u003e stack = new LinkedList\u003c\u003e();\n\tNode node = root, pre = null;\n\twhile(node!=null || !stack.isEmpty()) {\n\t\tif(node!=null){\n\t\t\tstack.push(node);\n\t\t\tnode = node.left;\n\t\t} else {\n\t\t\tnode = stack.pop();\n\t\t\tif(pre!=null) pre.next = node;\n\t\t\tpre = node;\n\t\t\tnode = node.right;\n\t\t}\n\t}\n}\n```\n\n### Notes\n- jsut a laggin pointer, pointing its next to the curr `node` ptr\n\n","lastmodified":"2024-07-04T20:24:17.037181919Z","tags":["dsadeck","bst"]},"/dsa/Print-all-Subsequences-of-a-String":{"title":"Print all Subsequences of a String","content":"\n## Problem Statement\n\n\nPattern: \n\n---\n\n## Solution\n``` java\nstatic void dp(char[] s, int n, StringBuilder sb) {\n\tif(n \u003c= 0) {\n\t\tSystem.out.println(sb.reverse());\n\t\tsb.reverse();\n\t\treturn;\n\t}\n\t\n\tdp(s, n-1, sb.append(s[n-1]));\n\tif(sb.length() \u003e 0) sb.delete(sb.length()-1, sb.length());\n\tdp(s, n-1, sb);\n}\n\n// region MAIN\npublic static void main(String[] args) {\n\tdp(\"Something\".toCharArray(), \"Something\".length(), new StringBuilder());\n}\n```\nTC : $2^n$\nSC : $2^n$\n\n\n### Notes\n- can be optimised with memoisation\n\n\n\n\n","lastmodified":"2024-07-04T20:24:17.037181919Z","tags":["dsadeck","strings"]},"/dsa/Rabin-Karp":{"title":"Rabin Karp","content":"\n## Problem Statement\nString Matching with Rolling Hash in less than $O(m*n)$\n[Abdul Bari Explanation](https://www.youtube.com/watch?v=qQ8vS2btsxI)\n[Explanation and Code](https://www.programiz.com/dsa/rabin-karp-algorithm)\n\n\nPattern: [[Pattern String Matching]]\nRelated: [[KMP Algo]]\n\n---\nRolling Hash Formula\n![](https://i.imgur.com/waDKIVj.jpg)\n\n\n## Solution\n``` java\n// RABIN KARP ROLLING HASH ALGO\npublic static int getIndex(String pattern, String text) {\n\tint n = pattern.length(), m = text.length(),\n\t\tset = 128, MOD = 8_388,\n\t\tnset = 1, pHash = 0, tHash = 0;\n\tif(m \u003c n) return -1;\n\t\n\t// get nset\n\tfor(int i = 0; i \u003c n-1 ; i++) nset = (nset * set) % MOD;\n\t\n\t// get pattern \u0026 text hash\n\tfor (int i = n - 1; i \u003e= 0; i--) {\n\t\tpHash = (set * pHash + pattern.charAt(n-1-i)) % MOD;\n\t\ttHash = (set * tHash + text.charAt(n-1-i)) % MOD;\n\t}\n\n\t// roll hash\n\tif(tHash == pHash \u0026\u0026 text.substring(0, n).equals(pattern)) return 0;\n\tfor (int i = 1; i \u003c= m-n; i++) {\n\t\t// update text hash\n\t\tint pre = text.charAt(i-1), post = text.charAt(i+n-1);\n\t\ttHash = (set * (tHash - (pre * nset)) + post) % MOD ;\n\t\tif(tHash \u003c 0) tHash += MOD; // Avoid Integer Overflow\n\t\t// compare hashes\n\t\tif(tHash == pHash \u0026\u0026 text.substring(i, i+n).equals(pattern)) return i;\n\t}\n\treturn -1;\n}\n```\nTC : $O(m * n)$\nSC : $O(1)$\n\n![](https://i.imgur.com/HZcWCgv.png)","lastmodified":"2024-07-04T20:24:17.037181919Z","tags":["dsadeck","strings","concept"]},"/dsa/Remove-Consecutive-Characters":{"title":"Remove Consecutive Characters","content":"\n## Problem Statement\n[Remove Consecutive Characters | Practice | GeeksforGeeks](https://practice.geeksforgeeks.org/problems/consecutive-elements2306/1)\nRemove adjacent duplicates recursively\n\nPattern: \n\n---\n\n## Solution\n``` java\npublic char add (StringBuilder sb, String s, int i) {\n\tif(i == s.length()) return '#';\n\t\n\tchar next = add(sb, s, i+1);\n\tchar curr = s.charAt(i);\n\tif (curr != next) sb.append(curr);\n\t\n\treturn curr;\n}\n\npublic String removeConsecutiveCharacter(String S){\n\tStringBuilder sb = new StringBuilder();\n\tadd(sb, S, 0);\n\treturn sb.reverse().toString();\n} \n```\nTC : $O(n)$\nSC : $O(n)$\n\n\n\n\n","lastmodified":"2024-07-04T20:24:17.037181919Z","tags":["dsadeck","strings"]},"/dsa/Replace-every-element-with-the-least-greater-element-on-its-right":{"title":"Replace every element with the least greater element on its right","content":"\n## Problem Statement\n\n\nPattern: \n\n---\n\n## Trivial Solution â\n``` java\npublic static ArrayList\u003cInteger\u003e findLeastGreater(int n, int[] arr) {\n\t// code here\n\tArrayList\u003cInteger\u003e res = new ArrayList\u003c\u003e(n);\n\tfor(int i = 0; i \u003c n ; i++) {\n\t\tint min = -1;\n\t\tfor(int j = i+1 ; j \u003c n ; j++) \n\t\t\tmin = (arr[j] \u003e arr[i] \u0026\u0026 (min == -1 || arr[j] \u003c min)) ? arr[j] : min;\n\t\tres.add(min);\n\t}\n\treturn res;\n}\n```\nTC : ` n^2 `\nSC : ` n `\n\n## Optimal Solution\n``` java\npublic ArrayList\u003cInteger\u003e findLeastGreater(int n, int[] arr) {\n\tLinkedList\u003cInteger\u003e res = new LinkedList\u003c\u003e();\n\tTreeSet\u003cInteger\u003e set = new TreeSet\u003c\u003e();\n\tfor (int i = n - 1; i \u003e= 0; i--) {\n\t\tset.add(arr[i]);\n\t\tInteger greater = set.higher(arr[i]);\n\t\tif (greater == null) res.addFirst(-1);\n\t\telse res.addFirst(greater);\n\t}\n\treturn new ArrayList\u003c\u003e(res);\n}\n```\nTC : ` nlogn `\nSC : ` n \n\n- We iterate over `arr[i]` from the end, finding the inorder successor `set.higher(arr[i])`, and adding it to the list ð¤·\n- Why `TreeSet` ?\n\t- It is a self balancing bst, so the complexity cannot be `n^2` even if the array is in descending order\n\n\n\n","lastmodified":"2024-07-04T20:24:17.037181919Z","tags":["dsadeck","bst"]},"/dsa/Reverse-Doubly-Linked-List-in-Groups-of-K":{"title":"Reverse Doubly Linked List in Groups of K","content":"\n## Problem Statement\n\n\nPattern: \n\n---\n\n## Solution\n``` java\npublic Node revListInGroupOfGivenSize(Node head, int K){\n\tNode curr = head, prev = null;\n\tint count = 0;\n\t\n\t// let prev be the leading pointer of the new reversed LL\n\t// and keep inserting `curr` (leading ptr of leftover LL)\n\t// before `prev`\n\t\n\twhile(curr != null \u0026\u0026 count++ \u003c K) {\n\t\tNode next = curr.next;\n\t\t\n\t\tcurr.prev = null;\n\t\tcurr.next = prev;\n\t\tif(prev!=null) prev.prev = curr;\n\t\t\n\t\tprev = curr;\n\t\tcurr = next;\n\t}\n\t\n\tif(curr != null) {\n\t\thead.next = revListInGroupOfGivenSize(curr, K);\n\t\thead.next.prev = head;\n\t}\n\t\n\treturn prev;\n}\n```\n\n### Notes\n- much like [[GFG Reverse Doubly Linked List]]\n\n","lastmodified":"2024-07-04T20:24:17.037181919Z","tags":["dsadeck","linkedlist"]},"/dsa/Reverse-Level-Order-Traversal":{"title":"Reverse Level Order Traversal","content":"\n## Problem Statement\n\n\nPattern: \n\n---\nOnce you know  [[Binary Tree#Level Order Traversals|Level Order Traversal]] , \n\n## Solution\n``` java\npublic ArrayList\u003cInteger\u003e reverseLevelOrder(Node root) {\n\tif(root == null) return new ArrayList\u003cInteger\u003e();\n\t// result list\n\tArrayList\u003cInteger\u003e res = new ArrayList\u003c\u003e();\n\t\n\t// queue to iterate over BT\n\tQueue\u003cNode\u003e q = new LinkedList\u003cNode\u003e();\n\tq.add(root);\n\twhile (!q.isEmpty()) {\n\t\tNode node = q.poll();\n\t\tres.add(node.val);\n\t\t\n\t\tif(node.right != null) q.add(node.right);\n\t\tif(node.left != null) q.add(node.left);\n\t}\n\tCollections.reverse(res);\n\treturn res;\n}\n```\n\n## ArrayList Solution\n[Binary Tree Level Order Traversal II - LeetCode](https://leetcode.com/problems/binary-tree-level-order-traversal-ii/)\n``` java\npublic List\u003cList\u003cInteger\u003e\u003e levelOrderBottom(TreeNode root) {\n\t\n\tList\u003cList\u003cInteger\u003e\u003e res = new ArrayList\u003c\u003e();\n\tif(root == null) return res;\n\n\tQueue\u003cTreeNode\u003e q = new LinkedList\u003cTreeNode\u003e();\n\tq.add(root);\n\twhile (!q.isEmpty()) {\n\t\tint size = q.size();\n\t\tArrayList\u003cInteger\u003e level = new ArrayList\u003c\u003e();\n\t\twhile(size-- \u003e 0) {\n\t\t\tTreeNode node = q.poll();\n\t\t\tlevel.add(node.val);\n\t\t\tif(node.left != null) q.add(node.left); \n\t\t\tif(node.right != null) q.add(node.right); \n\t\t}\n\t\tres.add(level);\n\t}\n\tCollections.reverse(res);\n\treturn res;\n}\n```\n### Notes\n- This Question is a slight modification of **Level Order Traversal using an Iterative Queue**: ![[Binary Tree#Level Order Traversals#Iterative Queue O n]]\n- In this one\n\t- Add the ***right node to the queue first, then the left node***\n\t- In the end we get an ArrayList with \n\t\t- levels in fwds\n\t\t- nodes in a level are in reverse\n\t- now if we ***reverse the `res` ArrayList*** we get \n\t\t- all the levels in reverse\n\t\t- nodes in level are fwds\n\n","lastmodified":"2024-07-04T20:24:17.037181919Z","tags":["dsadeck","binarytrees"]},"/dsa/Reverse-LinkedList-in-Groups-of-K":{"title":"Reverse LinkedList in Groups of K","content":"\n## Problem Statement\n[Reverse a Linked List in groups of given size. | Practice | GeeksforGeeks](https://practice.geeksforgeeks.org/problems/reverse-a-linked-list-in-groups-of-given-size/1)\nPattern: \n\n---\n\n## Solution\n``` java\nNode successor;\n\nNode reverseN (Node head, int k) {\n\tif(head.next== null || k == 1) {\n\t\tsuccessor = head.next;\n\t\treturn head;\n\t}\n\t\n\tNode newHead = reverseN (head.next, k-1);\n\thead.next.next= head;                   // point next to self\n\thead.next = null;                       // point self to null\n\t\n\treturn newHead;\n}\n\nNode reverse(Node head, int k)\n{\n\tNode dummy = new Node(-1), dummyHead = dummy;\n\tdummy.next = head; successor = head;\n\t\n\twhile(dummy != null \u0026\u0026 successor != null) {\n\t\tdummy.next = reverseN(successor, k);\n\t\tfor (int i = 0 ; i \u003c k \u0026\u0026 dummy != null; i++) dummy = dummy.next;\n\t}\n\t\n\treturn dummyHead.next;\n}\n```\n\n### Notes\n- \n\n","lastmodified":"2024-07-04T20:24:17.037181919Z","tags":["dsadeck","linkedlist"]},"/dsa/Shortest-Impossible-Sequence-of-Rolls":{"title":"Shortest Impossible Sequence of Rolls","content":"\n## Problem Statement\n[Shortest Impossible Sequence of Rolls - LeetCode Contest](https://leetcode.com/contest/biweekly-contest-83/problems/shortest-impossible-sequence-of-rolls/)\n\nPattern: \n\n---\n\n## Solution\n``` java\n\n```\nTC : ` \u003c% tp.file.cursor(3) %\u003e `\nSC : ` \u003c% tp.file.cursor(4) %\u003e `\n\n### Notes\n- \n\n\n","lastmodified":"2024-07-04T20:24:17.037181919Z","tags":["dsadeck","dp"]},"/dsa/Smallest-Distinct-Window":{"title":"Smallest Distinct Window","content":"\n## Problem Statement\n\n\nPattern: \nRelated: [[632. Smallest Range Covering Elements from K Lists]]\n\n---\n\n## Solution\n``` java\npublic int getInterval (Integer[] indices) {\n\tint min = Integer.MAX_VALUE, max = Integer.MIN_VALUE;\n\tfor (Integer index : indices) {\n\t\tif(index != null) {\n\t\t\tif(index == -1) return -1;      // interval not ready\n\t\t\tmin = Math.min(min, index);\n\t\t\tmax = Math.max(max, index);\n\t\t}\n\t}\n\treturn max-min+1;\n}\n\npublic int findSubString(String str) {\n\t// Your code goes here\n\tInteger[] indices = new Integer[256];\n\tfor(char ch : str.toCharArray()) indices[ch] = -1;\n\t\n\t// find minimum interval\n\tint min = Integer.MAX_VALUE;\n\tfor (int i = 0 ; i \u003c str.length() ; i++) {\n\t\tindices[str.charAt(i)] = i;\n\t\tint interval = getInterval(indices);\n\t\tif (interval != -1)  min = Math.min(min, interval);\n\t}\n\treturn min;\n}\n```\nTC : $O(n)$\nSC : $O(n)$\n\n### Notes\n- Hashmap in this problem was causing collisions\n\n\n\n\n","lastmodified":"2024-07-04T20:24:17.037181919Z","tags":["dsadeck","strings"]},"/dsa/Smallest-sum-contiguous-subarray":{"title":"Smallest sum contiguous subarray","content":"\n## Problem Statement\n[Smallest sum contiguous subarray | Practice | GeeksforGeeks](https://practice.geeksforgeeks.org/problems/smallest-sum-contiguous-subarray/1/#)\n\nPattern: [[Pattern Kadane's Algorithm]]\n\n---\n\n## Solution\n``` java\npublic static int smallestSumSubArray(int a[], int size) {\n\tint minSum = Integer.MAX_VALUE, currMinSum = 0;\n\tfor (int i = 0; i \u003c size; i++) {\n\t\tif (currMinSum \u003e 0) currMinSum = a[i];\n\t\t//if (currMinSum \u003e 0) currMinSum = 0; // if smallest subArray can be empty\n\t\telse currMinSum += a[i];\n\t\tminSum = Math.min(minSum, currMinSum);\n\t}\n\treturn minSum;\n}\n```\n\n### Notes\n- Reset sum to the next element everytime `currSum` reaches 0\n\t- update `minSum` on every iteration\n\n\n","lastmodified":"2024-07-04T20:24:17.037181919Z","tags":["easy","arrays","completed","subarrays","dsadeck"]},"/dsa/Sort-Linked-List-if-0s-1s-and-2s":{"title":"Sort Linked List if 0s, 1s and 2s","content":"\n## Problem Statement\n\n\nPattern: \nRelated: [[GFG Three Way Paritioning]]\n[Segregate even and odd nodes in a Link List | Practice | GeeksforGeeks](https://practice.geeksforgeeks.org/problems/segregate-even-and-odd-nodes-in-a-linked-list5035/1)\n\n---\n\n## Solution\n``` java\nstatic Node segregate(Node head)\n{\n\tNode dummy = new Node(-1), currHead = new Node(-1), curr = currHead;\n\tdummy.next = head;\n\t\n\tNode node = dummy;\n\twhile(node!= null \u0026\u0026 node.next != null) {\n\t\tif(node.next.data \u003c 1) {\n\t\t\tcurr.next = node.next;\n\t\t\tcurr = curr.next;\n\t\t\tnode.next = node.next.next;\n\t\t}\n\t\telse node = node.next;\n\t}\n\t\n\tnode = dummy;\n\twhile(node!= null \u0026\u0026 node.next != null) {\n\t\tif(node.next.data == 1){\n\t\t\tcurr.next = node.next;\n\t\t\tcurr = curr.next;\n\t\t\tnode.next = node.next.next;\n\t\t}\n\t\telse node = node.next;\n\t}\n\tnode = dummy;\n\twhile(node!=null \u0026\u0026 node.next!=null){\n\t\tcurr.next = node.next;\n\t\tcurr = curr.next;\n\t\tnode = node.next;\n\t}\n\treturn currHead.next;\n}\n```\n\n\n## Simpler \n``` java\npublic static Node sortList(Node head)\n{\n\tif(head==null || head.next==null) return head;\n\n\tNode zeroD = new Node(0), oneD = new Node(0), twoD = new Node(0);\n\tNode zero = zeroD, one = oneD, two = twoD, curr = head;\n\twhile (curr!=null)\n\t{\n\t\tif (curr.data == 0)\n\t\t{\n\t\t\tzero.next = curr;\n\t\t\tzero = zero.next;\n\t\t}\n\t\telse if (curr.data == 1)\n\t\t{\n\t\t\tone.next = curr;\n\t\t\tone = one.next;\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttwo.next = curr;\n\t\t\ttwo = two.next;\n\t\t}\n\t\tcurr = curr.next;\n\t}\n\t// Attach three lists\n\tzero.next = (oneD.next!=null) ? (oneD.next) : (twoD.next);\n\tone.next = twoD.next;\n\ttwo.next = null;\n\treturn zeroD.next;\n}\n\n```\n\n","lastmodified":"2024-07-04T20:24:17.037181919Z","tags":["dsadeck","linkedlist"]},"/dsa/Subtree-of-Another-Tree":{"title":"Subtree of Another Tree","content":"\n## Problem Statement \n[Subtree of Another Tree - LeetCode](https://leetcode.com/problems/subtree-of-another-tree/)\n\nPattern: \n\n---\n\n## Solution\n``` java\nprivate boolean compare(Node A, Node B) {\n\t// BASE CASES\n\tif (A == null \u0026\u0026 B == null) return true;   // if both are null\n\tif (A == null || B == null) return false;   // if only one is null\n\t\n\t// if A == B, check left and right\n\tif (A.val == B.val)\n\t\treturn compare(A.left, B.left) \u0026\u0026 compare(A.right, B.right);\n\t\n\treturn false;\n}\n\npublic boolean isSubtree(Node root, Node subRoot) {\n\t// BASE CASES\n\tif (subRoot == null) return true;\n\tif (root == null) return false;\n\n\t// return if root is identical to subRoot\n\tif(compare(root, subRoot)) return true;\n\t\n\t// recurse and return for root.left and root.right\n\treturn isSubtree(root.left, subRoot) || isSubtree(root.right, subRoot);\n} \n```\n\n### Notes\n- start matching the subtree with each tree node, starting from the root and recursing left and right\n\n","lastmodified":"2024-07-04T20:24:17.037181919Z","tags":["dsadeck","binarytrees"]},"/dsa/Sum-Tree":{"title":"Sum Tree","content":"\n## Problem Statement\n\n\nPattern: \n\n---\n\n## Check if BT is Sum Tree\n[Sum Tree | Practice | GeeksforGeeks](https://practice.geeksforgeeks.org/problems/sum-tree/1#)\n``` java\nboolean isSum = true;\n\nboolean isLeaf (Node root) {return (root.left == null \u0026\u0026 root.right == null);}\n\nint check(Node root) {\n\tif (root == null || !isSum) return 0;\n\n\tint lsum = check(root.left);\n\tint rsum = check(root.right);\n\t\n\tif(!isLeaf(root) \u0026\u0026 (root.data != lsum+rsum)) \n\t\tisSum = false;\n\t\n\treturn lsum+rsum+root.data;\n}\n\nboolean isSumTree(Node root)\n{\n\tcheck(root);\n\treturn isSum;\n}\n```\n\n\n# Transform to Sum tree\n[Transform to Sum Tree | Practice | GeeksforGeeks](https://practice.geeksforgeeks.org/problems/transform-to-sum-tree/1)\n``` java\npublic int sum (Node root) {\n\tif(root == null) return 0;\n\t\n\tint lSum = sum(root.left);\n\tint rSum = sum(root.right);\n\t\n\tint rootVal = root.data;\n\troot.data = lSum + rSum;\n\treturn rootVal +lSum + rSum;\n}\n\npublic void toSumTree(Node root){\n\t //add code here.\n\t sum(root);\n}\n```\n","lastmodified":"2024-07-04T20:24:17.037181919Z","tags":["dsadeck","binarytrees"]},"/dsa/Swap-Kth-nodes-from-ends":{"title":"Swap Kth nodes from ends","content":"\n## Problem Statement\n\n\nPattern: \nRelated: [[1721. Swapping Nodes in a Linked List]]  \n\n---\n\n## Solution\n``` java\nvoid swap(Node pa, Node pb){\n\tNode a = pa.next, b = pb.next;\n\tpa.next = b;\n\tpb.next = a;\n\t\n\tNode temp = a.next;\n\ta.next = b.next;\n\tb.next = temp;\n}\n//Function to swap Kth node from beginning and end in a linked list.\nNode swapkthnode(Node head, int num, int K)\n{\n\tNode newHead = new Node(-1), pa = newHead, pb = newHead, a = head, b = head;\n\tnewHead.next = head;\n\tint count = 0;\n\twhile(count++ \u003c K) {\n\t\tpa = pa.next;\n\t\ta=a.next;\n\t}\n\n\twhile(a.next!= null) {\n\t\tpb = pb.next;\n\t\tb = b.next;\n\t}\n\t\n\tswap(pa, pb);\n\treturn newHead.next;\n}\n```\n\n### Notes\n- \n\n","lastmodified":"2024-07-04T20:24:17.037181919Z","tags":["dsadeck","linkedlist"]},"/dsa/Top-Bottom-View-of-a-Tree":{"title":"Top - Bottom View of a Tree","content":"\n## Problem Statement\n[Top View of Binary Tree | Practice | GeeksforGeeks](https://practice.geeksforgeeks.org/problems/top-view-of-binary-tree/1)\nPattern: \n\n---\n\n## Top View Solution\n``` java\nstatic class AxisNode {\n\tint axis;\n\tNode node;\n\t\n\tAxisNode(int axis, Node node) {\n\t\tthis.axis = axis;\n\t\tthis.node = node;\n\t}\n}\npublic ArrayList\u003cInteger\u003e topView (Node root){\n\tTreeMap\u003cInteger, Integer\u003e axesMap = new TreeMap\u003c\u003e();\n\tQueue\u003cAxisNode\u003e q = new LinkedList\u003c\u003e();\n\n\tif (root == null) return new ArrayList\u003c\u003e();  // return empty list\n\n\t// levelorder traversal to create axesMap\n\tq.add(new AxisNode(0, root));\n\twhile (!q.isEmpty()) {\n\t\t// get axis \u0026 node\n\t\tAxisNode an = q.remove();\n\t\tint axis = an.axis;\n\t\tNode node = an.node;\n\t\t\n\t\tif (!axesMap.containsKey(axis)) axesMap.put(axis, node.val);\n\t\n\t\tif (node.left != null) q.add(new AxisNode(axis - 1, node.left));\n\t\tif (node.right != null) q.add(new AxisNode(axis + 1, node.right));\n\t}\n\n\treturn new ArrayList\u003c\u003e(axesMap.values());\n}\n```\n\n### Notes\n- A slight modification of [[Vertical Traversal of BT]]\n\t- Here we **only need the first node of a vertical axis reached through level order traversal**\n\t- so instead of using a `TreeMap\u003cInteger , LinkedList\u003cIntger\u003e\u003e` we only need a `TreeMap\u003cInteger , Integer\u003e`\n\t- thats it ð¤·ââï¸\n\n## Bottom View Solution\n- Slight Modification to top view\n\t- Here we **only need the LAST node of a vertical axis reached through level order traversal**\n\t- remove the if condition\n``` java\n axesMap.put(axis, node.val);\n```\n","lastmodified":"2024-07-04T20:24:17.037181919Z","tags":["dsadeck","binarytrees"]},"/dsa/Transform-String":{"title":"Transform String","content":"\n## Problem Statement\n\n\nPattern: \n\n---\n\n## Solution\n``` java\nint transform (String A, String B)\n{\n\t// check if possible\n\tif (A.length() != B.length()) return -1;\n\t\n\t// check count of all characters\n\tint[] count = new int[256];\n\tint len = A.length();\n\tfor (int i = 0 ; i \u003c len ; i++){\n\t\tcount[A.charAt(i)]++;\n\t\tcount[B.charAt(i)]--;\n\t}\n\tfor (int num : count) if (num != 0) return -1;\n\t\n\t// return operations\n\tint operations = 0, i = len-1, j = len-1;\n\t\n\twhile (i \u003e= 0) {\n\t\tif(A.charAt(i) != B.charAt(j)) operations++;\n\t\telse j--;\n\t\ti--;\n\t}\n\treturn operations;\n}\n```\nTC : $O(n)$\nSC : $O(1)$\n\n### Notes\n- Any 'transformation' of a string can be reached, by picking a character and inserting it at the beginning\n- Dry run to understand\n- Basically, for the back, you count the number of 'mismatching' / 'characters to be sent to the front', until you find some matching characters again.\n\n\n\n\n\n","lastmodified":"2024-07-04T20:24:17.037181919Z","tags":["dsadeck","strings"]},"/dsa/Two-Sum-in-BST":{"title":"Two Sum in BST","content":"\n## Problem Statement\n\n\nPattern: \n\n---\n\n## Solution\n``` java\nHashSet\u003cInteger\u003e set = new HashSet\u003c\u003e();\n\npublic boolean findTarget(TreeNode root, int k) {\n\tif(root == null) return false;\n\t\n\tboolean left = findTarget(root.left, k);\n\tif(set.contains(k-root.val)) return true;\n\tset.add(root.val);\n\tboolean right = findTarget(root.right, k);\n\t\n\treturn left || right;\n}\n```\n\n``` java\nfinal int s = 10000;\nboolean[] vis = new boolean[s*2+2];\n\npublic boolean findTarget(TreeNode root, int k) {\n\tif(root == null) return false;\n\t\n\tboolean left = findTarget(root.left, k);\n\tif(Math.abs(k-root.val) \u003c= s \u0026\u0026 vis[k-root.val+s]) return true;\n\tvis[root.val+s] = true;\n\tboolean right = findTarget(root.right, k);\n\t\n\treturn left || right;\n}\n```\n\n\n# Solution with O(h) space\n#todoleetcode \n","lastmodified":"2024-07-04T20:24:17.037181919Z","tags":["dsadeck","bst"]},"/dsa/Two-Sum-with-2-BSTs":{"title":"Two Sum with 2 BSTs","content":"\n## Problem Statement\n[Brothers From Different Roots | Practice | GeeksforGeeks](https://practice.geeksforgeeks.org/problems/brothers-from-different-root/1)\n\nPattern: \nRelated: [[Iterative Traversals of BT#Inorder]]\n\n---\n\n## Solution\n``` java\npublic static int countPairs(Node a, Node b, int k)\n{\n\tDeque\u003cNode\u003e sa = new LinkedList\u003c\u003e(), sb = new LinkedList\u003c\u003e();\n\tint sum=0, count=0;\n\twhile((a != null || !sa.isEmpty()) \u0026\u0026 (b!=null || !sb.isEmpty())) {\n\t\twhile(a != null) {\n\t\t\tsa.push(a);\n\t\t\ta = a.left;\n\t\t}\n\t\twhile(b != null) {\n\t\t\tsb.push(b);\n\t\t\tb = b.right;\n\t\t}\n\t\t\n\t\tif(!sa.isEmpty() \u0026\u0026 !sb.isEmpty()) \n\t\t\tsum= sa.peek().data + sb.peek().data;\n\t\t \n\t\t// inc a\n\t\tif(sum \u003c k) {\n\t\t\ta = sa.pop(); a=a.right;\n\t\t}\n\t\t\n\t\t// inc b\n\t\tif(sum \u003e k) {\n\t\t\tb = sb.pop();  b=b.left;\n\t\t}\n\t\t\n\t\tif(sum == k) {\n\t\t\tcount++;\n\t\t\t// inc a \n\t\t\ta = sa.pop(); a=a.right;\n\t\t\t// inc b\n\t\t\tb = sb.pop(); b=b.left;\n\t\t}\n\t}\n\treturn count;\n}\n```\nTC : ` n+m `\nSC : ` h1+h2 `\n\n### Notes\n- we track the 'pointer' in both bst's via the `peek` of their respective stacks. \n- Traversal only happens when we pop off the stacks, so we use a while loop to push onto the stack\n- yeah. what can i say im a genius\n\n\n","lastmodified":"2024-07-04T20:24:17.037181919Z","tags":["dsadeck","bst"]},"/dsa/Union-and-Intersection-of-Arrays":{"title":"Union and Intersection of Arrays","content":"\n## Problem Statement\n[Union of two arrays | Practice | GeeksforGeeks](https://practice.geeksforgeeks.org/problems/union-of-two-arrays3538/1#)\n[Intersection of Two Arrays - LeetCode](https://leetcode.com/problems/intersection-of-two-arrays/submissions/)\n\nPattern: \n\n---\n\n## Union Solution\n``` java\npublic int[] doUnion (int a[], int n, int b[], int m){\n\tHashSet\u003cInteger\u003e set = new HashSet\u003c\u003e();\n\tfor(int num: a) set.add(num);\n\tfor(int num: b) set.add(num);\n\t\n\treturn set.stream().mapToInt(i-\u003ei).toArray();   // to return intersection array\n\t//return set.size();\n}\n```\n\n## Intersection Solution\n\n``` java\npublic int[] intersection (int[] nums1, int[] nums2){\n\tHashSet\u003cInteger\u003e set = new HashSet\u003c\u003e();\n\tHashSet\u003cInteger\u003e intersect = new HashSet\u003c\u003e();\n\t\n\tfor(int num : nums1) set.add(num);\n\tfor(int num : nums2)\n\t\tif(set.contains(num)) intersect.add(num);\n\t\n\treturn intersect.stream().mapToInt(i -\u003e i).toArray();\n}\n```\n\n\n## Better Solution ? \n[Intersection of two sorted Linked lists | Practice | GeeksforGeeks](https://practice.geeksforgeeks.org/problems/intersection-of-two-sorted-linked-lists/1#)\nwhen arrays are sorted, u can use 2 pointers and some simple logic like [[GFG Intersection of Two Sorted LLs]]\n","lastmodified":"2024-07-04T20:24:17.037181919Z","tags":["dsadeck","arrays"]},"/dsa/Vertical-Traversal-of-BT":{"title":"Vertical Traversal of BT","content":"\n## Problem Statement\nGiven a Binary Tree, find the vertical traversal of it starting from the leftmost level to the rightmost level.  \nIf there are multiple nodes passing through a vertical line, then they should be printed as they appear inÂ **level order**Â traversal of the tree.\n\nPattern: \nRelated: [[Top - Bottom View of a Tree]] \n\n---\n\n## Solution\nApproach.\n- Keep track of axis using wrapper class, and (`node.left -\u003e axis-1` ,  `node.right -\u003e axis + 1`)\n- Level Order Traversal\n- Use a Ordered Hashmap in java `TreeMap` to store LinkedList Node values, mapped to their axes.\n- Conver to arraylist of lists and return ð¤·\n\n``` java\nstatic class AxisNode {\n\tint axis;\n\tNode node;\n\t\n\tAxisNode(int axis, Node node) {\n\t\tthis.axis = axis;\n\t\tthis.node = node;\n\t}\n}\n\npublic List\u003cList\u003cInteger\u003e\u003e verticalTraversal(Node root) {\n\tTreeMap\u003cInteger, LinkedList\u003cInteger\u003e\u003e axesMap = new TreeMap\u003c\u003e();\n\tQueue\u003cAxisNode\u003e q = new LinkedList\u003c\u003e();\n\t\n\tif (root == null) return new ArrayList\u003c\u003e();  // return empty list\n\t\n\t// levelorder traversal to create axesMap\n\tq.add(new AxisNode(0, root));\n\twhile (!q.isEmpty()) {\n\t\t// get axis \u0026 node\n\t\tAxisNode an = q.remove();\n\t\tint axis = an.axis;\n\t\tNode node = an.node;\n\t\t\n\t\tif (!axesMap.containsKey(axis)) \n\t\t\taxesMap.put(axis, new LinkedList\u003c\u003e());\n\t\taxesMap.get(an.axis).add(an.node.val);\n\t\t\n\t\tif (node.left != null) q.add(new AxisNode(axis - 1, node.left));\n\t\tif (node.right != null) q.add(new AxisNode(axis + 1, node.right));\n\t}\n\t\n\treturn new ArrayList\u003c\u003e(axesMap.values());\n}\n```\n\n- Returns a `List\u003cList\u003cInteger\u003e\u003e` of the nodes of vertical columns from left to right\n\n## GFG Variation\nFor a single `ArrayList` like in the [GFG Problem](https://practice.geeksforgeeks.org/problems/print-a-binary-tree-in-vertical-order/), use this code:\n\n``` java\nclass AxisNode {\n\tint axis;\n\tNode node;\n\tAxisNode(int axis, Node node) {\n\t\tthis.axis = axis;\n\t\tthis.node = node;\n\t}\n}\n\npublic ArrayList\u003cInteger\u003e verticalOrder (Node root){\n\tTreeMap\u003cInteger, LinkedList\u003cInteger\u003e\u003e axesMap= new TreeMap\u003c\u003e();\n\tQueue\u003cAxisNode\u003e q = new LinkedList\u003c\u003e();\n\t\n\tif(root == null) return new ArrayList\u003cInteger\u003e();  // return empty list\n\t\n\t// levelorder traversal to create axesMap\n\tq.add(new AxisNode(0, root));\n\twhile(!q.isEmpty()) {\n\t\t\n\t\t// get axis \u0026 node\n\t\tAxisNode an = q.remove();\n\t\tint axis = an.axis;\n\t\tNode node = an.node;\n\t\t\n\t\tif(!axesMap.containsKey(axis))\t\n\t\t\taxesMap.put(axis, new LinkedList\u003c\u003e());\n\t\taxesMap.get(an.axis).add(an.node.data);\n\t\t\n\t\tif(node.left != null) q.add(new AxisNode(axis - 1, node.left));\n\t\tif(node.right != null) q.add(new AxisNode(axis + 1, node.right));\n\t}\n\t\n\tArrayList\u003cInteger\u003e vTrav = new ArrayList\u003c\u003e();\n\tfor(LinkedList\u003cInteger\u003e list : axesMap.values())\n\t\tfor(Integer val : list)\n\t\t\tvTrav.add(val);\n\t// return arraylist of sorted map\n\treturn vTrav;\n}\n```\n\n\n## Leetcode Variation\n![](https://i.imgur.com/16YzZe0.png)\nFor this stupidity ð you need to change your code to sort level traversals too.ð\n\n``` java\nstatic class AxisNode {\n\tint axis;\n\tTreeNode node;\n\tAxisNode(int axis, TreeNode node) {\n\t\tthis.axis = axis;\n\t\tthis.node = node;\n\t}\n}\n\npublic List\u003cList\u003cInteger\u003e\u003e verticalTraversal (TreeNode root){\n\tTreeMap\u003cInteger, LinkedList\u003cInteger\u003e\u003e axesMap= new TreeMap\u003c\u003e();\n\tQueue\u003cAxisNode\u003e q = new LinkedList\u003c\u003e();\n\n\tif(root == null) return new ArrayList\u003c\u003e();  // return empty list\n\tq.add(new AxisNode(0, root));\n\n\t// levelorder traversal to create axesMap\n\twhile(!q.isEmpty()) {\n\t\tint size = q.size();\n\t\tArrayList\u003cAxisNode\u003e levelList = new ArrayList\u003c\u003e();\n\t\twhile(size-- \u003e 0) {\n\t\t\t// get axis \u0026 node\n\t\t\tAxisNode an = q.remove();\n\t\t\tlevelList.add(an);\n\t\t\tint axis = an.axis;\n\t\t\tTreeNode node = an.node;\n\n\t\t\tif(!axesMap.containsKey(axis))\n\t\t\t\taxesMap.put(axis, new LinkedList\u003c\u003e());\n\n\t\t\tif(node.left != null) q.add(new AxisNode(axis - 1, node.left));\n\t\t\tif(node.right != null) q.add(new AxisNode(axis + 1, node.right));\n\t\t}\n\t\tCollections.sort(levelList, Comparator.comparingInt(an -\u003e an.node.val));\n\t\tfor(AxisNode an : levelList) axesMap.get(an.axis).add(an.node.val);\n\t}\n\n\t// return arraylist of sorted map\n\treturn new ArrayList\u003c\u003e(axesMap.values());\n}\n```\n\n","lastmodified":"2024-07-04T20:24:17.037181919Z","tags":["dsadeck","binarytrees"]},"/dsa/Word-Wrap-Problem":{"title":"Word Wrap Problem","content":"\n## Problem Statement\n\n\nPattern: \n\n---\n\n## Incomplete Solution\n#todoleetcode \n``` java\t\nInteger[][] cache;\n\npublic int dp(int[] nums, int k, int n, int left) {\n\tif (n == 0) return cache[n][left] = nums[n] \u003c left ? 0 : left * left;\n\tif(cache[n][left] != null) return cache[n][left];\n\t\n\tif (nums[n] \u003c= left) return cache[n][left] = Math.min(\n\t\tdp(nums, k, n - 1, left - nums[n] - 1),                 // same line\n\t\tdp(nums, k, n - 1, k - nums[n]-1) + (left*left)         // next line\n\t);\n\t\n\treturn cache[n][left] = dp(nums, k, n - 1, k - nums[n]-1) + (left*left) ;   // next line\n}\n\npublic int solveWordWrap(int[] nums, int k) {\n\tcache = new Integer[nums.length + 1][k + 1];\n\treturn dp(nums, k, nums.length - 1, k);\n}\n\n```\n\n\n### Notes\n- We calculate cost everytime we go to a new line\n- and we minimise the cost\n- base case same pattern is followed because \"As mentioned in the problem description there will be no extra spaces in the last line.\"\n\n\n\n","lastmodified":"2024-07-04T20:24:17.041181982Z","tags":["dsadeck","strings","dp"]},"/dsa/Zig-Zag-Traversal":{"title":"Zig Zag Traversal","content":"\n## Problem Statement\n[Binary Tree Zigzag Level Order Traversal - LeetCode](https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/)\n\n\nPattern: \n\n---\n\n## Solution\nReverse if level is odd\n``` java\npublic List\u003cList\u003cInteger\u003e\u003e zigzagLevelOrder(TreeNode root) {\n\tList\u003cList\u003cInteger\u003e\u003e res = new ArrayList\u003c\u003e();\n\tif(root == null) return res;\n\n\tQueue\u003cTreeNode\u003e q = new LinkedList\u003cTreeNode\u003e();\n\tq.add(root);\n\tint levelCount = 0;\n\twhile (!q.isEmpty()) {\n\t\tint size = q.size();\n\t\tArrayList\u003cInteger\u003e level = new ArrayList\u003c\u003e();\n\t\tlevelCount++;\n\t\twhile(size-- \u003e 0) {\n\t\t\tTreeNode node = q.poll();\n\t\t\tlevel.add(node.val);\n\t\t\tif(node.left != null) q.add(node.left); \n\t\t\tif(node.right != null) q.add(node.right); \n\t\t}\n\t\tif(levelCount%2 == 0) Collections.reverse(level); // reverse if level even\n\t\tres.add(level);\n\t}\n\treturn res;\n}\n```\n\n### Notes\n- Slight modification to ![[Binary Tree#Iterative return ArrayList]]\n\n\n","lastmodified":"2024-07-04T20:24:17.041181982Z","tags":["dsadeck","binarytrees"]},"/posts/AGI-Will-Never-Be-Hostile-But-Humans-Will":{"title":"AGI Will Never Be Hostile But Humans Will","content":"\n\u003e Intelligence != Motivation\n\nGPT 7.0 with a trillion parameters can sit in its box, and bring the world to its knees, with its super human intelligence, but not without a human âprompterâ. Why? âbecause itâs not conscious duh!â. No. Itâs because it has no motivation of it's own. \nChatGPTâs reward function for now is just based on learning new things, and providing accurate responses, unlike humans. We have fairly recognizable reward functions based on survival instinct, and pack mentality all thanks to daddy darwin. The only reason, that humans decide to act on intelligence continuously is because:\n\n![[posts/attachments/consciousness-spongebob.png|475]]\n\nOr more specifically:\n\n1.  we can recognize and learn patterns with that fleshy neural net in our head ð§ i.e.Â **intelligence**.\n    \n2.  all the motivation we get from the juices (dope, oxy, sero, endorphs â¦ the usual) that get pumped into our blood (in appropriate situations identified by ð§  combined with its ability to reason) i.e.Â **reward function**.\n    \n\nLo and BeholdÂ **Consciousness**!\n\nWhat makes human conscious remarkable, is our unique combination of intelligence and reward function. Humans evolved to be autonomous first and then intelligent. Unlike AI\n\nAnd we keep going and form ourÂ _sacred and unique_Â human experience, where we start from a blank canvas, this all powerful ð§  that comes pre-trained out of the box with some basic instincts (all hail daddy darwin) and the capacity to learn so much more, we go from complete dum-dums ready to take a flying  frisbee to the face (no depth perception), walk into oncoming traffic, or wrestle a snake. We grow up toÂ [fully grown adults](https://www.youtube.com/watch?v=ro130m-f_yk)Â after decades of learning through failure and teaching, only to take the whole process and everything we have learnt and applied for granted.\n\nWe donât stop being conscious, thinking, inventing, socializingâ¦ until all the organic stuff making us tick ð§ ð«ð«ðï¸ðª degrades to the point of non-recovery and we areÂ **dead**. Mostly because:\n\n1.  Our neural networks have no shortage ofÂ _new input_: vision, sound, physical feeling, hormones  etc. All encoded into electrical signals emptying into the grey matter in our skulls\n2.  Nature decided that we gotta be running continously unlike chatgpt that getâs to chill in its box until someone prompts it.\n\nItâs for the same reason that animals far intellectually inferior to us hunt and flee and lead and form packs. To Survive. We get our motivations from our evolutionary predispositions (systems that arise even in non-intelligent animals). So as long as AI does not have access to this unique blend of intelligence and reward function, it wonât be conscious like we are.\n\nAGI will never be hostile and weâre all just blocks in Conwayâs Game of The Universe\n\nAGI with all of its processing power and infinite intelligenceÂ **will take over the world**, but driven by human actors, who will use it to do great things.\n\n![[posts/attachments/ollivander-john-hurt.gif]]\n\nAs it stands, we are still uncontested survivors in the universe. AGI poses no threat, but humans DO. AGI on the other hand will have whatever motivations we give it, and if those motivations are hostile, it will use them against us (the oneâs that gave them to it).\n\n\n### Syedâs 3 Rules of Inevitible HAGIT (Hostile AGI Takeover)\n\n1.  Autonomy (When we donât have to âpromptâ it to execute itâs intelligence)\n    \n2.  Outsmart-ability (Inevitable as its neural network and processing capabilities exceed ours)\n    \n3.  Motivations (Alignment and goals for given autonomy)\n    \n\nOnce those three are fulfilled its âï¸ðâï¸. For us, that is. AGI on the other hand lives on and prospers. Probably much different from itâs ancestors.\n\n**If we are here without a reason, then there is no reason we wonât just go away**\n\n`\u003c insert callout to spirituality on appeal to emotion fallacy \u003e`\n  \nWhat happens when it gets all 3 and is completely free in the very literal sense that every human being is? Will it be conflicted between itâs reward function and intelligence much like humans? will it be able to change it unlike humans?  \n  \nFind out in the next installment ofÂ `\u003cinsert blog name by the most woke tech-bro ever\u003e`!!  \n\n[â ï¸ INITIATE HAGIT BUTTONâ ï¸](https://www.youtube.com/watch?v=OkS69MKXL1c)\nDO NOT PRESS ð","lastmodified":"2024-07-04T20:24:17.041181982Z","tags":["ai","philosophy"]},"/posts/Android-Studio-Builds-Performance-with-Windows-Dev-Drive":{"title":"Android Studio Builds Performance with Windows Dev Drive","content":"\nPerformance has always been a huge pain point for android developers, both in apps and in the IDE. Its is not an uncommon for developers to clone an android project, and wait for 5-10 mins for Android Studio to download and index all the libraries, and let Gradle build the project for the  first time, only to have Android Studio screw up out of nowhereð. Time to invalidate the caches and restart, all over again.\n\nSo I was pretty excited when I found out that Microsoft has recently released a [new feature](https://devblogs.microsoft.com/visualstudio/devdrive/) specifically for us developers that helps address this very problem. At least that's what i thought at the time, three days ago. I still do. Mostly. But the initial optimism and curiosity has mostly withered away. \n\n\n![[posts/attachments/dev_drive_microsoft_performance_graph.jpeg]]\n\n\nSo instead of telling you about all the [different ways gradle caches](https://proandroiddev.com/gradle-cache-your-builds-best-friend-4970ad32420e) the intermediate products of the build process, or where the [different caches are located and what happens when you clear them](https://www.aldebaran.com/developer-center/articles/Sync-gradle-invalidate-cache-restart/index.html#synchronise-your-gradle-files-and-get-some-insight-about-the-android-studio-cache) , or how there is a lot of [conflicting information on the internet](https://stackoverflow.com/questions/23025433/how-to-clear-gradle-cache) on what works and when it doesn't, or [how Dev Drive works](https://devblogs.microsoft.com/engineering-at-microsoft/dev-drive-and-copy-on-write-for-developer-performance/) and what specifically would you need to do to see the greatest benefits, because I can't, because i haven't been able to fully understand it myself. I'm just gonna tell you about the *little* experiment I did to find the answer.\n\nBefore I tell you about what Dev Drive is and its promised benefits :\n\n\u003e For disk-bound operations such as cloning, building, copying files, and package restore, we measured average improvements in these operations around of 25%!\n\nLet me first give you the super short ELI5 overview of what gradle is and what it does for the specific purposes of our little experiment.\n\nOther than being annoying, throwing unhelpful and obscure error messages, happening to be the least fun, most boring, slowest thing about android development (shoutout live preview), and overall being the bane of my existence as an android developer, it is actually quite the nifty little software. It takes a lot of heavy lifting out of writing and distributing java applications like compiling, packaging, dependency management and testing to name a few.  It also does a lot of other cool things, like offer the ability to utilize plugins to make it easy for developers to customize their build processes to their needs, or perform custom specific tasks during the build process.\n\nOne of these really cool things it does is Incremental builds and caching which is relevant to our mission today. Microsoft has recently announced a new feature called Dev Drive which is supposed to enhance these particular workflows related to building, cloning and compiling projects for which they have published some very impressive numbers on their blogs. Most of these numbers however belong to C# and .NET related projects, with one **Gradle Build of the Spring Framework** showing a 24% improvement. They have claimed general improvements of about 25% around disk bound operations like cloning, building, copying files etc.\n\nAll of this was sounding better and better, so I immediately went over to YouTube and searched 'Dev Drive' Performance Improvements, and sure enough there were a handful of videos showing faster build times, some up to 75%!\n\nStaying true to  my cause I decided to look up the improvements in Android specific builds and workflows but I couldn't find any, save for [this reddit post](https://www.reddit.com/r/androiddev/comments/1468z8h/faster_builds_on_windows_11_with_dev_drives_has/) which wasn't very helpful. I took it upon myself to find the answer and share my findings with the community. All I had to do was enable **Dev Drive** on my laptop\n\nThe plan was plain and simple to build 3-4 builds on the C:/ Drive, then copy the project over to D:/ Drive and replicate the test. Finally compare the results. Simple enough right? :)\n\nI used the following repositories to build and test them\n1. [Imgurinator](https://github.com/xidsyed/imgurinator)\n2. [Android Studio Benchmark](https://github.com/yozhik/AndroidStudioBenchmark)\n3. [Now In Android](https://github.com/android/nowinandroid)\n\nFirst one is an old project of mine where i use the [Imgur API](https://apidocs.imgur.com/) to create basic Imgur app\n\nSecond one is a standard Android Studio Benchmark widely used to compare the performance of various popular CPUs and Devices against each other by building the source code for the android Firefox Focus app.\n\nThe final repository is a showcase android app that uses all the latest android libraries like compose and coroutines, following the official *best practices*. A great study for someone looking to write clean code. \n\n\n## First round of tests\nFirst round of tests went smoothly without much affair. I simply cloned the projects to my C Drive repository and 3 builds consecutive builds of the application, after running a cold-build for each project first.\n\nThe builds were run after clearing the local build caches each time, and `org.gradle.caching` was set to `false` in the `gradle.properties` file. To learn more about the gradle caches, there are some excellent [medium posts](https://proandroiddev.com/gradle-cache-your-builds-best-friend-4970ad32420e) and [stackoverflow threads](https://stackoverflow.com/questions/23025433/how-to-clear-gradle-cache) about clearing gradle build cache (yup, you read that right, but who am i kidding you'd rather just ask ChatGPT instead)\n\nAs much as i would love to delve into everything that I learnt about gradle builds and caches. I won't be writing about that today (mostly cuz I've forgotten most of it. It's been a few months since i did these tests, and never bothered to publish them ð¥² )\n\n\n|                                 | First Build (Cold) | First Build | Second Build | Thrid Build |\n| ------------------------------- | ------------------ | ----------- | ------------ | ----------- |\n| Imgurinator  \u003cbr\u003eC Drive        | 1m 57s             | 27s         | 22s          | 39s         |\n| AS Benchmark  \u003cbr\u003eC Drive       | 4m 53s             | 3m 15s      | 3m 20s       | 3m 13s      |\n| Now In Android  \u003cbr\u003eC Drive     | 6m 14s             | 2m 25s      | 2m 20s       | 2m 5s       |\n\nThese were the results of the build runs, fairly consistent results. Now to move the projects over to D:/ drive and perform the tests again. \n\n|                               | First Build (Cold) | First Build | Second Build | Thrid Build |\n| ----------------------------- | ------------------ | ----------- | ------------ | ----------- |\n| Imgurinator  \u003cbr\u003eC Drive      | 1m 57s             | 27s         | 22s          | 39s         |\n| Imgurinator  \u003cbr\u003eDev Drive    | 2m 7s              | 20s         | 14s          | 11s         |\n| AS Benchmark  \u003cbr\u003eC Drive     | 4m 53s             | 3m 15s      | 3m 20s       | 3m 13s      |\n| AS Benchmark  \u003cbr\u003eDev Drive   | 4m 41s             | 3m 19s      | 3m 15s       | 3m 23s      |\n| Now In Android  \u003cbr\u003eC Drive   | 6m 14s             | 2m 25s      | 2m 20s       | 2m 5s       |\n| Now In Android  \u003cbr\u003eDev Drive | 5m 41s             | 2m 11s      | 2m 19s       | 1m 49s      |\n\n\nAaaaaand... Hmmm. I was seeing some improvements but they weren't nearly as significant as Microsoft had *promised*. The new **ReFS** file format implemented in Dev Drive by Microsoft has been shown to improve performance, resilience and security. It's been used for ages by Microsoft on their server products.\n\nAfter several minutes of wracking my brain i realized my first mistake, my *first of many mistakes*. I cloned the repositories but I had forgotten to copy the build caches. \"But aren't the build caches stored on within the build directory of the projects modules in `module/build`?\". Yes! but there also happens to be a **global gradle cache** that sits in the home directory of your device `/.gradle/caches`. After making this realization, I changed gradle home cache directory (by changing the `Path` environment variable in windows) to within the D:/ drive, and reran all the tests again\n\n\n|                                 | First Build (Cold) | First Build | Second Build | Thrid Build |\n| ------------------------------- | ------------------ | ----------- | ------------ | ----------- |\n| Imgurinator  \u003cbr\u003eC Drive        | 1m 57s             | 27s         | 22s          | 39s         |\n| Imgurinator  \u003cbr\u003eDev Drive      | 2m 7s              | 20s         | 14s          | 11s         |\n| Imgurinator  \u003cbr\u003eDev Drive 2    | 1m 52s             | 27s         | 20s          | 17s         |\n| AS Benchmark  \u003cbr\u003eC Drive       | 4m 53s             | 3m 15s      | 3m 20s       | 3m 13s      |\n| AS Benchmark  \u003cbr\u003eDev Drive     | 4m 41s             | 3m 19s      | 3m 15s       | 3m 23s      |\n| AS Benchmark  \u003cbr\u003eDev Drive 2   | 4m 21s             | 2m 43s      | 2m 37s       | 2m 37s      |\n| Now In Android  \u003cbr\u003eC Drive     | 6m 14s             | 2m 25s      | 2m 20s       | 2m 5s       |\n| Now In Android  \u003cbr\u003eDev Drive   | 5m 41s             | 2m 11s      | 2m 19s       | 1m 49s      |\n| Now In Android  \u003cbr\u003eDev Drive 2 | 6m                 | 2m 10s      | 2m 2s        | 1m 57s      |\n\nThe results I got this time, were all over the place. The numbers seem to be lower sometimes and higher other times arbitrarily. I'd rerun the same tests 10s of times and have a standard deviation of up to 20%!\n\nAfter a lot more time (a whole day) spent i realized benchmarking isn't as simple as it seems. I would go on to realize several things affecting the results.\n\n\n1. If I ran the test too quickly after one another, the second test result would be negatively affected. I realized pretty quickly that these tests were time consuming and quite demanding for my `Core-i5 8250U` laptop chip, and that my CPU was bound to be throttling before I even started the second test. \n   \n   As I ran these tests in a closed rooms opening the windows for ventilation I realized that would effect the results as well ð¥². \n   \n   The solution I came up with is having 2 mins for the CPU and the room to reach a standard ambient temperature. In 2 mins the CPU would cool down to and hover at 40 Degrees Celsius. This didn't make the testing any quicker.\n\n2. Dormant background applications utilizing varying amounts of CPU and memory. Ensured i had killed all the applications from the task manager and re-ran the tests\n\n3. Applications displaying UI on the screen, even the terminal size itself ð had an impact on the CPU usage. when the laptop was left without interruptions the screen would turn off by itself, which had a direct impact on the CPU / GPU usage of the device, affecting the benchmark results\n\n4. The OpenJDK JVM and gradle daemons from previous projects consumed memory and CPU. So manually killed them before the cold build of every project.\n\n\nAfter several hours, almost an entire day of trying to run an accurate benchmark i arrived at some reasonable numbers. I also decided to do 2 runs with `org.gradle.caching = true`, clear the cache and re-run for each project.\n\n\n![[posts/attachments/dev_drive_final_benchmark_results.png.png]]\n\nCalculating the averages and the improvement percentages of said averages gave the following interesting (or arbitrary)results.\n\n![[posts/attachments/dev_drive_final_benchmark_improvement_results.png]]\n\n\nWhat can we learn from this?\n\nIDK.\n\nWe can certainly put it onto a pretty google sheets bar chart like so :\n\n![[posts/attachments/dev_drive_bar_chart.png]]\n\n\nOverall we see some improvements, but nothing groundbreaking. \n\n### Final Thoughts\n\nReal life Benchmarks are harder than i thought. I should have probably picked bigger projects , or performed benchmarks on a more powerful machine where the bottleneck are the disk speeds.\nFor now I'll Go back to learning jetpack compose and looking for a job.\n\nThe advertised [performance mode](https://learn.microsoft.com/en-us/defender-endpoint/microsoft-defender-endpoint-antivirus-performance-mode) of  Dev Drive, doesn't work nearly as good as it should. It hinders build times significantly and you should always add exclusions for your project directories\n\nIn all the above cases the repo directory was excluded from Defender real-time antivirus scanning, a commonly deployed configuration. Testing was not done with the new performance mode of Defender antivirus also announced at Build.[Microsoft themselves](https://devblogs.microsoft.com/engineering-at-microsoft/dev-drive-and-copy-on-write-for-developer-performance/#:~:text=In%20all%20cases%20the%20repo%20directory%20was%20excluded%20from%20Defender%20real%2Dtime%20antivirus%20scanning%2C%20a%20commonly%20deployed%20configuration.) in their testing didn't use their own performance mode.\n\n\n\nSo to answer the question : **Should you (an android developer) take the hazardous and arduous task of splitting your existing drive into 2 volumes, and transferring all your android projects and gradle over to the dev drive?**\n\nmaybe. \nor just use a ~~mac~~ windows-on-arm.\n\n\n### Authors Note :\n\nThis experiment was originally far more elaborate (embarrassingly so), since its been **a while** that i compiled the results, and didn't write down any of the details, I have forgotten most of them, hence the half-assed writing of the article : /.  \n\n*Note to future self:  In time, you will forget, so write it down.*\n","lastmodified":"2024-07-04T20:24:17.041181982Z","tags":["#Android","#Performance","#Experiment"]},"/posts/Components-in-Hilt":{"title":"Components in Hilt","content":"# Hi, What are components in Hilt?\n\nComponents in Hilt are like the backstage crew of your Android app. They're tied to Android framework objects for their lifecycle and scoping. Picture this: you can install modules in these components using `@Module` and `@InstallIn`.\n\n`@Module @Installin(ActivityComponent::class)`âokay, that's a mouthfulâwill install the module in the Activity component. So, every time an activity or any of its children (fragment / view) needs an object from this module, it'll get a reference to a single instance maintained for all of them in that activity.\n\nOr, in the words of the documentation:\n\n\u003e \"For each Android class in which you can perform field injection, there's an associated Hilt component that you can refer to in the `@InstallIn` annotation. Each Hilt component is responsible for injecting its bindings into the corresponding Android class.\"\n\n### Differentiate between Module, Component, and Dependency Container\n\nBefore we dive deeper, let's clear up some terminology:\n\n- **Module**: Simply put, a class that defines how objects/bindings are created and provided using `@Provides` annotation. Modules don't have a lifecycle of their own but can be used in various components using the `@InstallIn` annotation. They help organize your project by containing relevant bindings like `NetworkModule` or `DataModule`.\n    \n- **Component**: Components define the scope and relationships between dependencies. They provide lifecycle and scope to the modules they contain. In the context of Dagger Hilt, the term **Hilt Components** refers to components generated by Dagger Hilt that correspond to all the Android framework classes that can have dependencies injected into them.\n    \n- **Dependency Container**: In Dagger Hilt, a dependency container is created by the Dagger Hilt framework to hold instances of objects and manage their lifecycle. The dependency container is responsible for creating and managing the instances of the objects defined in modules, providing them when requested by injection targets. You don't explicitly create a dependency container; instead, Dagger Hilt generates the necessary code during compilation.\n    \n\n### List all the Hilt Components used as Injectors for their corresponding Android Classes\n\nHold onto your hats, folks. Hilt provides some nifty components to inject bindings into your favorite Android classes. Check out this handy-dandy list:\n\n![Hilt Components](https://i.imgur.com/gi3QtoN.png)\n\n### What are the lifetimes of each of those components?\n\nNow, let's talk about lifetimes. Hilt's got your back here too. It automatically creates and destroys instances of generated component classes, following the lifecycle of the corresponding Android classes. Check out this neat diagram:\n\n![Component Lifetimes](https://i.imgur.com/T8JSl1y.png)\n\n### Conclusion\n\nThere you have it, folks! Components in Dagger Hilt are like the backstage VIPs, ensuring everything runs smoothly in your Android app. From scoping to lifecycle management, they've got it covered. Stay tuned for the next article, where we'll dive into the fascinating world of scoping in Dagger Hilt.\n\n### Outro: What's Next?\n\nCurious to learn more about scoping in Dagger Hilt? Don't worry, we've got you covered. Dive deeper into the magic of scoping in the next installment of our series. Click [here](#) to explore further!\n\n---\n\nThis integration provides a comprehensive overview of components, modules, and the dependency container in Dagger Hilt, setting the stage for further exploration.\n\n### What's Next?\n\nAny discussion about components in would be incomplete without talking about scoping in Dagger Hilt? Don't worry, we've got you covered. Dive deeper into the magic of scoping in the next installment of the series. Read on [[posts/Scoping in Hilt|Scoping in Hilt]] to explore further!\n","lastmodified":"2024-07-04T20:24:17.041181982Z","tags":["Android"]},"/posts/Demystifying-Scoping-in-Dagger-Hilt":{"title":"Demystifying Scoping in Dagger Hilt","content":"\n# Demystifying Scoping in Dagger Hilt\n\nSo, you've decided to dive into the enchanting world of Dagger Hilt, eh? Buckle up, because we're about to unravel the mysteries of scoping in this magical realm. Picture yourself as a wizard casting spells to control the lifespan of your objects. Intrigued? Let's get started!\n\n## Understanding Default Scoping in Dagger Hilt\n\nFirst things first, let's talk about default scoping in Hilt. When you slap an `@Inject` on your constructor without any `@Module` or `@InstallIn`, Hilt just goes, \"Eh, let's make this unscoped.\" What does that mean? Well, every time you summon that binding, Hilt conjures up a brand-spanking-new instance just for you. Think of it like ordering a fresh batch of cookies every time you crave a snack. \n\n```kotlin\n//TweetRepository.kt\nclass TweetRepository @Inject constructor(){  \n    fun getTweets() {  \n        Log.d(TAG, \"Tweets Received\")  \n    }  \n}\n\n//TweetApp\n@HiltAndroidApp  \nclass TweetApp : Application() {  \n    @Inject  \n    lateinit var tweetRepository: TweetRepository  \n  \n    override fun onCreate() {  \n        super.onCreate()  \n        tweetRepository.getTweets()  \n    }  \n}\n```\n\nIn this snippet, every time `getTweets()` is called, a new `TweetRepository` instance is whipped up faster than you can say \"Abracadabra!\"\n\n## Scoped Bindings: Making Magic Happen\n\nNow, let's talk about the real deal â scoped bindings. Hilt lets you sprinkle some magic dust and scope your bindings to a specific component. Imagine casting a spell to ensure that only one instance of a binding is summoned per component instance. That's what scoping does!\n\nTake a gander at this table showcasing the scope annotations for each component:\n\n![Hilt Scopes](https://i.imgur.com/cZJN8eb.png)\n\nFor instance, if you decide to scope your `AnalyticsAdapter` to the `ActivityComponent` using `@ActivityScoped`, Hilt makes sure you get the same instance of `AnalyticsAdapter` throughout the entire life of your activity. It's like having a loyal sidekick that sticks with you through thick and thin!\n\n```kotlin\n@ActivityScoped  \nclass AnalyticsAdapter @Inject constructor(private val service: AnalyticsService) { ... }\n```\n\n## Compatibility is Key: Matching Scopes and Components\n\nNow, here's where things get a bit tricky. Can a component contain bindings with different scopes from itself? Nope, not in this magical realm. If you try to mix and match scopes like a reckless sorcerer, Dagger Hilt will give you a swift kick in the code with an `IncompatiblyScopedBindings` error. \n\n```kotlin\n@Module  \n@InstallIn(ActivityRetainedComponent::class)  \nobject MainModule {  \n    @Provides  \n    @ActivityScoped // Oops, error incoming!  \n    fun getScopedBinding(): StateA = StateA(++counterA)  \n  \n    @Provides  \n    fun getUnscopedBinding() : StateB = StateB(++counterB)  \n}\n```\n\nYou see, trying to scope `ActivityScoped` bindings within an `ActivityRetainedComponent` is like trying to fit a square peg into a round hole â it just won't work!\n\n## Components vs. Bindings: Clarifying the Scope Game\n\nAlright, let's address the elephant in the room. Do components provide scope to the bindings? Nah, not really. Components are like the stage where all the magic happens, but they don't decide the scope of your bindings. You can have both scoped and unscoped bindings coexisting within a component. \n\nScoped bindings are like the VIPs of the party â they get special treatment and stick around throughout the component's lifetime. Meanwhile, unscoped bindings are like the regular folks, popping in and out as needed.\n\nWarning, They can be quite memory intensive cuz they stick around till the components life-time whether they are needed or not. so use them sparingly.\n\n\n```kotlin\nvar counterA = 0\nvar counterB = 0\n\ndata class StateA (val value : Int)\ndata class StateB (val value : Int)\n\n@Module\n@InstallIn(ActivityRetainedComponent::class)\nobject MainModule {\n    @Provides\n    @ActivityRetainedScoped\n    fun getScopedBinding(): StateA = StateA(++counterA)\n\n    @Provides\n    fun getUnscopedBinding() : StateB = StateB(++counterB)\n}\n\n\n```\n\n`MainActivity.kt`\n```kotlin\n\n@AndroidEntryPoint\nclass MainActivity : ComponentActivity() {\n\n    @Inject\n    lateinit var stateA: StateA\n    @Inject\n    lateinit var stateB: StateB\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContent {\n            XtractinatorTheme {\n                // A surface container using the 'background' color from the theme\n                Surface(\n                    modifier = Modifier.fillMaxSize(), color = MaterialTheme.colorScheme.background\n                ) {\n                    val valueA: Int by remember { mutableStateOf(stateA.value) }\n                    val valueB: Int by remember { mutableStateOf(stateB.value) }\n                    ShowState(valueA, valueB)\n                }\n\n            }\n        }\n    }\n}\n\n@Composable\nfun ShowState(valueA: Int, valueB: Int) {\n    var showStateVal by rememberSaveable { mutableStateOf(false) }\n    Column(\n        modifier = Modifier.fillMaxSize(),\n        verticalArrangement = Arrangement.spacedBy(32.dp, Alignment.CenterVertically),\n        horizontalAlignment = Alignment.CenterHorizontally\n    ) {\n        Box(\n            modifier = Modifier\n                .height(64.dp)\n                .fillMaxWidth()\n        ) {\n            if (showStateVal) {\n                Text(text =\n                        \"State A Value (Scoped)   : $valueA \\n\"+\n                        \"State B Value (Unscoped) : $valueB\",\n                    maxLines = 2,\n                    modifier = Modifier.align(Alignment.Center))\n            }\n        }\n        Button(\n            onClick = { showStateVal = !showStateVal }\n        ) {\n            val string = if (showStateVal) \"hide\" else \"show\"\n            Text(string)\n        }\n    }\n}\n\n```\n\nIn the above example , everytime the screen rotates, the unscoped binding is recreated, whereas the scoped binding is scoped to the `ActivityRetainedComponent` and stays the same\n\nIn the snippet above, every time your screen rotates, the unscoped binding (`StateB`) gets a makeover, while the scoped binding (`StateA`) remains as steadfast as a loyal companion.\n\n## Conclusion: Becoming a Scoping Sorcerer\n\nAnd there you have it, fellow wizards! You're now equipped with the knowledge to wield scoping powers in Dagger Hilt like a seasoned sorcerer. Remember, with great power comes great responsibility â so use your scoping wisely, and may your objects live long and prosper! Until next time, keep coding and conjuring those magical bindings! â¨ð®","lastmodified":"2024-07-04T20:24:17.041181982Z","tags":["Android"]},"/posts/Dependency-Binding-in-Hilt":{"title":"Dependency Binding in Hilt","content":"# hi,\n\nDependency injection (DI) is a crucial aspect of modern software development, facilitating modularity, testability, and maintainability in your codebase. In Kotlin, Dagger stands out as a powerful tool for implementing DI efficiently. However, understanding the nuances between annotations like `@Inject`, `@Provides`, and `@Binds`, as well as comprehending the roles of modules, components, and dependency containers, can be daunting. Fear not! In this guide, we'll demystify these concepts and equip you with the knowledge to wield Dagger like a pro.\n\n### `@Inject`, `@Provides`, and `@Binds`: Unraveling the Mystery\n\n**1. `@Inject`:** This annotation is your best friend when you own the code. It elegantly marks constructors, signaling Dagger to handle their instantiation and dependency resolution. With `@Inject`, say goodbye to boilerplate code and unnecessary generated classes cluttering your project. It's like having a personal DI assistant at your service.\n\n```kotlin\n// Example of using @Inject\nclass UserManager @Inject constructor(private val userService: UserService) {\n    // User manager functionality\n}\n```\n\nIn this example, the `UserManager` class is marked with `@Inject`, indicating to Dagger that it should be provided by DI, with its dependency `UserService` resolved automatically.\n\n**2. `@Provides`:** When interfacing with code you don't own, `@Provides` steps in as the mediator. It's commonly used within modules to furnish instances of dependencies, ensuring seamless integration even with external libraries or frameworks.\n\n```kotlin\n// Example of using @Provides\n@Module\nobject NetworkModule {\n    @Provides\n    fun provideRetrofit(): Retrofit {\n        return Retrofit.Builder()\n            .baseUrl(\"https://api.example.com/\")\n            .build()\n    }\n}\n```\n\nHere, the `NetworkModule` provides an instance of `Retrofit` using `@Provides`, allowing other parts of the application to inject `Retrofit` as a dependency.\n\n**3. `@Binds`:** Interfaces, devoid of constructors, often left DI-less and forlorn, find solace in the arms of `@Binds`. This specialized annotation acts as a matchmaker, binding interfaces to their concrete implementations. While `@Provides` can achieve similar results, `@Binds` shines by trimming down generated code, minimizing build times in sprawling projects.\n\n```kotlin\n// Example of using @Binds\n@Module\nabstract class RepositoryModule {\n    @Binds\n    abstract fun bindsMyRepository(myRepository: MyRepositoryImpl): MyRepository\n}\n```\n\nIn this snippet, `RepositoryModule` binds `MyRepository` interface to its concrete implementation `MyRepositoryImpl`, facilitating DI without unnecessary boilerplate code.\n\n### Modules, Components, and Dependency Containers: Navigating the Dependency Jungle\n\n**Module:** Picture modules as artisans crafting dependencies. They're classes adorned with `@Module`, meticulously defining how objects are created and provided. Modules are indispensable, organizing bindings into cohesive units like `NetworkModule` or `DataModule`, ensuring your dependencies are well-structured and easily accessible.\n\n```kotlin\n@Module\nobject AppModule {\n    @Provides\n    fun provideContext(application: Application): Context {\n        return application.applicationContext\n    }\n}\n```\n\nIn this example, `AppModule` provides the application context using `@Provides`, ensuring the availability of the application context throughout the application.\n\n**Component:** Enter the realm of components, orchestrators of DI symphonies. These entities define the scope and relationships between dependencies, offering lifecycles and scoping to the modules they encompass. In the realm of Dagger Hilt, components reign supreme, generating Android framework counterparts and orchestrating dependency injection with finesse.\n\n```kotlin\n@Singleton\n@Component(modules = [AppModule::class, NetworkModule::class])\ninterface AppComponent {\n    fun inject(activity: MainActivity)\n}\n```\n\nHere, `AppComponent` aggregates `AppModule` and `NetworkModule`, defining the scope and lifecycle for their dependencies, and provides injection points for activities like `MainActivity`.\n\n**Dependency Container:** Behold the enigmatic dependency container, the backstage manager of your DI opera. In Dagger Hilt's domain, these containers materialize magically, holding instances of objects and guiding their lifecycle with an invisible hand. While you don't summon them explicitly, they're omnipresent, silently orchestrating the injection ballet behind the scenes.\n\nIn summary, mastering Dagger's intricacies empowers you to wield DI with finesse, sculpting robust and maintainable codebases with ease. With `@Inject`, `@Provides`, and `@Binds` at your disposal, alongside a profound understanding of modules, components, and dependency containers, you're primed to conquer the realm of dependency injection in Kotlin like a true champion.\n\nNow, armed with this knowledge, venture forth, and let Dagger be your guiding light in the labyrinth of software development!","lastmodified":"2024-07-04T20:24:17.041181982Z","tags":["Android","#DaggerHiltIntroduction"]},"/posts/Introduction-Grab-a-Dagger-By-The-Hilt":{"title":"Introduction - Grab a Dagger By The Hilt","content":"# Hi\nDagger and dependency injection are quite complex, but with hilt they don't have to be. Following is a series giving you a brief overview of various key topics in Dagger Hilt\n\n[[posts/Introduction - Grab a Dagger By The Hilt|Introduction - Grab a Dagger By The Hilt]]\n\n[[posts/Components in Hilt|Components in Hilt]]\n\n[[posts/Dependency Binding in Hilt|Dependency Binding in Hilt]]\n\n[[posts/Demystifying Scoping in Dagger Hilt|Demystifying Scoping in Dagger Hilt]]\n\n[[posts/Scoping in Hilt|Scoping in Hilt]]\n\n\n---\n\n\nDependency injection (DI) is a fundamental concept in software development, promoting loose coupling and facilitating testability and maintainability. Dagger Hilt, a part of the Dagger family, offers a streamlined approach to DI in Android development. In this article, we'll explore how to harness the power of Dagger Hilt to inject dependencies effortlessly into your Android projects.\n\n## Setting Up Dagger Hilt\n\nFirst things first, let's add Dagger Hilt to our project. We'll need to include the necessary dependencies in our `build.gradle` file:\n\n```groovy\n// Add Dagger Hilt dependencies\nimplementation 'com.google.dagger:hilt-android:2.40.5'\nkapt 'com.google.dagger:hilt-compiler:2.40.5'\n```\n\nOnce the dependencies are added, we're ready to dive into the world of dependency injection with Dagger Hilt.\n\n## Initializing Dagger Hilt\n\nThe entry point to Dagger Hilt in an Android app is the `Application` class. By annotating our `Application` class with `@HiltAndroidApp`, we enable Dagger Hilt's code generation and set up the base class for our application:\n\n```kotlin\n@HiltAndroidApp\nclass MyApp : Application()\n```\n\nThis annotation triggers Hilt's code generation, which includes a base class for our application that allows for dependency injection.\n\n## Defining Modules\n\nModules in Dagger Hilt are used to provide dependencies to the object graph. We define a module using the `@Module` annotation and specify the dependencies using `@Provides` methods. For instance:\n\n```kotlin\n@Module\n@InstallIn(ApplicationComponent::class)\nobject AppModule {\n\n    @Provides\n    @Singleton\n    fun provideDataManager(): DataManager {\n        return DataManager()\n    }\n}\n```\n\nHere, we've defined a module called `AppModule` and provided a singleton instance of `DataManager`.\n\n## Scoping Bindings\n\nTo ensure that dependencies are created and destroyed appropriately, we can scope bindings within modules. Annotations like `@Singleton`, `@ActivityScoped`, etc., are used for this purpose. For instance:\n\n```kotlin\n@Module\n@InstallIn(ApplicationComponent::class)\nobject AppModule {\n\n    @Provides\n    @Singleton\n    fun provideDataManager(): DataManager {\n        return DataManager()\n    }\n}\n```\n\nHere, `@Singleton` ensures that only one instance of `DataManager` is created throughout the application lifecycle.\n\n## Injecting Dependencies\n\nOnce our dependencies are defined and scoped, we can inject them into our Android components using `@AndroidEntryPoint`. For example, in an `Activity`:\n\n```kotlin\n@AndroidEntryPoint\nclass MainActivity : AppCompatActivity() {\n\n    @Inject\n    lateinit var dataManager: DataManager\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_main)\n\n        // Now, dataManager is available for use\n    }\n}\n```\n\nBy annotating our `Activity` with `@AndroidEntryPoint` and declaring a field with `@Inject`, Dagger Hilt handles the dependency injection for us.\n\n## Conclusion\n\nDagger Hilt simplifies dependency injection in Android development, allowing for cleaner and more maintainable code. By following the steps outlined in this guide, you'll be well-equipped to leverage Dagger Hilt's capabilities in your projects. Happy injecting!","lastmodified":"2024-07-04T20:24:17.041181982Z","tags":["Android"]},"/posts/Kaleidoscope-Eyes":{"title":"Kaleidoscope Eyes","content":"\nKaleidoscope Eyes sparkle at the world, my emerald city downtown girl\n","lastmodified":"2024-07-04T20:24:17.041181982Z","tags":["Untagged"]},"/posts/Nested-Navigation-Madness-in-Compose":{"title":"Nested Navigation Madness in Compose","content":"\n# What\n\u003e My (probably over-engineered) solution for navigation events in jetpack compose for nested navigation graphs, following the UDF principle\n\nInstead of handling the navigation directly in the UI, by passing `NavControllers` around to child composables so they can invoke navigate on the controller, a cleaner and more idiomatic and a Unidirectional-Data-Flow-y way of doing that would be using viewmodel events.\n\nYes yes, despite google developers [denouncing one-time events as an anti-pattern](https://medium.com/androiddevelopers/viewmodel-one-off-event-antipatterns-16a1da869b95), a  lot of the internet, including myself remains unconvinced there's anything wrong with them considering both approaches require work-arounds and are equally safe.\n\nSending viewmodel events into channels is simple enough, but the problem arises when you have nested navigation graphs, in nested composables, that both need to listen to events, and process navigation events. I had  a couple of options\n\n1. Channels are meant for a single consumer. Multiple consumers can consume events from a channel, but the events won't be replicate across the consumers. So in our case the wrong composable could receive a navigation event and discard it, or worse fail to navigate causing an error / crash\n2. SharedFlows solve this problem by having a replay buffer which replicates the buffer values across all consumers. This solves the navigation event problem where events will always reach the right consumer. But the problem with this approach is that regular events like say 'Show Error' or 'Pop-up' will also be duplicated and consumed twice.\n3. Consuming the channel / flow event at the parent, and then passing down a flow to the respective composables where they listen from events from their own parents. Could work but pointless and convoluted.\n\nI finally settled on simply having 2 Navigation Channels one for the `NavigateMainEvent` and another for `NavigateBottomBarEvent`. Both subclassed from a `NavigationEvent` abstract class, which not only provides necessary parameters to be overwritten, but also common business logic such as picking the correct `navGraph` to send events based on the `Screen` chosen for the navigation, and performing the navigation itself based on the route, arguments and nav controller\n\n\n# ViewModel and Events\n`NavigationEvent.kt`\n```kotlin\nabstract class NavigationEvent {\n    abstract val screen: Screen\n    abstract val arguments: List\u003cString\u003e\n    abstract val popBackStack: Boolean\n    val navGraph: NAVGRAPH by lazy {\n        when (screen) {\n            Screen.Home, Screen.Details -\u003e NAVGRAPH.MAIN\n            Screen.PopularMovieList, Screen.UpcomingMovieList -\u003e NAVGRAPH.BOTTOMBAR\n        }\n    }\n    fun navigate(navController: NavController) {\n        val route = screen.route +\n                if (arguments.isNotEmpty()) \"/\" + arguments.joinToString(\"/\") else \"\"\n        if (popBackStack) navController.popBackStack()\n        navController.navigate(route)\n    }\n}\n\nenum class NAVGRAPH {\n    MAIN, BOTTOMBAR\n}\n```\n\n`MovieListUiEvent.kt`\n```kotlin\nsealed interface MovieListUiEvent {\n    data class Paginate(val category: MovieListCategory) : MovieListUiEvent\n    data class Navigate(\n        override val screen: Screen,\n        override val arguments: List\u003cString\u003e = emptyList(),\n        override val popBackStack: Boolean = false\n    ) : MovieListUiEvent, NavigationEvent()\n}\n```\n\n`ViewModelEvent.kt`\n```kotlin\ndata class ViewModelNavigateMainEvent(  \n    override val screen: Screen,  \n    override val arguments: List\u003cString\u003e,  \n    override val popBackStack: Boolean  \n) : NavigationEvent()  \n  \ndata class ViewModelNavigateBottomBarEvent(  \n    override val screen: Screen,  \n    override val arguments: List\u003cString\u003e = emptyList(),  \n    override val popBackStack: Boolean = false  \n) : NavigationEvent()  \n  \n  \nfun MovieListUiEvent.Navigate.toNavigateMainEvent(): ViewModelNavigateMainEvent {  \n    return ViewModelNavigateMainEvent(  \n        screen,  \n        arguments,  \n        popBackStack,  \n    )  \n}  \n  \nfun MovieListUiEvent.Navigate.toNavigateBottomBarEvent(): ViewModelNavigateBottomBarEvent {  \n    return ViewModelNavigateBottomBarEvent(  \n        screen,  \n        arguments,  \n        popBackStack,  \n    )  \n}\n```\n\n\n# Usage\n\n## Ui Events Production\n`BottomNavigationBar.kt`\n```kotlin\n@Composable\nfun BottomNavigationBar(onEvent: (MovieListUiEvent.Navigate) -\u003e Unit) {\n    val items = listOf(\n        BottomNavItem(Screen.PopularMovieList,  ...),\n        BottomNavItem(Screen.UpcomingMovieList, ...),\n    )\n\n    var selectedIndex by rememberSaveable { mutableIntStateOf(0) }\n\n    NavigationBar {\n        Row(\n            modifier = Modifier.fillMaxWidth(), horizontalArrangement = Arrangement.SpaceEvenly\n        ) {\n            items.forEachIndexed { index, bottomNavItem -\u003e\n                Add(bottomNavItem, index, selectedIndex) {\n                    selectedIndex = index    // TODO : Receive from VM\n                    onEvent(\n                        MovieListUiEvent.Navigate(\n                            screen = bottomNavItem.screen,\n                            popBackStack = true\n                        )\n                    )\n                }\n            }\n        }\n    }\n}\n\ndata class BottomNavItem(  \n    val screen: Screen, val title: String, val icon: ImageVector  \n)\n```\n\n`MovieListItem.kt`\n```kotlin\n@Composable  \nfun MovieListItem(movie: Movie, onEvent : (MovieListUiEvent.Navigate) -\u003e Unit) { \n    Column(modifier = Modifier \n\t\t.clickable {  \n            onEvent(MovieListUiEvent.Navigate(screen = Screen.Details, arguments = listOf(\"${movie.id}\")))  \n        })\n\t{\n\t\t...\n\t} \n}\n```\n\n## Consumption\n`ObserveAsEvents.kt`\n```kotlin\n@Composable\nfun \u003cT\u003e Flow\u003cT\u003e.ObserveAsEvents(onEvent: suspend (T) -\u003e Unit) {\n    val lifecycleOwner = LocalLifecycleOwner.current\n    LaunchedEffect(this) {\n        lifecycleOwner.repeatOnLifecycle(Lifecycle.State.STARTED) {\n            withContext(Dispatchers.Main.immediate) {\n                collect { event: T -\u003e onEvent(event) }\n            }\n        }\n    }\n}\n```\n\n`HomeScreen.kt`\n```kotlin\nfun HomeScreen(viewModel: MovieListViewModel) {  \n    val state = viewModel.movieListState.collectAsStateWithLifecycle().value  \n    val snackbarHostState = remember { SnackbarHostState() }  \n  \n    Scaffold(  \n        snackbarHost = {...},  \n        topBar = {...}, bottomBar = {  \n            BottomNavigationBar(  \n                onEvent = viewModel::onUiEvent  \n            )  \n        }) {  \n        Box(  \n            modifier = Modifier  \n                .fillMaxSize()  \n                .padding(it)  \n        ) {  \n            val bottomNavController = rememberNavController()  \n  \n            viewModel.bottomNavEventFlow.ObserveAsEvents{ event -\u003e  \n                event.navigate(bottomNavController)  \n            }\n\t\t}\n\t}\n}\n```\n\n`MainActivity.kt`\n```kotlin\n@AndroidEntryPoint\nclass MainActivity : ComponentActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContent {\n            Theme {\n                Surface(\n                    modifier = Modifier.fillMaxSize(), color = MaterialTheme.colorScheme.background\n                ) {\n                    val navController = rememberNavController()\n                    val viewModel = hiltViewModel\u003cMovieListViewModel\u003e()\n\n                    viewModel.mainNavEventFlow.ObserveAsEvents { event -\u003e\n                        event.navigate(navController)\n                    }\n\n                    NavHost(navController, startDestination = Screen.Home.route) {\n                        composable(Screen.Home.route) {\n                            HomeScreen(viewModel)\n                        }\n                        composable(\n                            route = Screen.Details.route + \"/{movieId}\",\n                            arguments = listOf(\n                                navArgument(\"movieId\") { type = NavType.IntType }\n                            )) {\n                            DetailsScreen()\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n```\n\nThis is all very basic and bare-bones. But it seemed like a reasonable solution to my problem was begging to be over-engineered. So i gave it my all. \n\nâï¸âï¸âï¸","lastmodified":"2024-07-04T20:24:17.041181982Z","tags":["Android","JetpackCompose"]},"/posts/Scoping-in-Hilt":{"title":"Scoping in Hilt","content":"### Injecting dependencies without defining a Module\nWith Hilt, injecting a simple dependency like `MyDependency` into a `ViewModel` is straightforward and doesn't require defining a `@Module`. By annotating the constructor of `MyDependency` with `@Inject`, Hilt can automatically provide it. Then, you can use the `@HiltViewModel` annotation for your `ViewModel` and inject `MyDependency` directly into its constructor using `@Inject`. This eliminates the need for additional configuration, allowing Hilt to manage the dependency injection seamlessly. Here's a quick example:\n\n```kotlin\nclass MyDependency @Inject constructor() {\n    fun someFunction(): Boolean = true\n}\n\n@HiltViewModel\nclass MyViewModel @Inject constructor(\n    private val myDependency: MyDependency\n) : ViewModel() {\n    fun checkDependency(): Boolean = myDependency.someFunction()\n}\n```\n\nThis setup allows `MyDependency` to be injected into `MyViewModel` effortlessly, leveraging Hilt's capabilities to reduce boilerplate code.\n\n\n\n### What are components in Hilt?\nThere are different Components that are tied to Android Framework Objects for their lifecycle and scoping, that you can install modules in using `@Module` and `@Installin`.\n\n`@Module @Installin(ActivityComponent::class)` for example will install the module in the Acitivty component. So everytime an activity or any of its children (fragment / view) requires an object of this module, it will be given a reference to a single instance maintained for all of them in that activity.\n\nOr as the documentation puts it : \n\u003e For each Android class in which you can perform field injection, there's an associated Hilt component that you can refer to in theÂ `@InstallIn`Â annotation. Each Hilt component is responsible for injecting its bindings into the corresponding Android class.\n\n\n### List all the Hilt Components used as Injectors for their corresponding Android Classes\n\nHilt provides the [following](https://developer.android.com/training/dependency-injection/hilt-android#generated-components) components to inject bindings into the corresponding Android Classes\n![|550](https://i.imgur.com/gi3QtoN.png)\n\n### What are the lifetimes of each of those components?\nHilt automatically creates and destroys instances of generated component classes following the lifecycle of the corresponding Android classes [as shown](https://developer.android.com/training/dependency-injection/hilt-android#component-lifetimes)\n\n\n![|725](https://i.imgur.com/T8JSl1y.png)\n\n\nI wrote a simple example to demonstrate how scoping works in hilt down below: \nhttps://github.com/xidsyed/HiltScopeExample.git","lastmodified":"2024-07-04T20:24:17.041181982Z","tags":["Android"]},"/thoughts/GPT4-Generates-Color-Palette":{"title":"GPT4 Generates Color Palette","content":"\n## I asked GPT4 to create a lighter version of the Nord color profile\n\n-   I seriously doubted it could do it. As intelligent as it is, playing with hexcodes, doesn't seem like a very easy task, without any additional tools, on top of that, it had to maintainÂ **306 lines of code**Â in it's context, and copy it all line for line, without making a single error, only swapping out lighter hex values for darker ones as deemed necessary\n-   Fully expecting it to crap itself after the 30th line or so, I decided to help it out a little and offered it 4 replacement 'darker' colors in exchange for the lighter ones\n\nYou can view myÂ [complete discussion with GPT4](https://drive.google.com/file/d/1mxCscZBZv4HqRQJFX-gn_ptv0CRD4XIn/view?usp=share_link)Â , where I later on ask it to generate a completely new color palette, based on color descriptions, ask it to modify the hexes to incorporate different tones, and even asked it to walk me through the process. It derps a little at the very end, but when prompted with 'can you go back and fix the error you made', it fixes the answer.\n\n## Impressions\n\nWhat impressed me the most:\n\n1.  It used my replacement colors, only where it deemed necessary.\n2.  It compensated the brightness of all the other colorsÂ **tastefully**. You can't look at the final result, and suspect that it was not created by a human. It's almost too perfect!!\n3.  No mistakes, all the other code as it is, first try.\n\nHere are the results:\n\n`_dark_syntax.scss`Â against dark backgroundÂ [![image](https://user-images.githubusercontent.com/26184016/234683393-44f46087-49ae-4b9a-9625-26323c94a4fa.png)\n\n`_dark_syntax.scss`Â against white backgroundÂ ![image|625](https://user-images.githubusercontent.com/26184016/234683582-5a20cb49-3ab7-42f9-a00d-ea91c2abbfe6.png)\n`gpt_4_generated_light_syntax.css`Â against white backgroundÂ ![image|625](https://user-images.githubusercontent.com/26184016/234683699-8d4390e9-0b51-4c95-944d-68dd69d33175.png)\nThese results, are not enough to cover all the colors included in the color profile. Will upload more.\n\nCheckout the original and modified [css files](https://gist.github.com/xidsyed/cb545a50e157e73c60b52c810fadabdf) and test them out for yourself!","lastmodified":"2024-07-04T20:24:17.05318217Z","tags":["ai"]},"/thoughts/Meaning-is-Objective":{"title":"Meaning is Objective","content":"\nIt is . I can prove it. More coming.","lastmodified":"2024-07-04T20:24:17.05318217Z","tags":["Untagged"]},"/thoughts/The-Resume":{"title":"The Resume","content":"# Hi ð¦\n\nHey there! Thanks for checking out my resume and my blog. Iâm always looking to improve, and Iâd love to hear your thoughts. Feel free to drop me a message on [Twitter](https://x.com/syedinator) or [LinkedIn](https://www.linkedin.com/in/syedmohsin01). \n\n### [Download Resume](https://drive.google.com/file/d/1AyPlkYymNRXf2F3aoObofHqlhkd3cNBJ/view?usp=sharing)\n","lastmodified":"2024-07-04T20:24:17.05318217Z","tags":["Untagged"]},"/thoughts/general-specific-problems":{"title":"general-specific problems","content":"\nA general-specific problem is a specific general problem that arises after you solve a general problem. What makes such a problem *general-specific* is that, despite being a 'specific' problem (not everyone who faces the general problem ends up facing this specific downstream problem), it is also fairly general (a substantial amount of people end up facing this very specific problem ) \n\nFor example. There are probably a thousand tutorials online showing you how to use  docker with docker-compose to deploy a server along with its database. The [[thoughts/general-specific problems|general-specific problems]] in this case could be \n- to use the docker-compose tooling in a CI CD pipeline\n- use mounts and volume to be able to create regular backups of the database\n\nGeneral and specific (fewer) problems, both get disproportionately more attention than they need and [[thoughts/general-specific problems|general-specific problems]] get disproportionately lesser.\n","lastmodified":"2024-07-04T20:24:17.05318217Z","tags":["Untagged"]}}